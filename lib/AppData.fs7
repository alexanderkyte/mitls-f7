module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open Stream 

type pre_app_state =
  {app_info: SessionInfo;
   app_incoming: stream;
   app_outgoing: stream}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes
  | ApplicationSend of SessionInfo * stream * bytes

type app_state = (aps:pre_app_state){ApplicationState(aps)}

(* type app_state // abstract type at the implementation level *)

(* Application interface *)

(* Add data to be sent to the other party *)
val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state
(* Retrieve data that we received from the other party *)
val retrieve_data: app_state -> int -> (bytes * app_state) option

(* Dispatcher interface *)
val init : i:SessionInfo{NonNullSession(i)} -> a:app_state

val next_fragment: aps:app_state -> int -> 
  (d:Record.fragment * aps':app_state{ApplicationSend(aps.app_info,aps.app_outgoing,d) /\ aps'.app_info = aps.app_info}) option

val recv_fragment: aps:app_state ->
          d:fragment{(?rs. ApplicationSend(OtherRole(aps.app_info),rs,d)) \/ Compromised(OtherRole(aps.app_info))} ->
	  app_state Result

(* Application state definition *)
assume !aps. ApplicationState(aps) <=> (Stream(aps.app_incoming) /\ Stream(aps.app_outgoing) /\
					((?raps. ApplicationState(raps) /\
					         Established(raps.app_info,raps.app_outgoing,aps.app_info,aps.app_incoming)) \/
				      Compromised(OtherRole(aps.app_info))))

(* TODO: Application state uniqueness *)
assume !aps,aps'. aps.app_info = aps'.app_info /\ ApplicationState(aps) /\ ApplicationState(aps') =>
        ( StreamID(aps.app_outgoing) = StreamID(aps'.app_outgoing) /\ StreamID(aps.app_incoming) = StreamID(aps'.app_incoming) )

(* When can we add data to the outgoing buffer *)
assume !aps,d. ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)

(* When we can send data on the network from the outgoing stream *) 
assume !aps,d. ApplicationState(aps) /\ StreamRead(aps.app_outgoing,d) => ApplicationSend(aps.app_info,aps.app_outgoing,d)

theorem !info,hist,d. ApplicationSend(info,hist,d) =>
	(?aps. ApplicationState(aps) /\ info = aps.app_info /\ hist = aps.app_outgoing /\ StreamRead(aps.app_outgoing,d))

ask !aps,rs,d. ApplicationState(aps) /\ ApplicationSend(OtherRole(aps.app_info),rs,d) =>
		((StreamRead(rs,d) /\ StreamID(rs) = StreamID(aps.app_incoming) ) \/ Compromised(OtherRole(aps.app_info)))

(* TODO: to be proven handshake/session modules? *)
theorem !aps. FreshSession(aps.info,Application_data) /\ IsEmptyStream(aps.app_incoming) => ApplicationState(aps)
