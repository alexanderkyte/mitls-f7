module TLS

open Error
open Bytes
open AppConfig
open DataStream
open AppDataStream
open Dispatch
open TLSInfo

type index  = ConnectionInfo
type cn   = Dispatch.Connection
type params = protocolOptions

val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}

function val Role: cn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

type (;c:cn) sameCn = c':cn{Role(c) = Role(c') /\ CnId(c) = CnId(c')}

function val Dual: ConnectionInfo -> ConnectionInfo
assume !ki. Dual(ki) = { id_in = ki.id_out; id_out = ki.id_in }

predicate val TXT: index -> bool
predicate val SEC: index -> bool
predicate val Fatal: (index * bytes) -> bool
predicate val Close: (index * bytes) -> bool
predicate val Write: (index * bytes) -> bool
predicate val Read : (index * bytes) -> bool

function val  ConnInStream: c:cn -> (; ConnectionInKeyInfo(c)) stream
function val ConnOutStream: c:cn -> (;ConnectionOutKeyInfo(c)) stream

assume !id, s.  ConnInStream(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. ConnOutStream(Conn(id, s)) = OutStream(id, s.appdata)

function val WrittenBytes: cn -> bytes
function val    ReadBytes: cn -> bytes

assume !c. WrittenBytes(c) =  ConnInStream(c)
assume !c.    ReadBytes(c) = ConnOutStream(c)

type (;c:cn, r:range)  indelta = (; ConnectionInKeyInfo(c),  ConnInStream(c), r) delta
type (;c:cn, r:range) outdelta = (;ConnectionOutKeyInfo(c), ConnOutStream(c), r) delta
type (;c:cn) query

predicate val OutSplit : // FIXME: ugly
    (rg0:range              * newrg:range                   * rg:range *
     c  :cn               * newc :cn                    *
     d0 :(;c, rg0) outdelta * newd :(;newc, newrg) outdelta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:cn * c':cn * rg:range * (;c, rg) outdelta) -> bool
predicate val  ReadExtend : (c:cn * c':cn * rg:range * (;c, rg)  indelta) -> bool
predicate val    NoExtend : (c:cn * c':cn) -> bool

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WrittenBytes(c') = WrittenBytes(c) @| d
    /\    ReadBytes(c') =    ReadBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
          ReadBytes(c') =    ReadBytes(c) @| d
    /\ WrittenBytes(c') = WrittenBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c'. NoExtend(c, c') <=>
          ReadBytes(c) =    ReadBytes(c')
    /\ WrittenBytes(c) = WrittenBytes(c')
    /\       Params(c) =       Params(c')

type (;c:cn) ioresult_i =
| ReadError of ErrorKind * ErrorCause
| Warning   of c':(;c) sameCn * alertDescription { NoExtend(c, c') }
| Fatal     of c':(;c) sameCn {TXT(CnId(c)) => Fatal(Dual(CnId(c)), ReadBytes(c))}
| Close of unit { TXT(CnId(c)) => Close(Dual(CnId(c)), ReadBytes(c))}
| CertQuery of c':(;c) sameCn * (;c') query
| Handshake of c':cn { Role(c) = Role(c') /\ WrittenBytes(c') = [||] /\ ReadBytes(c') = [||]}
| Read      of c':(;c) sameCn * rg:range * d:(;c, rg) indelta
  {    CnId(c) <> null /\ ReadExtend(c, c', rg, d)
    /\ TXT(CnId(c)) => Write(Dual(CnId(c)), ReadBytes(c')) }

val read : c:cn -> (;c) ioresult_i

type (;c:cn, rg:range, d:(;c, rg) outdelta) ioresult_o =
| WriteError    of ErrorKind * ErrorCause
| WriteComplete of c':(;c) sameCn { WriteExtend(c, c', rg, d) }
| WritePartial  of c':(;c) sameCn * rg':range * d':(;c', rg') outdelta
  { ?d0, rg0. WriteExtend(c, c', rg0, d0) /\ OutSplit(rg0, rg', rg, c, c', d0, d', d) }
| MustRead      of c':(;c) cn 
  { c':cn{Role(c) = Role(c') /\ ConnectionOutKeyInfo(c) = ConnectionOutKeyInfo(c') /\
    ReadBytes(c) = ReadBytes(c') /\ Params(c) = Params(c') }

val write: c:cn -> rg:range -> d:(;c, rg) delta -> (;c, rg, d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))

type (;r:role,p:parameters) nullCn = c:cn { CnId(c) = null /\ Params(c) = p /\ Role(c) = r }
val connect: Tcp.NetworkStream -> p:params                  -> (;Client,p) nullCn Result
val resume:  Tcp.NetworkStream -> p:params -> sid:sessionID -> (;Client,p) nullCn Result 
val accept:  Tcp.NetworkStream -> p:params                  -> (;Server,p) nullCn Result

// even if the server declines, we authenticate the client's intent to resume from the sid.

val rekey      : c:cn {Role(c)=Client} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val rehandshake: c:cn {Role(c)=Client} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val request    : c:cn {Role(c)=Server} -> (c':(;c) sameCn {NoExtend(c, c')}) Result
val shutdown   : c:cn                  -> (c':(;c) sameCn {NoExtend(c, c')}) Result
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:cn -> (;c) query -> (c': (;c) sameCn { NoExtend(c, c') }) Result
val refuse:    c:cn -> (;c) query -> unit
