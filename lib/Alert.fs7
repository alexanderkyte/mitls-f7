module Alert

(* We do not support sending warnings, as there is no good reason to do so *)

open Bytes
open Error
open Formats
open TLSInfo
open TLSPlain

type alertLevel =
  | AL_warning
  | AL_fatal
  | AL_unknown_level of byte

type alert =
  {level: alertLevel;
   description: alertDescription;}

type (;si:SessionInfo) messages = bytes

type (;siIN:SessionInfo,siOUT:SessionInfo) pre_al_state =
  {al_incoming: (;siIN)  messages;
   al_outgoing: (;siOUT) messages;}

predicate type preds =
    | AlertState of pre_al_state

type (;siIN:SessionInfo,siOUT:SessionInfo) state = (als:pre_al_state){AlertState(als)}

val init: i:SessionInfo -> s:state{s.al_info = i}

type ALFragReply =
    | EmptyALFrag
    | ALFrag of bytes
    | LastALFrag of bytes

val next_fragment: als:state -> int -> (r:ALFragReply * als':state)
  {   (als'.al_info = als.al_info) 
  /\  (r = EmptyALFrag => als' = als) 
//  /\  (!f. r = ALFrag(f)     => (UpperProtoSend(als.al_info,Alert,f) /\ Pub(f))
//  /\  (!f. r = LastALFrag(f) => (UpperProtoSend(als.al_info,Alert,f) /\ Pub(f)) 
  }

type alert_reply =
  | ALAck of state
  | ALClose of state
  | ALClose_notify of state
val intpair_of_alertDesc: alertDescription -> int * int
val level_of_int: int -> alertLevel
val desc_of_int: int -> alertDescription
val alert_of_intpair: int * int -> alert
val alert_of_bytes: bytes -> alert
val bytes_of_alertDesc: alertDescription -> bytes
val send_alert: state -> alertDescription -> state Result
val handle_alert: state -> alert -> alert_reply Result
//CF temp: val recv_fragment:  state -> Record.fragment -> alert_reply Result

