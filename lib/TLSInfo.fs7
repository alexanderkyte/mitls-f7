module TLSInfo

open Bytes
open TLSConstants


type sessionID = b:bytes {Length(b) <= 32}
// "An arbitrary byte sequence chosen by the server 
// to identify an active or resumable session state."
// treating [||] as the absence of identifier.

type preRole =
	| Client
	| Server
type Role = r:preRole{r = Client \/ r = Server}

// Client/Server randomness; 
// their first 4 bytes give the local time, 
// so that they are locally pairwise-distinct
type random = (;32) lbytes 
type crand = random
type srand = random

// SessionInfo and epoch: Session and Connection level public immutable data.
// Used for indexing

//CF 04-09
// the randoms are not just bytes.

type SessionInfo = {
    init_crand: crand;
    init_srand: srand;
	protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
    clientID: Cert.cert list;
    serverID: Cert.cert list;
    sessionID: sessionID;
    }
// for certificates, the empty list represents the absence of identity 
// (possibly refusing to present requested certs) 
//   
// for sessionID, the empty bytes [||] represents the absence of ID,
// that is, the session is not resumable. 

private type preEpoch =
  | InitEpoch of Role * random  (* our fresh local random *)
  | SuccEpoch of crand * srand  (* the latest randoms     *)
               * si:SessionInfo
			   * pred:preEpoch 

type epoch = p:preEpoch

function val Pred: epoch -> epoch
assume !cr,sr,si,pred. Pred(SuccEpoch(cr,sr,si,pred)) = pred

predicate NullSessionInfo of SessionInfo
assume !si. NullSessionInfo(si) <=> (si.clientID = [] /\ si.serverID = [] /\ si.sessionID = [||] /\
    IsNullCiphersuite(si.cipher_suite) /\ si.compression = NullCompression /\ si.init_crand = [||] /\ si.init_srand = [||] )

val null_sessionInfo: pv:ProtocolVersion -> si:SessionInfo{NullSessionInfo(si)}
val isNullSessionInfo: s:SessionInfo -> b:bool{b=true => NullSessionInfo(s)}

function val EpochSI: epoch -> SessionInfo
assume !r,o,si. si = EpochSI(InitEpoch(r,o)) <=> NullSessionInfo(si)
assume !c,s,si,p. EpochSI(SuccEpoch(c,s,si,p)) = si

val epochSI: e:epoch -> si:SessionInfo{si = EpochSI(e)}

val epochSRand: e:epoch -> b:crand{!b1,b2,si,pe. e = SuccEpoch(b1,b2,si,pe) => b = b2}
val epochCRand: e:epoch -> b:srand{!b1,b2,si,pe. e = SuccEpoch(b1,b2,si,pe) => b = b1}

type ConnectionInfo =
	{ role: Role;
	  id_in:  epoch;
      id_out: epoch}

val connectionRole: ci:ConnectionInfo -> r:Role{r = ci.role}

val initConnection: r:Role -> b:bytes ->
	ci:ConnectionInfo
val nextEpoch: e:epoch -> crand -> srand -> si:SessionInfo ->
	e':epoch


/// Predicates specifying cryptographic assumptions on algorithms 

// relocate to TLSConstants?
predicate CPA of cipherAlg
// some reasonable assumptions:
// assume(CPA(AES_128_CBC))
// assume(CPA(AES_256_CBC))

predicate CMA of hashAlg
// some reasonable assumptions:
// assume(CMA(SHA))
// assume(CMA(SHA256))
// assume(CMA(SHA384))

predicate CTXT of cipherAlg * hashAlg
// some reasonable assumptions:
// assume !e. PRF(m) => CTXT(AES_128_CBC,m)
// assume !e. PRF(m) => CTXT(AES_256_CBC,m)

predicate StrongAE of cipherSuite
predicate StrongAuth of cipherSuite

definition !s. StrongAE(s)   <=> (?e,m. IsAEADCiphersuite(s) /\ AEAlg(s) = MtE(e,m) /\ CPA(e) /\ CTXT(e,m))
definition !s. StrongAuth(s) <=> (?e,m. IsAEADCiphersuite(s) /\ AEAlg(s) = MtE(e,m) /\ CMA(m))


// Predicates specifying the security of TLS connections 

predicate type cryptopreds = 
  | SafeHS of epoch // specified by the Handshake
  | Safe of epoch // The epoch parameters yield privacy & integrity
  | Auth of epoch // The epoch parameters yield integrity (not necesarily privacy)
  
definition !i. Safe(i) <=> (SafeHS(i) /\ StrongAE(EpochSI(i).cipher_suite))
definition !i. Auth(i) <=> (SafeHS(i) /\ StrongAuth(EpochSI(i).cipher_suite))

// not quite derivable unless we add CTXT => CMA
assume !ki. Safe(ki) => Auth(ki) 

ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => not Safe(ki)
ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => 
    not (?kex,s. EpochSI(ki).cipher_suite = CipherSuite(kex,s))

// so that TLS can exchange any traffic on the initial null connection
ask !ki. IsNullCiphersuite(EpochSI(ki).cipher_suite)    => not Auth(ki)



/// Application configuration options

type helloReqPolicy =
    | HRPIgnore
    | HRPFull
    | HRPResume

type config = {
    minVer: ProtocolVersion;
    maxVer: ProtocolVersion;
    ciphersuites: cipherSuites;
    compressions: Compression list;

    (* Handshake specific options *)

    (* Client side *)
    honourHelloReq: helloReqPolicy;
    allowAnonCipherSuite: bool;

    (* Server side *)
    request_client_certificate: bool;
    check_client_version_in_pms_for_old_tls: bool;

    (* Common *)
    safe_renegotiation: bool;
	server_name: Cert.hint;
	client_name: Cert.hint;

    (* Sessions database *)
    sessionDBFileName: string;
    sessionDBExpiry: TimeSpan
    }

val defaultConfig: config
