module CRE

open Bytes
open TLSConstants
open TLSInfo
open PMS
open PRF

// concrete PMS --> MS derivation.
private val extractMS: si:SessionInfo {not SafeHS_SI(si)} -> p:bytes -> (;si) PRF.masterSecret

(** RSA ciphersuites **) 

//CF actually a private type 
type rsaentry = pk:RSAKey.pk * cv:ProtocolVersion * pms:(;pk,cv)rsapms * csr:bytes * pa:prfAlg * ms:(;(RSAPMS(pk,cv,pms),csr,pa)) ms
private val rsalog: rsaentry list ref 

private val rsaassoc: 
    pk:RSAKey.pk -> cv:ProtocolVersion -> pms:(;pk,cv)rsapms -> csr:bytes -> pa:prfAlg-> 
    (pk':RSAKey.pk * cv':ProtocolVersion * pms':(;pk',cv')rsapms * csr':bytes * pa':prfAlg * ms':(;(RSAPMS(pk,cv,pms'),csr',pa')) ms) list -> 
	ms:(;(RSAPMS(pk,cv,pms),csr,pa)) ms option

val extractRSA:
    si:SessionInfo ->
	cv:ProtocolVersion ->
    pms: (;Cert.RSAPKCert(si.serverID),cv) rsapms 
	// { DecryptedPMS(si.pmsdata,pms)  } 
	->
    (;si) PRF.masterSecret


open DHGroup

//CF actually a private type
type dhentry = p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * pms:(;p,g,gx,gy) dhpms * csr:csrands * pa:prfAlg * ms:(;(DHPMS(pms),csr,pa)) PRF.masterSecret
private val dhlog: dhentry list ref 

val dhassoc: p:p -> g:(;p) g -> gx:(;p) elt -> gy:(;p) elt -> pms:(;p,g,gx,gy) dhpms -> csr:csrands -> pa:prfAlg -> 
             (p':p * g':(;p') g * gx':(;p') elt * gy':(;p') elt * pms':(;p',g',gx',gy') dhpms * csr':csrands * pa':prfAlg * (;(DHPMS(pms'),csr',pa')) PRF.masterSecret) list -> 
             (;(DHPMS(pms),csr,pa)) PRF.masterSecret option

// AP: Don't we really want *any* link between si and (g,p,gx,gy)?
val extractDHE:
    si:SessionInfo ->
    p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms ->
    (;si) PRF.masterSecret
