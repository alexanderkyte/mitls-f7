module MAC

open Bytes
open TLSConstants
open TLSInfo

/// a refined, ideal interface for indexed MACs
/// this file is loosely synchronized with cma/mac2.fs7

//CF 12-02: we need to support agility here, 
//          guaranteeing that ki has a MAC, and 
//          providing exact lengths for keys and tags.


private type (;ki:succEpoch) key = {k:(x:bytes{Length(x) = MacKeySize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))})}
type text = bytes
type tag = bytes
predicate val Msg: epoch * text -> bool

val Mac:    ki:succEpoch -> k:(;ki) key -> t:text{Msg(ki,t)} -> t:tag{Length(t) = MacKeySize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))}
val Verify: ki:succEpoch -> k:(;ki) key -> t:text -> tag -> 
  v:bool{ (v=true /\ Auth(ki)) => Msg(ki,t) }

val GEN:    ki:succEpoch -> (;ki) key
val LEAK:   ki:epoch{not(Auth(ki))} -> (;ki)key -> bytes
val COERCE: ki:epoch{not(Auth(ki))} -> x:bytes{Length(x) = MacKeySize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))} -> (;ki)key
