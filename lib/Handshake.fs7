module Handshake

// We haven't yet verified the Handshake implementation against this interface.

open Bytes
open Error
open TLSInfo
open DataStream
open StatefulAEAD
open TLSConstants
open TLSExtensions

(* Message Predicates *)
type HandshakeType =
    | HT_hello_request
    | HT_client_hello
    | HT_server_hello
    | HT_certificate
    | HT_server_key_exchange
    | HT_certificate_request
    | HT_server_hello_done
    | HT_certificate_verify
    | HT_client_key_exchange
    | HT_finished

function val HTBytes: HandshakeType -> bytes

private assume
    HTBytes(HT_hello_request      ) = [|  0uy |] /\ 
    HTBytes(HT_client_hello       ) = [|  1uy |] /\
    HTBytes(HT_server_hello       ) = [|  2uy |] /\
    HTBytes(HT_certificate        ) = [| 11uy |] /\
    HTBytes(HT_server_key_exchange) = [| 12uy |] /\
    HTBytes(HT_certificate_request) = [| 13uy |] /\
    HTBytes(HT_server_hello_done  ) = [| 14uy |] /\
    HTBytes(HT_certificate_verify ) = [| 15uy |] /\
    HTBytes(HT_client_key_exchange) = [| 16uy |] /\
    HTBytes(HT_finished           ) = [| 20uy |]


val htBytes: ht:HandshakeType -> b:bytes{b=HTBytes(ht)}
val parseHt: b:bytes -> (ht:HandshakeType{b=HTBytes(ht)}) Result 

function val MessageBytes: HandshakeType * bytes -> bytes
private definition !ht,b. MessageBytes(ht,b) = HTBytes(ht) @| VLBytes(3,b)
val messageBytes: ht:HandshakeType -> x:bytes -> m:bytes{m = MessageBytes(ht,x)}
val parseMessage: buf:bytes -> ((rem:bytes * ht:HandshakeType * x:bytes * to_log:bytes)
				{buf = to_log @| rem /\ to_log = MessageBytes(ht,x)}) option Result

// Next predicate to make sure we can make fragments
predicate type unsafe = Unsafe of epoch
private assume !ki. Unsafe(ki) <=> not Auth(ki)
val makeFragment: ki:epoch -> b:bytes -> (r:range * (;ki,r) Fragment.fragment) * bytes


(* verify data authenticated by the Finished messages *)
type log = bytes         (* message payloads so far, to be eventually authenticated *) 
type cVerifyData = bytes (* ClientFinished payload *)
type sVerifyData = bytes (* ServerFinished payload *)


function val ClientHelloMsg: (ProtocolVersion * random * sessionID * cipherSuites * Compression list * bytes) -> bytes
definition !cv,clRdm,sid,cls,cm,ext,b.
  ClientHelloMsg(cv,clRdm,sid,cls,cm,ext) =
		MessageBytes(HT_client_hello,
                (VersionBytes(cv) @| 
                 clRdm @| 
                 VLBytes(1,sid) @| 
                 VLBytes(2,CipherSuitesBytes(cls)) @| 
                 VLBytes(1,CompressionsBytes(cm)) @| 
                 ext)
		)
                
val parseClientHello: m:bytes -> 
	(pv:ProtocolVersion * cr:bytes * sid:sessionID * cs:cipherSuites * cm:Compression list * ext:bytes{?cs',cm'. MessageBytes(HT_client_hello,m) = ClientHelloMsg(pv,cr,sid,cs',cm',ext)
                          /\ ContainsCipherSuites(cs',cs) /\ ContainsCompressions(cm',cm)}) Result
val clientHelloBytes: c:config -> cr:random -> sid:sessionID -> ext:bytes -> m:bytes{m = ClientHelloMsg(c.maxVer,cr,sid,c.ciphersuites,c.compressions,ext)}

function val ServerHelloMsg: (ProtocolVersion * random * sessionID * cipherSuite * Compression * bytes) -> bytes
private definition !pv,sr,sid,cs,cm,ext.
	ServerHelloMsg(pv,sr,sid,cs,cm,ext) =
		MessageBytes(HT_server_hello,
			(VersionBytes(pv) @|
			 sr @|
			 VLBytes(1,sid) @|
			 CipherSuiteBytes(cs) @|
			 CompressionBytes(cm) @|
			 ext)
		)

val serverHelloBytes: si:SessionInfo -> sr:random -> ext:bytes ->
	b:bytes{b = ServerHelloMsg(si.protocol_version,sr,si.sessionID,si.cipher_suite,
							   si.compression,ext)}
val parseServerHello: b:bytes ->
	((pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes)
	 {MessageBytes(HT_server_hello,b) = ServerHelloMsg(pv,sr,sid,cs,cm,ext)})
	Result

val helloRequestBytes: b:bytes{b=MessageBytes(HT_hello_request,[||])}
val CCSBytes: b:bytes{b=[|1uy|]}

function val ServerHelloDoneMsg: unit -> bytes
private definition ServerHelloDoneMsg() = MessageBytes(HT_server_hello_done,[||])

val serverHelloDoneBytes: b:bytes{b=ServerHelloDoneMsg()}

function val CertificateMsg: Cert.certchain -> bytes
private definition !cl. CertificateMsg(cl) = MessageBytes(HT_certificate,VLBytes(3,Cert.CertificateListBytes(cl)))

val serverCertificateBytes: cl:Cert.certchain ->
	b:bytes{b = CertificateMsg(cl)}

val clientCertificateBytes: clo: (Cert.certchain * 'a * 'b) option ->
	b:bytes{
		( clo = None /\ b = CertificateMsg([]) ) \/
		( ?cl,a',b'. clo = Some((cl,a',b')) /\ b = CertificateMsg(cl)
		)}

val parseCertificateList: b:bytes -> s:Cert.certchain ->
	(bl:Cert.certchain{
		s = [] => b = UnfoldBack(bl,[||])
	}) Result

val parseClientOrServerCertificate: b:bytes ->
	(bl:Cert.certchain{
	  MessageBytes(HT_certificate,b) = CertificateMsg(bl)
	}) Result

function val CertTypesBytes: certType list -> bytes
private definition !h,t.
	CertTypesBytes([]) = [||] /\
	CertTypesBytes(h::t) = CertTypeBytes(h) @| CertTypesBytes(t)

val parseCertificateTypeList: b:bytes ->
	(ctl:certType list{b = CertTypesBytes(ctl)}) Result

function val DistinguishedNameListBytes: string list -> bytes
private definition !h,t.
	DistinguishedNameListBytes([]) = [||] /\
	DistinguishedNameListBytes(h::t) = VLBytes(2,Utf8(h)) @| DistinguishedNameListBytes(t)
function val DistinguishedNamesBytes: string list -> bytes
private definition !l.
	DistinguishedNamesBytes(l) = VLBytes(2,DistinguishedNameListBytes(l))

val parseDistinguishedNameList: b:bytes -> s:string list ->
	(res:string list{?l. res = l @ s /\
		b = DistinguishedNameListBytes(l)
	}) Result

function val CertificateRequestMsg: ProtocolVersion * certType list * Sig.alg list option * string list -> bytes
private definition !ct,sa,dn.
	CertificateRequestMsg(TLS_1p2,ct,Some(sa),dn) =
		  CertTypesBytes(ct) @|
		  SigHashAlgsBytes(sa) @|
		  DistinguishedNamesBytes(dn)
	/\ 
	CertificateRequestMsg(TLS_1p1,ct,None,dn) =
		  CertTypesBytes(ct) @|
		  DistinguishedNamesBytes(dn)
	/\ 
	CertificateRequestMsg(TLS_1p0,ct,None,dn) =
		  CertTypesBytes(ct) @|
		  DistinguishedNamesBytes(dn)
	/\ 
	CertificateRequestMsg(SSL_3p0,ct,None,dn) =
		  CertTypesBytes(ct) @|
		  DistinguishedNamesBytes(dn)

// AP: I don't think many of these things will end up in the final sessionInfo.
// So, no need to be too precise.
val certificateRequestBytes: sign:bool -> cs:cipherSuite -> pv:ProtocolVersion ->
	b:bytes{?ct,sa.
		b = MessageBytes(HT_certificate_request,
		    CertificateRequestMsg(pv,ct,sa,[])
			)
	}

val parseCertificateRequest: ProtocolVersion -> bytes -> (certType list * Sig.alg list option * string list) Result

//function val ClientKeyExchangeMsg_RSA: pv:ProtocolVersion * si:SessionInfo * RSAKeys.pk * (;si,pv)CRE.rsapms -> bytes
function val ClientKeyExchangeMsg_RSA: pv:ProtocolVersion * bytes -> bytes

val clientKEXBytes_RSA: si:SessionInfo -> c:config ->
	((b:bytes * pms:(;Cert.RSAPKCert(si.serverID),c.maxVer)CRE.rsapms){
		?encpms. b=ClientKeyExchangeMsg_RSA(si.protocol_version,encpms)
		}) Result
val parseClientKEX_RSA: si:SessionInfo -> RSAKeys.sk -> pv:ProtocolVersion -> config -> b:bytes ->
	((;Cert.RSAPKCert(si.serverID),pv)CRE.rsapms{
		?encpms. ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) = MessageBytes(HT_client_key_exchange,b)
	}) Result

function val ClientKeyExchangeMsg_DHE: bytes -> bytes

val clientKEXExplicitBytes_DH: bytes -> bytes
val parseClientKEXExplicit_DH: bytes -> bytes Result
val clientKEXImplicitBytes_DH: bytes
val parseClientKEXImplicit_DH: bytes -> unit Result

(* Digitally signed and DHE parameters *)
val digitallySignedBytes: Sig.alg -> bytes -> ProtocolVersion -> bytes
val parseDigitallySigned: Sig.alg list -> bytes -> ProtocolVersion -> (Sig.alg * bytes) Result

val dheParamBytes: bytes -> bytes -> bytes -> bytes
val parseDHEParams: bytes -> (bytes * bytes * bytes * bytes) Result

function val ServerKeyExchangeMsg_DHE:  ProtocolVersion * p:bytes * g:bytes * y:bytes * Sig.alg * sign:bytes-> bytes

val serverKeyExchangeBytes_DHE: bytes -> Sig.alg -> bytes -> ProtocolVersion -> bytes
val parseServerKeyExchange_DHE: ProtocolVersion -> cipherSuite -> bytes -> (bytes * bytes * bytes * Sig.alg * bytes) Result

function val ServerKeyExchangeMsg_DH_anon: bytes * bytes * bytes -> bytes

//function val CertificateVerifyMsg: si:SessionInfo * (;si)PRF.masterSecret * a:Sig.alg * Cert.certchain * (;a)Sig.pkey * log -> bytes
function val CertificateVerifyMsg: ProtocolVersion -> Sig.alg -> bytes -> bytes

val makeCertificateVerifyBytes: si:SessionInfo -> (;si)PRF.masterSecret -> a:Sig.alg -> (;a)Sig.skey -> l:log ->
	b:bytes{
	  ?sign. b = CertificateVerifyMsg(si.protocol_version,a,sign)
	}
val certificateVerifyCheck: si:SessionInfo -> (;si)PRF.masterSecret -> a:Sig.alg list -> l:log -> payload:bytes ->
	b:bool{
	  b = true =>
		?sign. MessageBytes(HT_certificate_verify,payload) = CertificateVerifyMsg(si.protocol_version,a,sign)
		// /\ Something good about signature check
	}

//function val ServerFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ServerFinishedMsg: sVerifyData -> bytes

//function val ClientFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ClientFinishedMsg: cVerifyData -> bytes

function val ClientFinished_Full_RSA_Auth: (ProtocolVersion * random * sessionID * cipherSuites * Compression list * bytes) * (* Client Hello *)
                                           (ProtocolVersion * random * sessionID * cipherSuite * Compression * bytes) *       (* Server Hello *)
                                           (bytes list) *                                                                     (* Server Certificate *)
                                           (ProtocolVersion * certType list * Sig.alg list option * string list) *            (* Server Certificate Request *)
                                           (bytes list) *                                                                     (* Client Certificate *)
                                           (pv:ProtocolVersion * si:SessionInfo * RSAKeys.pk * (;si,pv)CRE.rsapms) *          (* Client Key Exchange *)
                                           (si:SessionInfo * (;si)PRF.masterSecret * a:Sig.alg * Cert.certchain * (;a)Sig.pkey * log) -> (* Client Certificate Verify *)
                                           bytes

function val ClientOrServerCertificateMsg: Cert.certchain -> bytes

predicate ServerLogBeforeClientCertificateRSA_Auth of SessionInfo * ProtocolVersion * log 

predicate ServerLogBeforeClientCertificateRSA_NoAuth of SessionInfo * ProtocolVersion * log 

private assume !si,pv,l. 
  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l) <=>
  (?cs,cm,sess,ex1,ex2,ctl,sal,nl. 
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
          ClientOrServerCertificateMsg(si.serverID) @|
          CertificateRequestMsg(si.protocol_version,ctl,sal,nl) @|
          ServerHelloDoneMsg()))

private assume !si,pv,l. 
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l) <=>
  (?cs,cm,sess,ex1,ex2. 
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
          ClientOrServerCertificateMsg(si.serverID) @|
          ServerHelloDoneMsg()))
          

predicate ServerLogBeforeClientKeyExchangeRSA_Auth of SessionInfo * ProtocolVersion * log 
predicate ServerLogBeforeClientKeyExchangeRSA_NoAuth of SessionInfo * ProtocolVersion * log 

private assume !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l) <=>
  (?l'. ServerLogBeforeClientCertificateRSA_Auth(si,pv,l') /\
        l = l' @| ClientOrServerCertificateMsg(si.clientID))

private assume !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l) <=>
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l)

predicate ServerLogBeforeClientCertificateVerify_Auth of SessionInfo * log 
predicate ServerLogBeforeClientCertificateVerify_NoAuth of SessionInfo * log 
private assume !si,l.
  ServerLogBeforeClientCertificateVerify_Auth(si,l) <=>
  (?pv,l',k,pms. ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l) /\
                 l = l' @| ClientKeyExchangeMsg_RSA(pv,si,k,pms))
private assume !si,l.
  ServerLogBeforeClientCertificateVerify_NoAuth(si,l) <=>
  (?pv,l',k,pms. ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l) /\
                 l = l' @| ClientKeyExchangeMsg_RSA(pv,si,k,pms))

predicate ServerLogBeforeClientFinished_Auth of SessionInfo * log 
predicate ServerLogBeforeClientFinished_NoAuth of SessionInfo * log
private assume !si,l.
  ServerLogBeforeClientFinished_Auth(si,l) <=>
  (?l',ms,a,k. ServerLogBeforeClientCertificateVerify_Auth(si,l') /\
   (l = l' @| CertificateVerifyMsg(si,ms,a,si.clientID,k,l)))
private assume !si,l.
  ServerLogBeforeClientFinished_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateVerify_NoAuth(si,l)

predicate ServerLogBeforeServerFinished_Auth of SessionInfo * log 
predicate ServerLogBeforeServerFinished_NoAuth of SessionInfo * log 
private assume !si,l.
  ServerLogBeforeServerFinished_Auth(si,l) <=>
  (?l',ms. ServerLogBeforeClientFinished_Auth(si,l') /\
   (l' = l @| ClientFinishedMsg(si,ms,l')))
private assume !si,l.
  ServerLogBeforeServerFinished_NoAuth(si,l) <=>
  (?l',ms. ServerLogBeforeClientFinished_NoAuth(si,l') /\
   (l' = l @| ClientFinishedMsg(si,ms,l')))


predicate ClientLogBeforeServerHello of random * sessionID * log 
predicate ClientLogBeforeServerCertificateRSA of SessionInfo * log 

private assume !cr,sid,l.
  ClientLogBeforeServerHello(cr,sid,l) <=>
  (?pv,cs,cm,ex1. l = ClientHelloMsg(pv,cr,sid,cs,cm,ex1))

private assume !si,l.
  ClientLogBeforeServerCertificateRSA(si,l) <=>
  (?l',cr,sid,ex2. 
     ClientLogBeforeServerHello(cr,sid,l') /\
     l = l' @| 
         ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2))

predicate ClientLogBeforeCertificateRequestRSA of SessionInfo * log 

private assume !si,pv,l. 
  ClientLogBeforeCertificateRequestRSA(si,l) <=>
  (?l'. ClientLogBeforeServerCertificateRSA(si,l') /\
     l = l @| ClientOrServerCertificateMsg(si.serverID))


predicate ClientLogBeforeServerHelloDoneRSA_Auth of SessionInfo * log 
predicate ClientLogBeforeServerHelloDoneRSA_NoAuth of SessionInfo * log 

private assume !si,pv,l. 
  ClientLogBeforeServerHelloDoneRSA_Auth(si,l) <=>
  (?l',ctl,sal,nl. ClientLogBeforeCertificateRequestRSA(si,l) /\
     l = CertificateRequestMsg(si.protocol_version,ctl,sal,nl))

private assume !si,pv,l. 
  ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l) <=>
  ClientLogBeforeCertificateRequestRSA(si,l)

predicate ClientLogBeforeClientFinished_Auth of SessionInfo * log 
private assume !si,pv,l. 
  ClientLogBeforeClientFinished_Auth(si,l) <=>
  (?l',l'',pv,k,pms,ms,a,k'. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l'' = l' @| ServerHelloDoneMsg() 
         @| ClientOrServerCertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(pv,si,k,pms) /\
     l = l''
         @| CertificateVerifyMsg(si,ms,a,si.clientID,k',l''))

predicate ClientLogBeforeClientFinished_NoAuth of SessionInfo * log 
private assume !si,pv,l. 
  ClientLogBeforeClientFinished_Auth(si,l) <=>
  (?l',pv,k,pms,ms,a,k'. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg() 
         @| ClientOrServerCertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(pv,si,k,pms))

predicate ClientLogBeforeServerFinished_Auth of SessionInfo * log 
predicate ClientLogBeforeServerFinished_NoAuth of SessionInfo * log 

private assume !si,pv,l. 
  ClientLogBeforeServerFinished_Auth(si,l) <=>
  (?l',ms. ClientLogBeforeClientFinished_Auth(si,l') /\
     l = l' @| ClientFinishedMsg(si,ms,l'))

private assume !si,pv,l. 
  ClientLogBeforeServerFinished_NoAuth(si,l) <=>
  (?l',ms. ClientLogBeforeClientFinished_NoAuth(si,l') /\
     l = l' @| ClientFinishedMsg(si,ms,l'))

type serverState =  (* note that the CertRequest bits are determined by the config *) 
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log){ServerLogBeforeClientCertificateRSA_Auth(si,pv,l)}
   | ServerCheckingCertificateRSA of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log * b:bytes){ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l)}
   | ClientKeyExchangeRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log){ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l)}

   | ClientCertificateDH          of si:SessionInfo * l:log
   | ServerCheckingCertificateDH  of si:SessionInfo * l:log * b:bytes
   | ClientKeyExchangeDH          of si:SessionInfo * l:log

   | ClientCertificateDHE         of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log
   | ServerCheckingCertificateDHE of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log * bytes
   | ClientKeyExchangeDHE         of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | CertificateVerify            of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientCertificateVerify_Auth(si,l)}
   | ClientCCS                    of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientFinished_Auth(si,l)}
   | ClientFinished               of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeClientFinished_Auth(si,l)}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * cVerifyData * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeServerFinished_Auth(si,l)}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRF.masterSecret * cVerifyData * sVerifyData

   | ServerWritingCCSResume       of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;epochSI(ew))PRF.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ClientCCSResume              of e:succEpoch * (;e)StatefulAEAD.reader * sVerifyData * (;EpochSI(e))PRF.masterSecret * log
   | ClientFinishedResume         of si:SessionInfo * (;si)PRF.masterSecret * sVerifyData * log

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type clientState = 
   | ServerHello                  of cr:crand * sid:sessionID (* * bytes for extensions? *) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,sid,l)}

   | ServerCertificateRSA         of si:SessionInfo * l:log{ClientLogBeforeServerCertificateRSA(si,l)}
   | ClientCheckingCertificateRSA of si:SessionInfo * l:log * b:bytes{ClientLogBeforeCertificateRequestRSA(si,l)}
   | CertificateRequestRSA        of si:SessionInfo * l:log{ClientLogBeforeCertificateRequestRSA(si,l)} (* both certificate request and hellodone will be accepted *)
   | ServerHelloDoneRSA           of si:SessionInfo * c:Cert.sign_cert * l:log{ClientLogBeforeServerHelloDoneRSA_Auth(si,l)}

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of SessionInfo * log
   | ClientCheckingCertificateDHE of SessionInfo * log * bytes
   | ServerKeyExchangeDHE         of SessionInfo * log
   | CertificateRequestDHE        of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log
   | ServerHelloDoneDHE           of SessionInfo * Cert.sign_cert * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRF.masterSecret * l:log{ClientLogBeforeClientFinished_Auth(si,l)}
   | ServerCCS              of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.reader * cVerifyData * l:log){EpochSI(e)=si /\
                                                                                                                                   ClientLogBeforeServerFinished_Auth(si,l)}
   | ServerFinished         of si:SessionInfo * (;si)PRF.masterSecret * cVerifyData * l:log{ClientLogBeforeServerFinished_Auth(si,l)}

   | ServerCCSResume        of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;EpochSI(ew))PRF.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ServerFinishedResume   of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRF.masterSecret * log
   | ClientWritingCCSResume of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRF.masterSecret * sVerifyData * log
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of clientState
  | PSServer of serverState

private type pre_hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config; 
  sDB: SessionDB.SessionDB;
  (* current handshake & session we are establishing *) 
  pstate: protoState;
}

(*--- controlinterface *)
(* Control Interface *)

private type (;ci:ConnectionInfo) hs_state = pre_hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
predicate val Authorize: config * Cert.cert -> bool
predicate val Complete: ConnectionInfo * config -> bool
predicate EvSentFinishedFirst of ConnectionInfo * bool
// AP: Not sure the SentCCS event is useful;
// rather I'd welcome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool

function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream

predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
assume !ci,s. EmptyStreams(ci,s) <=> (
		EmptyStream(ci.id_in,HSInStream(ci,s)) /\
		EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
		EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
		EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
assume !ci,s,s'. SameStreams(ci,s,s') <=> (
		HSInStream(ci,s') = HSInStream(ci,s) /\
		CCSInStream(ci,s') = CCSInStream(ci,s) /\
		HSOutStream(ci,s') = HSOutStream(ci,s) /\
		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:        r:Role            -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = r /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)
		}
val resume:      nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = Client /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)}
val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val rekey:       ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val authorize:   ci:ConnectionInfo -> s:(;ci)hs_state -> c:Cert.certchain  ->
	s':(;ci,Config(ci,s))nextState { Authorize(Config(ci,s),c) /\ SameStreams(ci,s,s') }
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState{SameStreams(ci,s,s')}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState{SameStreams(ci,hs,s')}
  | OutSome of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutCCS of  (rg:range * f:(;ci.id_out,rg)Fragment.fragment * 
               ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * s':(;ci',Config(ci,hs))nextState)
               { SentCCS(ci'.id_out) /\
			     StatefulPlain.EmptyHistory(ci'.id_out,cs.history) /\
			      ci.id_out = Pred(ci'.id_out) /\
                              ci.id_in = ci'.id_in /\
                              ci.role = ci'.role /\
				 (Auth(ci.id_out) => Fragment.Fragment(ci.id_out,CCSOutStream(ci,hs),rg,f) ) /\
				 EmptyStream(ci'.id_out,HSOutStream(ci',s')) /\
				 EmptyStream(ci'.id_out,CCSOutStream(ci',s')) /\
				 HSInStream(ci',s') = HSInStream(ci,hs) /\
				 CCSInStream(ci',s') = CCSInStream(ci,hs)
				 }
  | OutFinished of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true) /\
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutComplete of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs)) /\
					(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
					HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
					CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
					HSInStream(ci,s') = HSInStream(ci,hs) /\
					CCSInStream(ci,s') = CCSInStream(ci,hs)
				   }
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.certchain * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getMinVersion:        ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

/// Misc

// 
// //TODO? change sessionID to uniformally use [||] instead of None.
// 
// /// Handshake message format 
// 
// // we need a precise spec, as verifyData is a series of such messages.
// 
// function val MessageBytes: HandshakeType * bytes -> bytes 
// definition !ht,payload. MessageBytes(ht,payload) = HTBytes(ht) @| VLBytes(3,data)
// 
// val makeMessage: ht:HandshakeType -> payload:bytes -> msg:bytes { msg = MessageBytes(ht,payload) }
// val parseMessage: hs_state -> (hs_state * ht:HandshakeType * payload:bytes * msg:bytes { msg = MessageBytes(ht,payload) }) option
// //TODO unclear how to usefully maintain hs_state invariant; pass instead state.incoming? 
// 
// /// Client Hello 
// 
// 
// function val ClientHelloBytes: ... 
// definition !cv,clRdm,sid,clientCipherSuites,cm,ext.
//   ClientHelloBytes(cv,clRdm,sid,clientCipherSuites,cm,ext) = 
//     MessageBytes(
// 	  HT_client_hello, 
//       VersionBytes cv @| CRBytes clRdm @| SidBytes sid @| CipherSuitesBytes clientCipherSuites @| CompressionsBytes cm @| ext )
// 
// //TODO get rid of the intermediate record
// //TODO factor out extension processing
// val makeClientHelloBytes: ... -> msg:bytes { msg = ClientHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( cv,clRdm,sid,clientCipherSuites,cm,ext { MessageBytes(HT_client_hello,payload) =  ClientHelloBytes(...) }  ) Result
// 
// /// Server Hello 
// 
// function val ServerHelloBytes: ... // (sv,sr,sid,cs,cm,extensions) 
// definition !sv,sr,sid,cs,cm,ext.
//   ServerHelloBytes(sv,sr,sid,cs,cm,ext) =
//     MessageBytes(
// 	  HT_server_hello, 
//       VersionBytes sv @| CRBytes sr @| SidBytes sid @| CipherSuiteBytes cs @| CompressionsBytes cm @| ext )
// 
// val makeServerHelloBytes: ... -> msg:bytes { msg = ServerHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( sv,sr,sid,cs,cm,ext { MessageBytes(HT_server_hello,payload) = ServerHelloBytes(sv,sr,sid,cs,cm,ext) } ) Result
// 
// /// Certificate chains
// 
// function val CertificateListBytes: Cert.cert list -> bytes
// definition CertificateListBytes([]) = [||] 
// definition !c,cs. CertificateListBytes(c::cs) = CertificateBytes(c) @| CertificateListBytes(cs)
// 
// function val CertsBytes: Cert.cert list -> bytes
// definition !cs. CertsBytes(cs) = VLBytes 3 (CertificateListBytes(cs))
// 
// function val CertificateBytes: Cert.cert list -> bytes
// definition !certs. CertificateBytes(certs) = MessageBytes(HT_certificate,CertsBytes(certs))
// 
// val makeCertificateBytes: certs:Cert.cert list -> msg:bytes { msg = CertificateBytes(certs) }
// val parseCertificate: payload:bytes -> (certs:Cert.cert list{ MessageBytes(HT_certificate,CertsBytes(certs)) = CertificateBytes(certs) } ) Result
// 
// /// Server Hello Done
// 
// val serverHelloDoneBytes: msg:bytes { msg = Message(HT_server_hello_done,[||]) }
// 
// /// Client Key Exchange (for now only for RSA); note that this message is randomized.
// 
// predicate val ClientKeyExchangeBytes: pms * pkey * bytes -> bool (* with some injectivity properties *)
// definition !pms,pkey. ClientKeyExchangeBytes(pms,pkey,msg) =
//   ?cipher. Encrypted(pms,pkey,cipher) /\ msg = MessageBytes(HT_client_key_exchange, cipher)
// 
// //TODO makeClientKeyExchangeBytes actually generates the pms?!
// 
// val makeClientKexRsaBytes: pms:pms -> pkey:pkey -> msg:bytes { ClientKeyExchangeBytes(pms,pkey,msg) }  
// val parseClientKexRsa: si:SessionInfo -> payload:bytes -> pms:pms { !cs. si.serverID = Some(cs)  = ClientKeyExchangeBytes(pms,CertsPKey(cs),MessageBytes(HT_client_key_exchange,payload)) } 
// 
// /// State-machine invariants (sample)
// 
// // Full handshake, RSA with anonymous client, waiting for ClientKeyExchange:
// 
// config, si, log { 
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,    certs, ts 
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(certs)
//       @|  serverHelloDoneBytes
//      
//  /\ (si.sessionID = [||] \/ si.sessionID <> clientSid) (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.maxVer) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ si.compression in config.compressions
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(certs)
// }
// 
// // Idem, after a few more steps
// 
// config, si, log, pms {
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,     cs, ts,    cipher  
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(cs)
//       @|  serverHelloDoneBytes
// 	  @|  ClientKeyExchangeBytes(cipher)
//      
//  /\ si.sessionID <> clientSid (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.ver) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(cs)
// 
//  (* after ClientKeyExchange *)
//  /\ ...
// 
//  (* after accepting Finished *) 
//  /\ ( Honest(pms) /\ StrongHS(si.cipherSuite) -> ?clientConfig. ClientFinished(clientConfig,si) /\ clientVer = clientConfig.maxVer /\ ...  (* we may also rewrite the whole invariant by unification *) ) 
// 
// }
// 
// 
// 
