module Record

open Bytes
open Error
open TLSInfo
open FragCommon
open TLSFragment
open Formats
open CipherSuites
open AEAD

type (;ki:KeyInfo) ConnectionState =
	| NullState
	| SomeState of (;ki)TLSFragment.history * (;ki)StatefulAEAD.state

type (;ki:KeyInfo) sendState = (;ki) ConnectionState 
type (;ki:KeyInfo) recvState = (;ki) ConnectionState

val initConnState: ki:KeyInfo -> state:(;ki) StatefulAEAD.state -> 
                   cs:(;ki) ConnectionState //{cs = SomeSate(state)}
val nullConnState: ki:KeyInfo -> cs:(;ki) ConnectionState //{cs = NullState}

private val makePacket: ContentType -> ProtocolVersion -> bytes -> bytes

val headerLength: b:bytes{Length(b) = 5} -> (n:nat{n>0 /\ n <= max_TLSCipher_fragment_length}) Result

private val parseHeader: b:bytes{Length(b) = 5} ->
	((ContentType * ProtocolVersion * n:nat){n>0 /\ n <= max_TLSCipher_fragment_length}) Result

// FIXME: Remove next assume!
// private assume !ki,tlen,t. MAC.Msg(ki,tlen,t)

val recordPacketOut: ki:KeyInfo -> 
                     ss:(;ki) sendState -> 
                     rg:DataStream.range -> ct:ContentType -> 
                     f:(;ki,ct,h,rg) TLSFragment.fragment -> //FIXME: history 'h' is only valid in ss if ss is not null!
                     (ss':(;ki) sendState * wire:bytes)
 
val recordPacketIn : ki:KeyInfo ->
                     rs:(;ki) recvState ->
                     wire:bytes{Length(wire) >= 5} -> 
                     (rs':(;ki)recvState *
                        ct:ContentType * pv:ProtocolVersion *
                        rg:range * 
                        f:(;ki,ct,h,rg) TLSFragment.fragment) Result //FIXME: history 'h' is only valid in ss if ss is not null!

