#! /usr/bin/env python

import sys, os, re, codecs, StringIO as sio

# --------------------------------------------------------------------
def _noexn(f):
    try: f()
    except: pass

# --------------------------------------------------------------------
def parser():
    import pyparsing as p

    def internal_comment(comment):
        return comment.strip()[0:1] != '@'

    ml_comments = p.Regex(r'\(\*(?:[^*]*\*+)+?\)')
    ss_comments = p.Regex(r'//.*')
    ml_strings  = p.Regex(r'"(?:[^"\n\r\\]|(?:"")|(?:\\x[0-9a-fA-F]+)|(?:\\.))*"')

    def ml_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:-2]) else tk
    ml_comments.setParseAction(ml_comments_action)

    def ss_comments_action(_s, _loc, tk):
        return [] if internal_comment(tk[0][2:]) else tk
    ss_comments.setParseAction(ss_comments_action)

    return ml_comments | ss_comments | ml_strings

# --------------------------------------------------------------------
def filter_hashes(input):
    hif    = re.compile(r'^\s*#\s*if\s+(\w+)\s*$')
    helse  = re.compile(r'^\s*#\s*else\b')
    hend   = re.compile(r'^\s*#\s*endif\b')
    hashes = []
    output = []

    for line in input:
        m = None
        for i, r in enumerate([hif, helse, hend]):
            m = re.search(r, line)
            if m is not None: break

        if m is not None:
            if i == 0:
                hashes.append((m.group(1), True))
            elif i == 1:
                if hashes and hashes[-1][1]:
                    hashes[-1] = (hashes[-1][0], False)
            elif i == 2:
                if hashes:
                    hashes.pop()
        else:
            if all([not x[1] for x in hashes]):
                output.append(line)

    return output

# --------------------------------------------------------------------
def _options(args):
    from optparse import OptionParser

    parser = OptionParser(usage = '%prog <options> [filenames...]')
    parser.add_option("-B", None,
                      action  = "store_false",
                      dest    = "backup",
                      help    = "do NOT create a backup file",
                      default = True,
                      metavar = "BACKUP")
    parser.add_option("-c", "--header",
                      dest    = "header",
                      help    = "add header from HEADER",
                      metavar = "HEADER")

    (options, args) = parser.parse_args()

    return (options, args)

# --------------------------------------------------------------------
def _read_file(filename):
    contents = open(filename, 'rb').read()

    if contents.startswith(codecs.BOM_UTF8):
        return unicode(contents[len(codecs.BOM_UTF8):], 'utf-8')
    return unicode(contents, 'utf-8')

# --------------------------------------------------------------------
CRLN = '\r\n'

def _process_file(filename, options):
    output = parser().transformString(_read_file(filename))
    output = output.splitlines()
    output = filter_hashes(output)
    output = CRLN.join(output) + CRLN
    output = re.sub('(?:\r\n){3,}', 2 * CRLN, output)
    output = re.sub('(?:\r\n)+$', CRLN, output)
    output = re.sub('^(?:\r\n)*', CRLN, output)

    if options.header:
        output = CRLN.join(options.header.splitlines()) + CRLN + output

    if options.backup:
        if os.path.exists(filename + '~'):
            os.unlink(filename + '~')
        os.rename(filename, filename + '~')
    else:
        os.unlink(filename)

    try:
        with codecs.open(filename, 'w', 'utf-8') as ostream:
            ostream.write(output)
    except:
        _noexn(lambda : os.unlink(filename))
        raise

# --------------------------------------------------------------------
def _main():
    options, filenames = _options(sys.argv[:1])

    if options.header:
        options.header = open(options.header, 'r').read().splitlines()
        options.header = [' * ' + x for x in options.header]
        options.header = ['(*'] + options.header + [' *)']
        options.header = CRLN.join(options.header)

    for filename in filenames:
        _process_file(filename, options)

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()
