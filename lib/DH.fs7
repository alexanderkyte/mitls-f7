module DH

// for TLS, we index all values by local randomness 
// unclear how to deal with public parameters

// RFC 5246 8.2.1: 
//   A conventional Diffie-Hellman computation is performed.  The
//   negotiated key (Z) is used as the pre_master_secret, and is converted
//   into the master_secret, as specified above. Leading bytes of Z that
//   contain all zero bits are stripped before it is used as the
//   pre_master_secret.
// // why?? is it treated in PRF smoothness? 

// values of *any* size in 1..2^16 may be used ?? 
type bigInt
type bigIntbytes = (;(1,65535)) rbytes 
type (;p) elt = e:bigInt { 0 < e /\ e < p }  

// raw modular exponentiation
private val exp: p:bigInt -> g:(;p) elt -> x:bigInt -> e:(;p) elt

val bigIntBytes: bigInt -> bytes 
val parseBigInt: bytes -> bigInt
// binary format for bigInt, variable 2-byte length, big-endian;
// the first byte cannot be 0;
// this guarantees that every bigInt as a unique binary representation.

// public DH parameters, chosen by the server.
// validity? normally p should be prime and g < p
type pp = p: bigInt * g: (;p) elt 

type id = bytes
type (;i:id,pp:pp) x // bigInt, secret exponent
// indexing guarantees that any given private key is used with at most one pp
  
type (;i:id,pp:pp) gx = e:elt // { e = g^x mod p }

type eltrepr = bytes
val elt:     i:id -> (;i) gx -> gxrepr
val eltrepr: i:id -> gxrepr -> (;i) gx 

// TODO: corruption

type (;i:id,gy:elt) gxy // shared secret

val gen:   i:id -> (;i) x * (;i) gx
val share: i:id -> (;i) x -> j:id -> (;j) gx -> (;i,j) gxy


// ideally, 
// - we keep a table of generated exchange values, (i:id * pp:pp * (;i,pp) gx) list 
// - we keep a table of computed shared secrets,   (i:id * j:id * pp:pp * (;i,j) gxy) list 
//   (where i and i are matching indexes in the first table, irrespective of how gy was received)
// - relying on DDH, we replace those computations by fresh sampling of g^z

// let split n = let d = n / 2 in d, n - 2*d ;;
// let (mod) v p = let d = v / p in v - d * p ;;
// let rec expmod p g n = if n = 0 then 1 else let (d,r) = split n in let e = expmod p g d in let e2 = (e * e) mod p in if r=0 then e2 else (e2 * g) mod p ;;