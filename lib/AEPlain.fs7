module AEPlain

open Bytes
open TLSInfo
open TLSFragment
open DataStream

// AP and CF agree: AEPlain is indexed by (ki and) its public length, after encoding (and not by range).
// We define function from:
// - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
// - from tlen to public range of decoded authenticated fragment
// - (and the inverse functions)

function val PlainLength: ki:KeyInfo -> l1:nat ->
	l2:nat //{ki.sinfo.protocol_version == (SSL3p0 || TLS1p0) => l1 = l2 /\
		   // ki.sinfo.protocol_version == (TLS1p1 || TLS1p2) => l1 = l2 + IVSize(ki))}

private type (;ki:KeyInfo,tlen:nat) plain = {p: (x:bytes){Length(x) = PlainLength(ki,tlen)}}
val plain: ki:KeyInfo -> tlen:nat -> b:bytes{Length(b) = PlainLength(ki,tlen)} -> (;ki,tlen) plain
val repr: ki:KeyInfo -> tlen:nat -> (;ki,tlen) plain -> b:bytes{Length(b) = PlainLength(ki,tlen)}

// Plaintext of MAC (addData + TLSFragment.fragment)
private type (;ki:KeyInfo) MACPlain = {macP:bytes}
private type (;ki:KeyInfo) tag = {macT:bytes}

val tagRepr: ki:KeyInfo -> (;ki)tag -> bytes

function val MsgBytes: pv:CipherSuites.ProtocolVersion * (;pv) TLSFragment.addData * bytes  -> bytes
assume !pv,ad,x. MsgBytes(pv,ad,x) = (ad @| IntBytes(2,Length(x))) @| x 
assume !pv,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(pv,ad1,x1) = MsgBytes(pv,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

// Now defined in MAC
// predicate Msg of ki:KeyInfo * tlen:DataStream.range * (;ki,tlen)MACPlain.MACPlain

assume !ki,tlen,pl. MAC.Msg(ki,pl) <=>
  (Corrupt(ki) \/
     (?ad,x. Length(ad) = TLSFragment.ADLength(ki.sinfo.protocol_version) /\
	  pl.macP = MsgBytes(ki.sinfo.protocol_version,ad,x) /\
	  TLSFragment.Fragment(ki,tlen,
			       TLSFragment.ADseqn(ki.sinfo.protocol_version,ad),
			       TLSFragment.ADct(ki.sinfo.protocol_version,ad),x)))

ask !ki,t. Corrupt(ki) => MAC.Msg(ki,t)

val concat: ki:KeyInfo -> rg:DataStream.range -> 
  ad:(;ki.sinfo.protocol_version) TLSFragment.addData ->
  f:(;ki,rg,ad)AEADPlain.plain ->
  p:(;ki)MACPlain

val mac: ki:KeyInfo -> (;ki) MAC.key -> t:(;ki) MACPlain{MAC.Msg(ki,t.macP)} -> (;ki) tag
val verify: ki:KeyInfo -> (;ki) MAC.key -> text:(;ki) MACPlain -> tag:(;ki) tag ->
	v:bool{v = true => MAC.Msg(ki,text.macP)}

val pad: l:int -> b:bytes{Length(b) = l}
val check_split: 
  b:bytes -> i:int -> 
  b1:bytes * b2:bytes { Length(b1) = i /\ b = b1 @| b2 }

// The following should rather be internal to AEAD, as it only operates on public data.
// However, we put it here to avoid circular dependencies
function val RangeCipher: KeyInfo -> range -> nat
val rangeCipher: ki:KeyInfo -> r:range -> tlen:nat{tlen=RangeCipher(ki,r)}

val encode: ki:KeyInfo -> rg:range -> ad:(;ki.sinfo.protocol_version) TLSFragment.addData -> (;ki,rg,ad) AEADPlain.plain -> (;ki) tag -> (tlen:nat * (;ki,tlen) plain){tlen=RangeCipher(ki,rg)}
val decode: ki:KeyInfo -> ad:(;ki.sinfo.protocol_version) TLSFragment.addData -> tlen:nat -> (;ki,tlen) plain -> (rg:range * (;ki,rg,ad)AEADPlain.plain * (;ki)tag * bool){tlen=RangeCipher(ki,rg)}
