module CRE

open Bytes
open TLSConstants
open TLSInfo
open PMS

// concrete PMS --> MS derivation.
private val extractMS: si:SessionInfo {not SafeHS_SI(si)} -> p:bytes -> (;si) PRF.masterSecret

(** RSA ciphersuites **) 

//CF actually a private type 
type rsaentry = pk:RSAKey.pk * cv:ProtocolVersion * (;pk,cv)rsapms * csr:bytes * si:SessionInfo * ms:(;si) PRF.masterSecret
private val rsalog: rsaentry list ref 

private val rsaassoc: 
    pk:RSAKey.pk -> cv:ProtocolVersion -> (;pk,cv)rsapms -> csr:bytes -> si:SessionInfo -> 
    (pk':RSAKey.pk * cv':ProtocolVersion * (;pk',cv')rsapms * csr':bytes * si':SessionInfo * ms':(;si') PRF.masterSecret) list -> 
	ms:(;si) PRF.masterSecret option

val extractRSA:
    si:SessionInfo ->
	cv:ProtocolVersion ->
    pms: (;Cert.RSAPKCert(si.serverID),cv) rsapms 
	// { DecryptedPMS(si.pmsdata,pms)  } 
	->
    (;si) PRF.masterSecret


open DHGroup

//CF actually a private type
type dhentry = p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms * bytes * si:SessionInfo * ms:(;si) PRF.masterSecret
private val dhlog: dhentry list ref 

val dhassoc: p:p -> g:(;p) g -> gx:(;p) elt -> gy:(;p) elt -> (;p,g,gx,gy) dhpms -> csr:bytes -> si:SessionInfo -> 
             (p':p * g':(;p') g * gx':(;p') elt * gy':(;p') elt * (;p',g',gx',gy') dhpms * csr':bytes * si':SessionInfo * (;si') PRF.masterSecret) list -> 
             (;si) PRF.masterSecret option

// AP: Don't we really want *any* link between si and (g,p,gx,gy)?
val extractDHE:
    si:SessionInfo ->
    p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms ->
    (;si) PRF.masterSecret
