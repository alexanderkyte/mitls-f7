module AEAD

open Bytes
open Error
open TLSInfo

open TLSConstants

type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}

private type (;ki:epoch) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO: Define AEADSize. 
// In the code, (AEADSize * 2) is computed in TLSConstants.getKeyExtensionLength

function val AEADSize: ki:epoch -> nat
private assume !ki,si. si = EpochSI(ki) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) ) /\
	( IsAEADCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) +
					    EncKeySize(TLSConstants.CipherSuiteENCAlg(si.cipher_suite)) +
					    Encode.IVSize(ki) )

// Why is this failing? Because of AEADSize not being what I want, I cannot typecheck COERCE.
//ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => AEADSize(ki,ki) = MacKeySize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))

val GEN:    ki:succEpoch{Safe(ki)} -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:succEpoch{not Auth(ki)} -> b:bytes{Length(b) = AEADSize(ki)} -> (;ki)AEADKey
val LEAK:   ki:epoch{not Auth(ki)} -> (;ki)AEADKey -> b:bytes

(* KB: 2/5. Partial implementation of CTXT in the code. *)
predicate val CTXT: 'a * 'b * 'c * 'd -> bool
predicate val NotCTXT: 'a * 'b * 'd -> bool
assume !ki,d,p,c. NotCTXT(ki,d,c) => not CTXT(ki,d,p,c)
assume !ki,d,p,p',c. (CTXT(ki,d,p,c) /\ CTXT(ki,d,p',c)) => p = p'
private val mteKey: ki:epoch -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) AEADKey

function val CipherRange: epoch * bytes -> range
assume !e,c,rg. rg = CipherRange(e,c) <=> Length(c) = Encode.RangeCipher(e,rg)
val encrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){rg = CipherRange(ki,c)}

val decrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {!k,r,p. res = Correct((k,r,p)) => r = CipherRange(ki,c)}

val encrypt: ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){rg = CipherRange(ki,c) /\
                             (Safe(ki) => CTXT(ki,ad,p,c))}

val decrypt: ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {(!k,r,p. res = Correct((k,r,p)) => r = CipherRange(ki,c)) /\
    (Safe(ki) => 
        ((!k,r,p. res = Correct((k,r,p)) => CTXT(ki,ad,p,c)) /\
         (!p. CTXT(ki,ad,p,c) => (?k,r. res = Correct((k,r,p))))))}

(* CF 04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that RangeCipher depends on the TLS version too.
*)
