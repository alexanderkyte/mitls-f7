// Merge of Handshake.fs7 and Handshake3.fs7.
// Not fully detailed, to fit in the paper.
// Agreed to be implemented, once refined.
module Handshake

open Error
open CipherSuites
open TLSInfo
open DataStream

(* Control Interface )*
type CI=ConnectionInfo; type RS=Record.ConnectionState
type (;ci:CI) hs_state
val init:        Role                   -> config  -> (ci:CI * (;ci)hs_state)
val resume:      nextSI:SessionInfo     -> config  -> (ci:CI * (;ci)hs_state)
val rehandshake: ci:CI -> (;ci)hs_state -> config  -> (;ci)hs_state
val rekey:       ci:CI -> (;ci)hs_state -> config  -> (;ci)hs_state
val request:     ci:CI -> (;ci)hs_state -> config  -> (;ci)hs_state
val authorize:   ci:CI -> (;ci)hs_state -> cert    -> (;ci)hs_state

(* Network Interface*)

type (;ci:CI) outgoing =
  | OutIdle of (;ci)hs_state
  | OutSome of                (rg:range * (;id.id_out,rg)fragment)
  | OutCCS of               (rg:range * (;id.id_out,rg)fragment) * ((ci':CI * cs:(;ci'.id_out)RS * (;ci')hs_state){ SentCCS(ki) /\ EmptyHistory(ci'.id_out,cs) /\ ci.id_in = ci'.id_in})
  | OutFinished of   (rg:range * (;id.id_out,rg)fragment) * (;ci)hs_state
  | OutComplete of (rg:range * (;id.id_out,rg)fragment) * (;ci)hs_state {Complete(ci)}
val next_fragment: ci:CI -> (;ci)hs_state -> (;ci)outgoing

type (;ci:CI)incoming =
  | HInAck of (;ci)hs_state
  | InVersionAgreed  of (;ci)hs_state
  | InQuery of Certificate.cert * (;ci)hs_state
  | InFinished of (;ci)hs_state
  | InComplete of (;ci)hs_state {Complete(ci)}
  | InError of ErrorCause * ErrorKind * (;ci)hs_state
val recv_fragment: ci:CI -> (;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> (;ci)recv_reply
val recv_ccs     : ci:CI -> (;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> (((ci':CI * cs:(;ci'.id_in)RS * (;ci')hs_state){EmptyHistory(ci'.id_in,cs) /\ ci.id_out = ci'.id_out})
