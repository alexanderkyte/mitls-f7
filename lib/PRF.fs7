module PRF

(* PRFs keyed by master secrets, both for key derivation and verifyData *)

open Bytes
open TLSInfo
open StatefulLHAE
open TLSConstants

// Master secrets are used to derive key materials. 
// Compared with standard (non-tls) key derivation,
// - the label is hardcoded & implicit; 
// - the seed (crandom @| srandom) is retrieved from the epoch

type repr = (;48)lbytes
//#begin-abstraction
//CF the index records the *local* session info 
//CF index abstract is currently broken
private type (;si:SessionInfo) masterSecret = {bytes: repr}
//#end-abstraction


(*MK SHOULD BE:
private type (;pms:Pms,csr:csrands) protoMasterSecret = { bytes: repr }

private type (;si:SessionInfo) masterSecret = {
  protoms    : (;(;GetPMS(si),si.csrands) protoMasterSecret;         
}

val changeMasterSecret: si:SessionInfo -> (;GetPMS(si),si.csrands) protoMasterSecret{?ki. EpochSI(ki)=si /\ Complete(ki,..)} -> (;si) masterSecret
*)


(* MK !! causes logical inconsistency
function val Epochs: 'a -> 'b
private definition !ci,r,e_in,e_out.
	(ci = {role=Client;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_in,ci.id_out) ) \/
	(ci = {role=Server;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_out,ci.id_in) )
*)


// AuthSI is defined in TLSInfo
val sample: si:SessionInfo -> (;si)masterSecret
//#begin-coerce
val coerce: si:SessionInfo {not SafeHS_SI(si)} -> repr -> (;si)masterSecret 
//#end-coerce

//ask from LHAE.fs7 repeated here to help Z3
ask !ki,si,enc,mac. TLSConstants.CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = TLSConstants.MACOnly(mac) =>
	  LHAE.LHAEKeySize(ki) = TLSConstants.MacKeySize(mac)

ask !cs,pv,mac. CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) => KeyExtensionLength(pv,cs) = MacKeySize(mac)+MacKeySize(mac)
ask !cs,pv,mac. CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) => LHAE.LHAEKeySize_AEAlg(MACOnly(mac)) = TLSConstants.MacKeySize(mac)
ask !ki,mac. CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = MACOnly(mac) =>
	  LHAE.LHAEKeySize(ki) = TLSConstants.MacKeySize(mac)

private val keyGen_int: ci:ConnectionInfo{EpochSI(ci.id_in)=EpochSI(ci.id_out) /\ IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out) /\ not Auth(ci.id_in) /\ not Auth(ci.id_out)} -> (;EpochSI(ci.id_out))masterSecret -> 
  ( w:(;ci.id_out)StatefulLHAE.writer * 
    r:(;ci.id_in) StatefulLHAE.reader ) 
//  { StatefulLHAE.History(ci.id_out,WriterState,w) = StatefulPlain.EmptyHistory(ci.id_out) /\
//    StatefulLHAE.History(ci.id_out,ReaderState,r) = StatefulPlain.EmptyHistory(ci.id_in)}

private type keysentry = (e:epoch * e':epoch * ms:(;EpochSI(e)) masterSecret * bytes * (;e)StatefulLHAE.reader * (;e')StatefulLHAE.writer) 
private val keyslog: keysentry list ref 
val keysassoc: e:epoch -> e':epoch -> ms:(;EpochSI(e)) masterSecret -> bytes -> keysentry list -> ((;e)StatefulLHAE.reader * (;e')StatefulLHAE.writer) option

val keyGen: ci:ConnectionInfo{IsSuccEpoch(ci.id_in)} -> (;EpochSI(ci.id_out))masterSecret -> 
  ( w:(;ci.id_out)StatefulLHAE.writer * 
    r:(;ci.id_in) StatefulLHAE.reader ) 
  { StatefulLHAE.History(ci.id_out,WriterState,w) = StatefulPlain.EmptyHistory(ci.id_out) /\
    StatefulLHAE.History(ci.id_out,ReaderState,r) = StatefulPlain.EmptyHistory(ci.id_in)}

private function val Fst: 'a -> 'b
private function val Snd: 'a -> 'b
private definition !e1,e2. Fst((e1,e2)) = e1
private definition !e1,e2. Snd((e1,e2)) = e2

(* typing the keys log for the ideal functionality *)
//private type entry = (ems:(e12:(epoch * epoch) * (;Fst(e12))masterSecret) * 
//                   ((;Fst(Fst(ems)),ReaderState)state * (;Snd(Fst(ems)),WriterState)state)) 
//private val log: entry list ref 

(*CF VerifyData should be about epochs not sessions *)
// Master secrets are also used to generate and check verifyData tags,
// providing conditional authentication of the (abstract) VerifyData predicate.

predicate VerifyData of epoch * Role * bytes

(* typing the finishedlog for the ideal functionality *)

type finishedtext = bytes
type finishedtag = bytes

private type finishedentry = (ki:epoch * r:Role * t:finishedtext * finishedtag){VerifyData(ki,r,t)}
private val finishedlog: finishedentry list ref
private val ftmem: ki:epoch -> r:Role -> t:finishedtext -> finishedentry list -> b:bool{ b=true => VerifyData(ki,r,t) }

private val finish_log: (SessionInfo * bytes * bytes) list ref 


val makeVerifyData: e:succEpoch -> 
  r:Role -> (;EpochSI(e)) masterSecret -> 
  log:bytes{VerifyData(e,r,log)} -> 
  bytes (* length depends on cs, 12 by default *)

val checkVerifyData: e:succEpoch -> r:Role -> (;EpochSI(e)) masterSecret ->
				   log:bytes (* the log *) ->
				   tag:bytes (* the expected value *) ->
				   b:bool{(b = true /\ SafeHS(e)) => VerifyData(e,r,log)} //MK SafeMS(MS(e)) => VerifyData(MS(e),r,log)
				   //TODO SafeHS(e) => PRF(pv,MacAlg(e))

val ssl_certificate_verify: si:SessionInfo -> (;si)masterSecret -> TLSConstants.sigAlg -> bytes -> bytes

private val epochs:ConnectionInfo -> epoch * epoch