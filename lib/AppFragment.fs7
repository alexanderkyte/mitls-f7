module AppFragment
open Bytes
open TLSInfo
open DataStream

predicate DeltaFragment of ki:epoch * s:(;ki) stream * r:range * (;ki,s,r)delta
private type (;ki:epoch,r:range) fragment = {frag: (s:(;ki)stream * d:(;ki,s,r) delta{Auth(ki) => DeltaFragment(ki,s,r,d)})}
function val Extend: 'a * 'b * 'c * 'd -> 'e

predicate FragmentSent of ki:epoch * (;ki) stream * r:range * (;ki,r)fragment
private assume !ki,s,r,f. FragmentSent(ki,s,r,f) <=> 
  (?d. f.frag = (s,d) /\ DeltaFragment(ki,s,r,d))

type (;e:epoch,s:(;e)stream,r:range)plain = f:(;e,r) fragment{Auth(e) => FragmentSent(e,s,r,f)}
// range-based fragmentation 

val fragment: ki:epoch -> s:(;ki) stream -> r:range ->
  (;ki,s,r) delta -> 
  (f:(;ki,r) fragment * s':(;ki) stream){FragmentSent(ki,s,r,f) /\ s' = Extend(ki,s,r,f)}

val delta: ki:epoch -> s:(;ki) stream -> r:range -> 
  f:(;ki,r) fragment{Auth(ki) => FragmentSent(ki,s,r,f)} -> 
  d:(;ki,s,r) delta * s':(;ki) stream{s' = Extend(ki,s,r,f)}

val delta': ki:epoch -> s:(;ki) stream -> r:range -> 
  f:(;ki,r) fragment{not Auth(ki)} -> 
  d:(;ki,s,r) delta * s':(;ki) stream{s' = ExtendStream(ki,s,r,d)}

val plain: ki:epoch{not Auth(ki)} -> r:range -> (;r) rbytes -> (;ki,r) fragment
val repr:  ki:epoch{not Safe(ki)} -> r:range -> (;ki,r) fragment -> (;r) rbytes

//CF: This is *not* valid because of empty fragments; 
//CF: instead we may have to record in stream a sequence of bytes, rather than their concatenation.

private theorem !ki,s,r1,r2,f1,f2. 
  DeltaFragment(ki,s,r1,f1) /\ DeltaFragment(ki,s,r2,f2) => (r1 = r2 /\ f1 = f2)
private definition !ki,s,r,s',d. 
  Extend(ki,s,r,{frag = (s',d)}) = ExtendStream(ki,s,r,d)


 

