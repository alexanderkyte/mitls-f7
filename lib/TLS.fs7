module TLS

open Error
open Bytes
open DataStream
open AppDataStream
open Dispatch
open TLSInfo 
// for ConnectionInfo, Client, Server, ... 

//TODO: change Direction to role 
//KB: I disagree. Directions are the right abstraction for KeyInfo. 
//    If need be, it would be better to define a role in ConnectionInfo.

type role = Direction

type index = ConnectionInfo
type params = protocolOptions
type cn //= Dispatch.Connection

function val Role: cn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

// Peer(i) ghostly refers to the remote peer's index 
function val Peer: index -> index 
assume !ki. Peer(ki) = { id_in = ki.id_out; id_out = ki.id_in }

// main security predicates and events; may be defined elsewhere
predicate val TXT: index -> bool
predicate val SEC: index -> bool
predicate val Fatal:   (index * bytes) -> bool
predicate val Warning: (index * bytes) -> bool
predicate val Close:   (index * bytes) -> bool
predicate val Write:   (index * bytes) -> bool
predicate val Read :   (index * bytes) -> bool //AP: Unused. Everything is defined as a correspondence on Write

function val CnId: c:cn -> index
function val CnStream_i: c:cn -> (;ConnectionInKeyInfo(c)) stream
function val CnStream_o: c:cn -> (;ConnectionOutKeyInfo(c)) stream
assume !id, s. CnId(Conn(id, s)) = id
assume !id, s. CnStream_i(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. CnStream_o(Conn(id, s)) = OutStream(id, s.appdata)
//CF redundant?
function val Bytes_o: cn -> bytes
function val Bytes_i: cn -> bytes
assume !c. Bytes_o(c) = CnStream_i(c)
assume !c. Bytes_i(c) = CnStream_o(c)

// These types hide the precise of a range in messages
type (;c:cn) msg_i = r:range * (;ConnectionInKeyInfo(c),  CnStream_i(c), r) delta
type (;c:cn) msg_o = r:range * (;ConnectionOutKeyInfo(c), CnStream_o(c), r) delta

predicate val Split_o: (cn * msg_o * msg_o * cn * msg_o)  -> bool

// Abbreviations for specifying connection invariants 
predicate val Extend:   (c:cn * c':cn) -> bool
predicate val Extend_o: (c:cn * c':cn * (;c) msg_o) -> bool
predicate val Extend_i: (c:cn * c':cn * (;c) msg_i) -> bool

type (;c:cn) nextCn = c':cn {  Role(c')    = Role(c) 
                            /\ CnId(c')    = CnId(c)
                            /\ Params(c')  = Params(c) }
definition !c, c'. 
  Extend(c, c') <=>            Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c)
definition !c, c', msg. 
  Extend_o(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c)
                            /\ Bytes_o(c') = Bytes_o(c) @| msg
definition !c, c', msg. 
  Extend_i(c, c', msg) <=>   Bytes_i(c') = Bytes_i(c) @| msg
                            /\ Bytes_o(c') = Bytes_o(c)

//TODO: in SameConnection, enforce the chaining for all HS-specific data, in particular to chain successive handshakes.
//TODO: fix alertDescription, so that it only represents the second byte. 
//TODO: check that we are not too restrictive for the ongoing connection once we start negotiating.
//TODO: regroup the bits of the TLS library that are needed in the API.
//TODO: write the "toplevel" automata, from the user viewpoint; consider enforcement by typing, session-style.

// authorization query; TBD with principals
type (;c:cn) query

type (;c:cn) ioresult_i =
| ReadError of alertDescription option //AP: There was an error reading, and so we may have sent a fatal alert on the other side. We tell the user which fatal alert has been sent, if any (otherwise it's an internal error, and right now we don't tell what to the user)
| Close     of Tcp.NetworkStream  {TXT(CnId(c)) => Close(Peer(CnId(c)), Bytes_i(c))}
| Fatal     of a:alertDescription {TXT(CnId(c)) => Fatal(Peer(CnId(c)), a, Bytes_i(c))}
| Warning   of c':(;c) nextCn * a:alertDescription 
  {Extend(c,c') /\ TXT(CnId(c)) => Warning(Peer(CnId(c)), a, Bytes_i(c))}
| CertQuery of c':(;c) nextCn * (;c') query {Extend(c, c')} 
| Handshake of c':cn {Role(c') = Role(c) /\ Bytes_o(c') = [||] /\ Bytes_i(c') = [||]}
	//AP: /\ Close(CnId(c),Bytes_o(c)) /\ Close(Peer(CnId(c)),Bytes_i(c)) -- and same for Alert protocol, and hanshake.
	// We need to show agreement on the content of all protocols in previous and current connectio to express the Alert attack (and therefore authentication)
| Read      of c':(;c) nextCn * d:(;c) msg_i
  {Extend_i(c,c',d) /\ TXT(CnId(c)) => Write(Peer(CnId(c)), Bytes_i(c')) }
| ReadMustRead of c':cn * d:(;c) msg_i
	// Mashup of ioresult_i.Read and ioresult_o.MustRead
	{	   Role(c') = Role(c)
		/\ Params(c') = Params(c)
		/\ ConnectionInKeyInfo(c') = ConnectionInKeyInfo(c)
		/\ Extend_i(c,c',d)
		/\ TXT(CnId(c)) => Write(Peer(CnId(c)),Bytes_i(c')) } // AP: TXT(index) is not precise enough here:
			// in/out directions are not the same, and we want to only refer to the incoming direction

val read : c:cn -> (;c) ioresult_i

type (;c:cn,d:(;c) msg_o) ioresult_o =
| WriteError    of alertDescription option // The alert we have sent
| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
	//AP: /\ Write(CnId(c'),Bytes_o(c')) -- we need to generate the Write event somewhere, and this (and WritePartial) looks like a good place.
| WritePartial  of c':(;c) nextCn * d':(;c') msg_o 
  { ?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d') }
| MustRead      of c':cn 
    {   Role(c')                = Role(c) 
     /\ Params(c')              = Params(c)
	 /\ ConnectionInKeyInfo(c') = ConnectionInKeyInfo(c) 
     /\ Bytes_i(c')             = Bytes_i(c) }

val write: c:cn -> rg:range -> d:(;c) msg_o -> (;c,d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,Bytes_o(c')) 
// - Close(ki,Bytes_o(c))
// WriteError reports a local error
// WriteComplete reports write completion
// WritePartial reports partial write completion, and returns the rest
// MustRead signals that the connection cannot be used anymore for writing until a new handshake completes. 
// (it may be a bit too restrictive) 

// special NULL_NULL initial connection index
// cannot be used for data writing (by typing)
val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}
type (;r:role,p:params) nullCn = c:cn {CnId(c) = null /\ Params(c) = p /\ Role(c) = r}

val connect: Tcp.NetworkStream -> p:params                  -> (;CtoS,p) nullCn Result
val resume:  Tcp.NetworkStream -> p:params -> sid:sessionID -> (;CtoS,p) nullCn Result 
// even if the server declines, we authenticate the client's intent to resume from the sid.
val accept:  Tcp.NetworkStream -> p:params                  -> (;StoC,p) nullCn Result
val shutdown: c:cn -> Tcp.NetworkStream Result
//was: (c':(;c) nextCn {Extend(c,c')}) Result
// [shutdown] will internally generate a Close(ki, Bytes_o(c)); releases the TCP socket after shutdown

val rekey:       c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val rehandshake: c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val request:     c:cn {Role(c)=StoC} -> (c':(;c) nextCn {Extend(c,c')}) Result

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:cn -> (;c) query -> (c': (;c) nextCn {Extend(c,c')}) Result
val refuse:    c:cn -> (;c) query -> unit