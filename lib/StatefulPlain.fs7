module StatefulPlain
open TLSInfo
open TLSFragment
open DataStream
open Error
open Bytes
open Formats
open CipherSuites
open TLSKey

type (;ki:KeyInfo) data = (b:bytes){Length(b) = TLSFragment.ADLength(ki) - 8}

function val Log: (data * range * TLSFragment.fragment) list -> (data * TLSFragment.fragment) list
assume !h. (h = [] => Log(h) = []) /\
	   (!ad,r,f,t. h = (ad,r,f)::t => Log(h) = (ad,f)::Log(t))

private type (;ki:KeyInfo,h:TLSFragment.history,ad:data,r:range) fragment = {f: bytes}

val addFragment: ki:KeyInfo -> h:TLSFragment.history -> ad:data -> r:range -> f:(;ki,h,ad,r) fragment -> h': TLSFragment.history{Log(h') = (ad,f)::Log(h)}

val fragment: ki:KeyInfo -> h:TLSFragment.history -> ad:data -> r:range -> bytes -> (;ki,h,ad,r) fragment
val repr: ki:KeyInfo -> h:TLSFragment.history -> ad:data -> r:range -> (;ki,h,ad,r) fragment -> bytes

function val ADCT: KeyInfo -> ContentType -> bytes //creates the ad bytes only from PV and CT

val TLSFragmentToFragment: ki:KeyInfo -> ct:ContentType -> h:TLSFragment.history -> rg:range -> (;ki,ct,h,rg) TLSFragment.fragment -> (;ki,h,ADCT(ki,ct),r) fragment
val FragmentToTLSFragment: ki:KeyInfo -> ct:ContentType -> h:TLSFragment.history -> rg:range -> (;ki,h,ADCT(ki,ct),rg) fragment -> (;ki,ct,h,rg) TLSFragment.fragment