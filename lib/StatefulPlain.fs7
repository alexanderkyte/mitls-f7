module StatefulPlain
open Bytes
open TLSConstants
open TLSInfo
open DataStream

//------------------------------------------------------------------------------------------------------
// `Plain' interface towards StatefulAEAD
//------------------------------------------------------------------------------------------------------

function val ADLength: epoch -> nat
assume !ki. 
    (EpochSI(ki).protocol_version = SSL_3p0  /\ ADLength(ki) = 1) \/
	(EpochSI(ki).protocol_version <> SSL_3p0 /\ ADLength(ki) = 3)

type (;ki:epoch) data = (b:bytes){Length(b) = ADLength(ki)} 

private type (;ki:epoch) prehistory = (ad:(;ki) data * r:range * x:(;ki,r)Fragment.fragment) list
function val HLength: ki:epoch * (;ki)prehistory -> nat
private definition !ki.          HLength(ki,[]) = 0
private definition !ki,h,ad,r,x. HLength(ki,(ad,r,x)::h) = HLength(ki,h)+1

predicate Sent of ki:epoch * (nat * (;ki)prehistory)
private type (;ki:epoch)history = (sn:nat * ph:(;ki)prehistory){sn = HLength(ki,ph) /\ (Auth(ki) => Sent(ki,(sn,ph)))}
function val SeqN: ki:epoch * (;ki)history -> nat
assume !ki,sn,h. SeqN(ki,(sn,h)) = sn
predicate EmptyHistory of ki:epoch * (;ki) history
function val ExtendHistory: ki:epoch * h:(;ki) history * (;ki) data * r:range * (;ki,r) Fragment.fragment -> 'a
private definition !ki,h. EmptyHistory(ki,h) <=> h = (0,[])
private definition !ki,n,h,d,r,f. ExtendHistory(ki,(n,h),d,r,f) = (n+1,(d,r,f)::h)


private type (;ki:epoch,h:(;ki)history,ad:(;ki)data,range:range) statefulPlain =
	{contents: (x: (;ki,range)Fragment.fragment{Auth(ki) => Sent(ki,ExtendHistory(ki,h,ad,range,x))})}

val statefulPlain: ki:epoch{not Auth(ki)} -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;r)rbytes -> (;ki,h,ad,r) statefulPlain
val statefulRepr:  ki:epoch{not Safe(ki)} -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r) statefulPlain -> (;r)rbytes

//------------------------------------------------------------------------------------------------------
// `internal' interface towards TLSFragment
//------------------------------------------------------------------------------------------------------

//CF 21/4 use a function instead? just inline?  
function val SAEADContents: 'a -> 'b
assume !f. SAEADContents(f) = f.contents

val emptyHistory: ki:epoch -> h:(;ki)history{EmptyHistory(ki,h)}
private val consHistory: ki:epoch -> h:(;ki)prehistory ->
	ad:(;ki)data -> r:range -> x:(;ki,r)Fragment.fragment ->
	h':(;ki)prehistory{h' = (ad,r,x)::h}
val addToHistory: ki:epoch -> h:(;ki)history ->
	ad:(;ki)data -> r:range -> x:(;ki,h,ad,r)statefulPlain ->
	h':(;ki)history{h' = ExtendHistory(ki,h,ad,r,SAEADContents(x))}

// adding the 8-byte sequence number to AD (internal to AEAD) 

val contents:  ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range -> 
    sf:(;ki,h,ad,r)statefulPlain -> 
    x :(;ki,r)Fragment.fragment{x = SAEADContents(sf) /\ (Auth(ki) => Sent(ki,ExtendHistory(ki,h,ad,r,x)))}
val construct: ki:epoch -> h:(;ki)history -> ad:(;ki)data -> r:range ->
	x :(;ki,r)Fragment.fragment{Auth(ki) => Sent(ki,ExtendHistory(ki,h,ad,r,x))} ->
	sf:(;ki,h,ad,r)statefulPlain{x = SAEADContents(sf)}


//------------------------------------------------------------------------------------------------------
// Auxiliary Definitions and Assumes for Typing
//------------------------------------------------------------------------------------------------------

// Sent grows linearly
assume !ki.          Sent(ki,(0,[]))
assume !ki,h,ad,r,x. Sent(ki,ExtendHistory(ki,h,ad,r,x)) => Sent(ki,h)
assume !ki,h,h'. (Auth(ki) /\ Sent(ki,h) /\ Sent(ki,h') /\ SeqN(ki,h) = SeqN(ki,h')) => h = h'

function val ADBytes: (epoch * ContentType) -> bytes //(;ki)StatefulPlain.data
assume !ki,ct.
	( EpochSI(ki).protocol_version = SSL_3p0 /\
	  ADBytes(ki,ct) =
		CTBytes(ct) ) \/
	( EpochSI(ki).protocol_version <> SSL_3p0 /\
          ADBytes(ki,ct) =
		(CTBytes(ct) @| VersionBytes(EpochSI(ki).protocol_version)))

private val makeAD: ki:succEpoch -> ct:ContentType ->
	  ad: (;ki)data{ad=ADBytes(ki,ct)}

function val Multiplexed: ki:epoch * (;ki) history -> 'b
assume !ki,sh,h. EmptyHistory(ki,sh) /\
   TLSFragment.EmptyHistory(ki,h) => h = Multiplexed(ki,sh)
assume !ki,sh,sh',h,ct,r,x. 
  (sh' = ExtendHistory(ki,sh,ADBytes(ki,ct),r,x) /\
   h = Multiplexed(ki,sh)) => 
  (Multiplexed(ki,sh') = TLSFragment.ExtendHistory(ki,ct,h,r,x))

assume !ki,sh,ct,r,x.  
  Sent(ki,ExtendHistory(ki,sh,ADBytes(ki,ct),r,x)) <=> 
  TLSFragment.TLSFragment(ki,ct,Multiplexed(ki,sh),r,x)

val TLSFragmentToFragment: ki:succEpoch -> ct:ContentType -> h:(;ki) TLSFragment.history ->
	st:(;ki) history{h = Multiplexed(ki,st)} -> rg:range -> f:(;ki,ct,h,rg) TLSFragment.fragment -> 
	sf:(;ki,st,ADBytes(ki,ct),rg) statefulPlain
		{TLSFragment.TLSContents(f) = SAEADContents(sf) /\
		 (Auth(ki) => TLSFragment.TLSFragment(ki,ct,h,rg,SAEADContents(sf)))}

val fragmentToTLSFragment: ki:succEpoch -> ct:ContentType -> h:(;ki) TLSFragment.history ->
	st:(;ki) history{h = Multiplexed(ki,st)} -> rg:range -> 
    d:(;ki,st,ADBytes(ki,ct),rg) statefulPlain ->
	f:(;ki,ct,h,rg) TLSFragment.fragment{TLSFragment.TLSContents(f) = SAEADContents(d)}