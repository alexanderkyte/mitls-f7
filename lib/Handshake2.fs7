// Merge of Handshake.fs7 and Handshake3.fs7.
// Not fully detailed, to fit in the paper.
// Agreed to be implemented, once refined.
module Handshake

open Error
open CipherSuites
open TLSInfo
open DataStream

type (;ci:ConnectionInfo) hs_state

val init: Role -> protocolOptions -> (ci:ConnectionInfo * (;ci)hs_state)
val resume: nextSI:SessionInfo -> protocolOptions -> (ci:ConnectionInfo * (;ci)hs_state)

val rehandshake: ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state
val rekey:       ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state
val request:  ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state


type (;ci:ConnectionInfo) outgoing =
  | OutIdle of (;ci)state
  | OutSome of                (rg:range * (;id.id_out,rg)fragment)
  | OutCCS of               (rg:range * (;id.id_out,rg)fragment) * ((ci':ConnectionInfo * cs:(;ci'.id_out)Record.ConnectionState * (;ci')state){EmptyHistory(ci'.id_out,cs) /\ ci.id_in = ci'.id_in})
  | OutFinished of   (rg:range * (;id.id_out,rg)fragment) * (;ci)state
  | OutComplete of (rg:range * (;id.id_out,rg)fragment) * (;ci)state
val next_fragment: ci:ConnectionInfo -> (;ci)hs_state -> (;ci)outgoing

type (;ci:ConnectionInfo)incoming =
  | HInAck of (;ci)state
  | InVersionAgreed  of (;ci)state
  | InQuery of Certificate.cert * (;ci)state
  | InFinished of (;ci)state
  | InComplete of (;ci)state
  | InError of ErrorCause * ErrorKind * (;ci)state
val recv_fragment: ci:ConnectionInfo -> (;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> (;ci)recv_reply
val recv_ccs     : ci:ConnectionInfo -> (;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> (((ci':ConnectionInfo * cs:(;ci'.id_in)Record.ConnectionState * (;ci')state){EmptyHistory(ci'.id_in,cs) /\ ci.id_out = ci'.id_out})

val authorize: ci:ConnectionInfo -> (;ci)hs_state -> Certificate.cert -> (;ci)hs_state
