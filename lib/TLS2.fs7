module TLS // excerpts for the paper
open Error
open Bytes
open DataStream
open AppDataStream
open Dispatch
open TLSInfo 


type (;c:CI) query
type (;c:CI) msg_i = r:range * (;c.id_in,  CnStream_i(c), r) delta
type (;c:CI) msg_o = r:range * (;c.id_out, CnStream_o(c), r) delta

type (;c:CI) ioresult_i =
| Read      of c':(;c) nextCn * d:(;c) msg_i
  {Extend_i(c,c',d) /\ (Auth(c.id_in) => Write(Peer(c.id_in), Bytes_i(c'))) }
| Close of TCP.NetworkStream  {Auth(c.id_in) => Close(Peer(c.id_in), Bytes_i(c))}
| Fatal     of a:alertDescription {Auth(c.id_in) => Fatal(Peer(c.id_in), a, Bytes_i(c))}
| Warning   of c':(;c) nextCn * a:alertDescription 
  {Extend(c,c') /\ Auth(c.id_in) => Warning(Peer(c.id_in), a, Bytes_i(c))}
| CertQuery of c':(;c) nextCn * (;c') query {Extend(c, c')} 
| Handshake of c':cn {...}
| ...
val read : c:cCI -> (;c) ioresult_i

type (;c:CI,d:(;c) msg_o) ioresult_o =
| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
| WritePartial  of c':(;c) nextCn * d':(;c') msg_o 
  { ?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d') }
| WriteError    of alertDescription option 
| MustRead      of c':CI {...}
val write: c:CI -> d:(;c,rg) msg_o -> (;c,d) ioresult_o

val connect: TCP.Stream -> p:params                  -> c:nullCn{Role(c) = Client}  Result
val resume:  TCP.Stream -> p:params -> sid:sessionID -> c:nullCn{Role(c) = Client} Result 
val accept:  TCP.Stream -> p:params                  -> c:nullCn{Role(c) = Server} Result
val shutdown: c:CI -> TCP.Stream Result
val rekey:       c:CI {Role(c)=Client} -> (c':(;c) nextCn {Extend(c,c')}) Result
val rehandshake: c:CI {Role(c)=Client} -> (c':(;c) nextCn {Extend(c,c')}) Result
val request:     c:CI {Role(c)=Server} -> (c':(;c) nextCn {Extend(c,c')}) Result
val authorize: c:CI -> (;c) query -> (c': (;c) nextCn {Extend(c,c')}) Result
val refuse:    c:CI -> (;c) query -> unit 