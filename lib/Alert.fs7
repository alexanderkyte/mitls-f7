module Alert

open Bytes
open Error
open TLSInfo

private type (;ci:ConnectionInfo)pre_al_state = {
  al_incoming: bytes; (* incomplete incoming message *)
  al_outgoing: bytes (* emptybstr if nothing to be sent *) 
}
type (;ci:ConnectionInfo)state = (;ci)pre_al_state

// protocol-specific abstract fragment,
// and associated functions (never to be called with ideal functionality)
private type (;ki:KeyInfo,tlen:int,seqn:int)fragment = {b:bytes}
predicate AlertFragment of KeyInfo * int * int * Bytes.bytes
val repr: ki:KeyInfo -> tlen:int -> seqn:int -> (;ki,tlen,seqn)fragment -> b:Bytes.bytes{AlertFragment(ki,tlen,seqn,b)}
val fragment: ki:KeyInfo -> tlen:int -> seqn:int -> b:Bytes.bytes{AlertFragment(ki,tlen,seqn,b) \/ Corrupt(ki)} -> (;ki,tlen,seqn)fragment

val makeFragment: ki:KeyInfo -> seqn:int -> b:bytes -> (tlen:int * (;ki,tlen,seqn)fragment) * b2:bytes

type (;ki:KeyInfo,seqn:int)ALFragReply =
    | EmptyALFrag
    | ALFrag of          (tlen:int * (;ki,tlen,seqn)fragment)
    | LastALFrag of      (tlen:int * (;ki,tlen,seqn)fragment)
    | LastALCloseFrag of (tlen:int * (;ki,tlen,seqn)fragment)

type (;ci:ConnectionInfo)alert_reply =
    | ALAck of          (;ci)state
    | ALClose of        (;ci)state
    | ALClose_notify of (;ci)state

// Conversions
function val AlertBytes: alertDescription -> bytes
private assume
	AlertBytes(AD_close_notify						) = [|1uy;   0uy|] /\
	AlertBytes(AD_unexpected_message				) = [|2uy;  10uy|] /\
	AlertBytes(AD_bad_record_mac					) = [|2uy;  20uy|] /\
	AlertBytes(AD_decryption_failed					) = [|2uy;  21uy|] /\
	AlertBytes(AD_record_overflow					) = [|2uy;  22uy|] /\
	AlertBytes(AD_decompression_failure				) = [|2uy;  30uy|] /\
	AlertBytes(AD_handshake_failure					) = [|2uy;  40uy|] /\
	AlertBytes(AD_no_certificate					) = [|1uy;  41uy|] /\
	AlertBytes(AD_bad_certificate_warning			) = [|1uy;  42uy|] /\
	AlertBytes(AD_bad_certificate_fatal				) = [|2uy;  42uy|] /\
	AlertBytes(AD_unsupported_certificate_warning	) = [|1uy;  43uy|] /\
	AlertBytes(AD_unsupported_certificate_fatal		) = [|2uy;  43uy|] /\
	AlertBytes(AD_certificate_revoked_warning		) = [|1uy;  44uy|] /\
	AlertBytes(AD_certificate_revoked_fatal			) = [|2uy;  44uy|] /\
	AlertBytes(AD_certificate_expired_warning		) = [|1uy;  45uy|] /\
	AlertBytes(AD_certificate_expired_fatal			) = [|2uy;  45uy|] /\
	AlertBytes(AD_certificate_unknown_warning		) = [|1uy;  46uy|] /\
	AlertBytes(AD_certificate_unknown_fatal			) = [|2uy;  46uy|] /\
	AlertBytes(AD_illegal_parameter					) = [|2uy;  47uy|] /\
	AlertBytes(AD_unknown_ca						) = [|2uy;  48uy|] /\
	AlertBytes(AD_access_denied						) = [|2uy;  49uy|] /\
	AlertBytes(AD_decode_error						) = [|2uy;  50uy|] /\
	AlertBytes(AD_decrypt_error						) = [|1uy;  51uy|] /\
	AlertBytes(AD_export_restriction				) = [|2uy;  60uy|] /\
	AlertBytes(AD_protocol_version					) = [|2uy;  70uy|] /\
	AlertBytes(AD_insufficient_security				) = [|2uy;  71uy|] /\
	AlertBytes(AD_internal_error					) = [|2uy;  80uy|] /\
	AlertBytes(AD_user_cancelled_warning			) = [|1uy;  90uy|] /\
	AlertBytes(AD_user_cancelled_fatal				) = [|2uy;  90uy|] /\
	AlertBytes(AD_no_renegotiation					) = [|1uy; 100uy|] /\
	AlertBytes(AD_unsupported_extension				) = [|2uy; 110uy|]

val alertBytes: ad:alertDescription -> b:bytes{b=AlertBytes(ad)}
val parseAlert: b:bytes -> (ad:alertDescription{b=AlertBytes(ad)}) Result

predicate IsFatal of alertDescription
private assume
	IsFatal(AD_unexpected_message   		) /\
	IsFatal(AD_bad_record_mac       		) /\
	IsFatal(AD_decryption_failed    		) /\
	IsFatal(AD_record_overflow      		) /\
	IsFatal(AD_decompression_failure		) /\
	IsFatal(AD_handshake_failure    		) /\
	IsFatal(AD_bad_certificate_fatal		) /\
	IsFatal(AD_unsupported_certificate_fatal) /\
	IsFatal(AD_certificate_revoked_fatal    ) /\
	IsFatal(AD_certificate_expired_fatal    ) /\
	IsFatal(AD_certificate_unknown_fatal    ) /\
	IsFatal(AD_illegal_parameter			) /\
	IsFatal(AD_unknown_ca       			) /\
	IsFatal(AD_access_denied    			) /\
	IsFatal(AD_decode_error     			) /\
	IsFatal(AD_export_restriction   		) /\
	IsFatal(AD_protocol_version     		) /\
	IsFatal(AD_insufficient_security		) /\
	IsFatal(AD_internal_error   			) /\
	IsFatal(AD_user_cancelled_fatal 		) /\
	IsFatal(AD_unsupported_extension		)

val isFatal: ad:alertDescription -> b:bool{b = true => IsFatal(ad)}

val init: ci:ConnectionInfo -> (;ci)state

val send_alert: ci:ConnectionInfo -> (;ci)state -> alertDescription -> (;ci)state

val next_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)state -> ((;ci.id_out,seqn)ALFragReply * (;ci)state) 

val handle_alert: ci:ConnectionInfo -> (;ci)state -> alertDescription -> (;ci)alert_reply

val recv_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)state -> tlen:int -> (;ci.id_in,tlen,seqn)fragment -> ((;ci)alert_reply) Result

val reIndex: oldID:ConnectionInfo -> newID:ConnectionInfo{CompatibleIndexes(oldID,newID)} ->
	(;oldID)state -> (;newID)state
