module Alert

open Bytes
open Error
open TLSInfo

private type (;ci:ConnectionInfo)pre_al_state = {
  al_incoming: bytes; (* incomplete incoming message *)
  al_outgoing: bytes (* emptybstr if nothing to be sent *) 
}
type (;ci:ConnectionInfo)state = (;ci)pre_al_state

// protocol-specific abstract fragment,
// and associated functions (never to be called with ideal functionality)
type (;ki:KeyInfo,tlen:int,seqn:int)fragment
predicate AlertFragment of KeyInfo * int * int * Bytes.bytes
val repr: ki:KeyInfo -> tlen:int -> seqn:int -> (;ki,tlen,seqn)fragment -> b:Bytes.bytes{AlertFragment(ki,tlen,seqn,b)}
val fragment: ki:KeyInfo -> tlen:int -> seqn:int -> b:Bytes.bytes{AlertFragment(ki,tlen,seqn,b) \/ Corrupt(ki)} -> (;ki,tlen,seqn)fragment

type (;ki:KeyInfo,seqn:int)ALFragReply =
    | EmptyALFrag
    | ALFrag of          (tlen:int * (;ki,tlen,seqn)fragment)
    | LastALFrag of      (tlen:int * (;ki,tlen,seqn)fragment)
    | LastALCloseFrag of (tlen:int * (;ki,tlen,seqn)fragment)

type (;ci:ConnectionInfo)alert_reply =
    | ALAck of          (;ci)state
    | ALClose of        (;ci)state
    | ALClose_notify of (;ci)state

val init: ci:ConnectionInfo -> (;ci)state

val send_alert: ci:ConnectionInfo -> (;ci)state -> alertDescription -> (;ci)state

val next_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)state -> ((;ci.id_out,seqn)ALFragReply * (;ci)state) 

val recv_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)state -> tlen:int -> (;ci.id_in,tlen,seqn)fragment -> ((;ci)alert_reply) Result

val reIndex: oldID:ConnectionInfo -> newID:ConnectionInfo{CompatibleIndexes(oldID,newID)} ->
	(;oldID)state -> (;newID)state
