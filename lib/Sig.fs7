module Sig

// TODO still many details to fix.

open Bytes
open TLSConstants

(* TLS uses three signatures algorithms, together with hash algorithm.
   We verify TLS security relative to those *combinations* of algorithms
   that provide CMA-security, as specified in this interface. 
   However, none of them are CMA-secure in the standard model under an 
   assumption weaker than "This scheme is secure".

   This interface is adapted from the one described in CCS'11:

       Cedric Fournet, Markulf Kohlweiss, Pierre-Yves Strub: Modular 
       code-based cryptographic verification. ACM Conference on Computer 
       and Communications Security 2011: 341-350

   Its implementation is trusted, not verified. *)

// CF we should verify its ideal implementation!?

(*********************** Cryptographic agility **************************** 

   note that the same key may be used with different hashes. 
   so we require some joint security assumption for them

   TLS 1.2 provides explicit support for it:
   [1.2] - Substantial cleanup to the client's and server's ability to
           specify which hash and signature algorithms they will accept.
           Note that this also relaxes some of the constraints on signature
           and hash algorithms from previous versions of TLS.
***************************************************************************)

// TODO: there is some adhocness processing of those algs left in Handshake.fs
  
// implements SignatureAndHashAlgorithm, with fewer values for hashAlg
//MK: I don't understand this comment.
type alg   = sigHashAlg //MK: now defined in TLSConstants.fs7: sigAlg * hashAlg

type text = bytes
type (;a:alg) sigv = bytes
  // TODO: specify their size, 36 with RSA, 20 with DSA
  // with TLS 1.2, this explicitly contains a; see DigitallySigned struct 

// Summary of the extension logic for the client:
// - specific to TLS 1.2
// - cs indicates sigAlg but not hashAlg, but "this is historical"
// - extension indicates supported algs (not necessarily following the cs)
// - no extension == client supports exactly the default alg

// let defaultAlg cs =
//   let a = 
//     match cs with 
//     | RSA | DH_RSA | DHE_RSA | RSA_PSK (* | ECDH_RSA | ECDHE_RSA *) -> RSA
//     | DH_DSS | DHE_DSS                                              -> DSA
//     | ECDH_ECDSA | ECDHE_ECDSA                                      -> ECDSA in
//   (a, SHA1)

// TODO: how to extract & checks the algs from certs?
// TODO: how does the server control the choice of algorithms? For now hardcoded.

//********************** Ideal Functionality for Signing *********************** 

//#begin-abstraction
type (;a:alg) skey
//#end-abstraction
type (;a:alg) pkey

function val PK: 'a -> 'b // a:alg * (;a)skey -> vkey
predicate Msg of a:alg * (;a)pkey * text 
predicate Honest of a:alg * (;a) pkey
predicate Strong of alg

val gen:     a:alg -> pk:(;a) pkey * sk:(;a) skey { pk = PK(sk) }
val sign:    a:alg -> sk:(;a) skey -> t:text{Msg(a,PK(sk),t)} -> (;a) sigv
val verify:  a:alg -> pk:(;a) pkey -> t:text -> m:(;a) sigv -> 
  b:bool {(b=true /\ Strong(a) /\ Honest(a,pk)) => Msg(a,pk,t)}

// MK bot used: val pkey:    a:alg -> CoreSig.sigpkey -> p:(;a) pkey
// MK not used: val pkey_repr:  a:alg -> p:(;a) pkey -> CoreSig.sigpkey 

val coerce:  a:alg -> p:(;a) pkey{not Honest(a,p)} -> CoreSig.sigskey -> s:(;a)skey{p = PK(s)}
val leak:    a:alg -> s:(;a) skey{not Honest(a,PK(s))} -> CoreSig.sigskey

private val create_pkey: a:alg -> CoreSig.sigpkey -> (;a)pkey

// TODO: adjust compromise model, connect it to Cert (mostly for the benefit of the adversary)
