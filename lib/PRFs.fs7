module PRFs

open Bytes
open Formats
open TLSInfo
open RSA
open Error

(* RSA pms is now defined in RSAPlain *)

// val empty_pms: si:SessionInfo -> (;si)preMasterSecret (* Deprecate? Used to implement a dummy DH key exchange *)
// val rsaEncryptPMS: si:SessionInfo -> asymKey -> (;si)preMasterSecret -> bytes Result (*$ how can this fail? *)

(** Server-side decryption of RSA PMS *) 

(* should be: rsaDecryptPMS *)
val getPMS: si:SessionInfo -> 
            vc:CipherSuites.ProtocolVersion (* highest client version, as above *) ->
            bool -> (* flag whether we should check protocol version in old TLS versions *)
            HSK.cert -> 
            bytes -> (;si)preMasterSecret (* No Result type: in case of error, we return a fresh random PMS *)


(****** MS ******) 

(** From PMS to MS *) 

type msRepr = b:bytes{ Length(b) = 48 }
private type (;si:SessionInfo) masterSecret = msRepr  

(* computes the MS from the PMS, some constant label, and the (crandom @| srandom) from si *)

val PRFsmoothRSA:
    si:SessionInfo -> 
    pms: (;si) RSAPlain.pms ->
    (;si) masterSecret 

val PRFsmoothDH:
    si:SessionInfo ->
	p: DH.p -> g: (;p) DH.elt -> gx: (;p) DH.elt -> gy: (;p) DH.elt -> 
	pms: (p,g,gx,gy) DH.pms ->
	(;si) masterSecret 

(** VerifyData MAC keyed with the master secret, relying on CMA ***)          

(* Generates verifyData for the Finished message *)

val prfVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
                   bytes (* msgLog *) -> 
                   bytes (* length depends on cs, 12 by default *)


(** KDF for the connection key materials, keyed with the master secret *)

type (;ci:ConnectionInfo) keyBlob
val prfKeyExp: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret ->
               (* No label, it's hardcoded. Of course we can make it explicit -> *)
               (* No seed (crandom @| srandom), it can be retrieved from epoch (and not SessionInfo!) -> *)
               (;ci)keyBlob (* length depends on cs *)

val splitStates: ci:ConnectionInfo -> (;ci)keyBlob -> ((;ci.id_out)StatefulAEAD.state * (;ci.id_in)StatefulAEAD.state)

val makeTimestamp: unit -> int
