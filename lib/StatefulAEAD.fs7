module StatefulAEAD

open TLSInfo
open Error
open StatefulPlain
open DataStream 
open Bytes

// TODO 12-02: 
// - Do we need to control the cipherlength?

private type (;ki:KeyInfo) prestate = {
  key: (;ki) AEAD.AEADKey;
  history: (;ki)history
}

predicate State of KeyInfo * prestate
//predicate Next of KeyInfo * state * data * range * fragment

private type (;ki:KeyInfo) state = (s:prestate) {State(ki,s)}

definition !ki,s. State(ki,s) <=>
	( SeqN(ki,s.history) = 0 \/
	  (?s'. State(ki,s') /\ 
	        // s.key = s'.key /\ // NO! s.key = NextAEADState(s'.key); the AEAD key changes over time!
			SeqN(ki,s.history) = SeqN(ki,s'.history)+1)
	)

type (;ki:KeyInfo) reader = r:(;ki) state
type (;ki:KeyInfo) writer = w:(;ki) state

val GEN: ki:KeyInfo{Safe(ki)} -> (;ki) reader * (;ki)writer
val COERCE: ki:KeyInfo{not Auth(ki)} -> b:bytes{Length(b)=AEAD.AEADSize(ki,())} -> (;ki)state
val LEAK: ki:KeyInfo{not Auth(ki)} -> (;ki)state -> b:bytes

val history: ki:KeyInfo -> s:(;ki) state -> h:(;ki)history{h=s.history}

type cipher = ENC.cipher
predicate STXT of ki:KeyInfo * (;ki)state * ad:(;ki)data * r:range * (;ki,r)Fragment.fragment * cipher
assume !ki,s,ad,r,f,c. STXT(ki,s,ad,r,f,c)
	<=> AEAD.CTXT(ki,MakeAD(ki,s.history,ad),r,f,c)

val encrypt: ki:KeyInfo -> 
  w:(;ki) writer -> 
  ad:(;ki)data ->
  r:range ->
  f: (;ki,w.history,ad,r) fragment ->
  (w':(;ki) writer * c:cipher){
    STXT(ki,w,ad,r,SAEADContents(f),c)}

val decrypt: ki:KeyInfo -> 
  r:(;ki) reader -> 
  ad:(;ki)data ->
  c:ENC.cipher ->
  res:((;ki) reader * rg:(rg:range{Length(c)=AEPlain.RangeCipher(ki,rg)}) * 
	 (;ki,r.history,ad,rg) fragment) Result{
	 !rd,rg,f. res = Correct(rd,rg,f) => 
		(Safe(ki) => STXT(ki,rd,ad,SAEADContents(f),c)) /\
        (Auth(ki) => STXT(ki,rd,ad,SAEADContents(f),c)) }
