module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open Stream 

type pre_app_state =
  {app_info: SessionInfo;
   app_incoming: stream;
   app_outgoing: stream}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes
  | ApplicationSend of SessionInfo * stream * bytes

type app_state = (aps:pre_app_state){ApplicationState(aps)}

function type funs =
  | InitAppState of SessionInfo

val init : i:SessionInfo -> a:app_state{a = InitAppState(i)}

val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state

val retrieve_data: app_state -> int -> (bytes * app_state) option

val next_fragment: as1:app_state -> int -> 
  (d:Record.fragment * as2:app_state{ApplicationSend(as1.app_info,History(as1.app_outgoing),d) /\ as2.app_info = as1.app_info}) option

val recv_fragment: aps:app_state ->
          d:fragment{ApplicationSend(OtherRole(aps.app_info),aps.app_incoming,d)} ->
	  app_state Result

(* Application state definition *)
assume !aps. ApplicationState(aps) <=> (?raps. raps.app_info = OtherRole(aps.app_info) /\ (aps.app_incoming = History(raps.app_outgoing) \/ Compromised(OtherRole(aps.app_info)) ))

(* When we can send data on the network from the outgoing stream *) 
assume !aps,d. ApplicationState(aps) /\ StreamRead(History(aps.app_outgoing),d) => ApplicationSend(aps.app_info,History(aps.app_outgoing),d)

theorem !raps,d. ApplicationSend(raps.app_info,History(raps.app_outgoing),d) => StreamRead(History(raps.app_outgoing),d) /\ ApplicationState(raps)

ask !aps,d. ApplicationState(aps) /\ ApplicationSend(OtherRole(aps.app_info),aps.app_incoming,d) => (StreamRead(aps.app_incoming,d) \/ Compromised(OtherRole(aps.app_info)))

(* When can we add data to the outgoing buffer *)
assume !aps,d. AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)

(* Initial application state *)
assume !info. InitAppState(info) = {
		app_info = info;
		app_incoming = empty_stream;
		app_outgoing = empty_stream}

ask !i,aps. aps = InitAppState(i) => ApplicationState(aps)

