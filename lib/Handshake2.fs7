module Handshake
// An abstract interface to the Handshake protocol, including PKIs and the session database

open Bytes
open Error
open CipherSuites
open TLSInfo
open TLSKey
open AppConfig

(* There is one instance of the protocol for each TCP connection
   run by an honest principal, each able to perform as sequence 
   of handshakes for that connection *)

type (;ci:ConnectionInfo) state (* for each local instance of the protocol *)

(* Control Interface *) 

val init: ci:ConnectionInfo -> Direction -> protocolOptions -> (;ci)state
val resume: ci:ConnectionInfo -> si:SessionInfo -> protocolOptions -> (;ci)state
val rehandshake: ci:ConnectionInfo -> (;ci) state -> protocolOptions -> (;ci) state
val rekey: ci:ConnectionInfo -> (;ci) state -> protocolOptions -> (;ci) state
val request: ci:ConnectionInfo -> (;ci) state -> protocolOptions -> (;ci) state

(* Network Interface *)

type (;ki:KeyInfo,l:nat) fragment
val repr:     ki:KeyInfo -> l:nat -> (;ki,l) fragment -> b:bytes{Length(b)=l}
val fragment: ki:KeyInfo -> l:nat -> b:bytes{Length(b)=l} -> (;ki,l) fragment

type (;ki:KeyInfo,l:nat) ccsFragment
val ccsRepr:     ki:KeyInfo -> (;ki,1) ccsFragment -> b:bytes{Length(b)=1}
val ccsFragment: ki:KeyInfo -> b:bytes{Length(b)=1} -> (;ki,1) ccsFragment

type (;ki:KeyInfo) outgoing = (* handshakes wants to send... *)
  | OutIdle                                 (* nothing  *) 
  | OutSome of l:int * (;ki,l) fragment (* a fragment *)            
  | OutCCS of (;ki,1) fragment * newk:KeyInfo * (;newki) ccs_data
                          (* the CCS, then use these writing params *)
  | OutFinished of l:int * (;ki,l) fragment (* a fragment that ends the finished message *)
  | OutComplete of l:int * (;ki,l) fragment (* idem + stating the handshake is complete *)
val nextFragment: ci:ConnectionInfo -> (;ci) state -> (;ci.id_out) outgoing * (;ci) state

type (;ki:KeyInfo) incoming = (* the fragment is accepted, and... *)
  | InAck                      (* nothing happens *)
  | InCheck of ProtocolVersion (* as client, must now check the negotiated version *)
  | InPatch of ProtocolVersion (* as server, must now patch the negotiated version *)
  | InFinished                 (* we just accepted the finished message *) 
  | InComplete                 (* idem + stating the hanshake is complete *)  
val recvFragment: 
  ci:ConnectionInfo -> (;ci) state -> l:nat -> (;ci.id_in,l) fragment -> 
  (;ci.id_in.sinfo) incoming Result * (;ci) state
val recvCCS:
  ci:ConnectionInfo -> (;ci) state -> (;ci.id_in,1) ccsFragment ->
  (ki:KeyInfo * (;ki) ccs_data) Result * (;ci) state
