module TLS

open Tcp
open Error
open Bytes
open AppConfig
open DataStream
open AppDataStream
open Dispatch
open TLSInfo

type index  = ConnectionInfo
type conn   = Dispatch.Connection
type params = protocolOptions

val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}

function val Role: conn -> Direction
assume !c. Role(c) = ConnectionOutKeyInfo(c).dir

type (;c:conn) OutSameConnection =
    c':conn{Role(c) = Role(c') /\  ConnectionInKeyInfo(c) =  ConnectionInKeyInfo(c')}

type (;c:conn)  InSameConnection =
    c':conn{Role(c) = Role(c') /\ ConnectionOutKeyInfo(c) = ConnectionOutKeyInfo(c')}

type (;c:conn)    SameConnection =
    c':conn{Role(c) = Role(c') /\      ConnectionIndex(c) =      ConnectionIndex(c')}

function val Dual: ConnectionInfo -> ConnectionInfo
assume !ki. Dual(ki) = { id_in = ki.id_out; id_out = ki.id_in }

predicate val TXT: index -> bool
predicate val SEC: index -> bool

predicate val Fatal: (index * bytes) -> bool
predicate val Close: (index * bytes) -> bool
predicate val Write: (index * bytes) -> bool
predicate val Read : (index * bytes) -> bool

function val  ConnInStream: c:conn -> (; ConnectionInKeyInfo(c)) stream
function val ConnOutStream: c:conn -> (;ConnectionOutKeyInfo(c)) stream

assume !id, s.  ConnInStream(Conn(id, s)) =  InStream(id, s.appdata)
assume !id, s. ConnOutStream(Conn(id, s)) = OutStream(id, s.appdata)

function val WrittenBytes: conn -> bytes
function val    ReadBytes: conn -> bytes

assume !c. WrittenBytes(c) =  ConnInStream(c)
assume !c.    ReadBytes(c) = ConnOutStream(c)

type (;c:conn, r:range)  indelta = (; ConnectionInKeyInfo(c),  ConnInStream(c), r) delta
type (;c:conn, r:range) outdelta = (;ConnectionOutKeyInfo(c), ConnOutStream(c), r) delta

type (;c:conn) query

predicate val OutSplit : // FIXME: ugly
    (rg0:range              * newrg:range                   * rg:range *
     c  :conn               * newc :conn                    *
     d0 :(;c, rg0) outdelta * newd :(;newc, newrg) outdelta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:conn * c':conn * rg:range * (;c, rg) outdelta) -> bool
predicate val  ReadExtend : (c:conn * c':conn * rg:range * (;c, rg)  indelta) -> bool
predicate val    NoExtend : (c:conn * c':conn) -> bool

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WrittenBytes(c') = WrittenBytes(c) @| d
    /\    ReadBytes(c') =    ReadBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
          ReadBytes(c') =    ReadBytes(c) @| d
    /\ WrittenBytes(c') = WrittenBytes(c)
    /\       Params(c') =       Params(c)

definition !c, c'. NoExtend(c, c') <=>
          ReadBytes(c) =    ReadBytes(c')
    /\ WrittenBytes(c) = WrittenBytes(c')
    /\       Params(c) =       Params(c')

type (;c:conn, rg:range, d:(;c, rg) outdelta) ioresult_o =
| Out_Error         of ErrorKind * ErrorCause
| Out_MustRead      of c':(;c) InSameConnection { NoExtend(c, c') }
| Out_WriteComplete of c':(;c) SameConnection { WriteExtend(c, c', rg, d) }
| Out_WritePartial  of c':(;c) SameConnection * rg':range * d':(;c', rg') outdelta {
     ?d0, rg0.    WriteExtend(c, c', rg0, d0)
               /\ OutSplit(rg0, rg', rg, c, c', d0, d', d)
  }

type (;c:conn) ioresult_i =
| In_Error of ErrorKind * ErrorCause

| In_Warning of c':(;c) SameConnection * alertDescription { NoExtend(c, c') }

| In_Fatal   of c':(;c) SameConnection {
    TXT(ConnectionIndex(c)) => Fatal(Dual(ConnectionIndex(c)), ReadBytes(c))
  }

| In_CertQuery of c':(;c) SameConnection * (;c') query

| In_HandshakeDone of c':conn {
    Role(c) = Role(c') /\ WrittenBytes(c') = [||] /\ ReadBytes(c') = [||]
  }

| In_Close of unit {
    TXT(ConnectionIndex(c)) => Close(Dual(ConnectionIndex(c)), ReadBytes(c))
  }

| In_Read of c':(;c) SameConnection * rg:range * d:(;c, rg) indelta {
       ConnectionIndex(c) <> null
    /\ ReadExtend(c, c', rg, d)
    /\ TXT(ConnectionIndex(c)) => Write(Dual(ConnectionIndex(c)), ReadBytes(c'))
  }

// client-only; as is, must be followed by a read until Handshaken
val connect: NetworkStream -> p:params ->
  (c:conn { ConnectionIndex(c) = null /\ Params(c) = p /\ Role(c) = CtoS }) Result

val resume: NetworkStream -> sid:sessionID -> p:params -> // FIXME: sid in post
  (c:conn { ConnectionIndex(c) = null /\ Params(c) = p /\ Role(c) = CtoS }) Result

// server-only; as is, must be followed by a read until Handshaken
val accept:  NetworkStream -> p:params ->
  (c:conn { ConnectionIndex(c) = null /\ Params(c) = p /\ Role(c) = StoC }) Result

// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))
val write: c:conn -> rg:range -> d:(;c, rg) delta -> (;c, rg, d) ioresult_o
val read : c:conn -> (;c) ioresult_i

// ?non-blocking?
val rekey      : c:conn -> (c':(;c) SameConnection { NoExtend(c, c') }) Result
val rehandshake: c:conn -> (c':(;c) SameConnection { NoExtend(c, c') }) Result
val shutdown   : c:conn -> (c':(;c) SameConnection { NoExtend(c, c') }) Result
  
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:conn -> (;c) query -> (c': (;c) SameConnection { NoExtend(c, c') }) Result
val refuse:    c:conn -> (;c) query -> unit
