(* Handshake protocol *) 
module Handshake

open Error
//open Formats
open CipherSuites
open TLSInfo
open TLSKey
open AppConfig
//open SessionDB

// There is one instance of the protocol for each TCP connection,
// each performing a sequence of Handshakes for that connection.

// protocol state  
type (;ci:ConnectionInfo) pre_hs_state 
type (;ci:ConnectionInfo) hs_state = (;ci)pre_hs_state

// protocol-specific abstract fragment,
// and associated functions (never to be called with ideal functionality)
type (;ki:KeyInfo,tlen:DataStream.range,seqn:int) fragment
predicate HandshakeFragment of KeyInfo * DataStream.range * int * Bytes.bytes
predicate CCSFragment of KeyInfo * DataStream.range * int * Bytes.bytes

val repr: ki:KeyInfo -> tlen:DataStream.range -> seqn:int -> (;ki,tlen,seqn)fragment -> b:Bytes.bytes{HandshakeFragment(ki,tlen,seqn,b)}
val fragment: ki:KeyInfo -> tlen:DataStream.range -> seqn:int -> b:Bytes.bytes{HandshakeFragment(ki,tlen,seqn,b) \/ Corrupt(ki)} -> (;ki,tlen,seqn)fragment
type (;ki:KeyInfo,tlen:DataStream.range,seqn:int)ccsFragment
val ccsRepr: ki:KeyInfo -> tlen:DataStream.range -> seqn:int -> (;ki,tlen,seqn)ccsFragment -> b:Bytes.bytes{CCSFragment(ki,tlen,seqn,b)}
val ccsFragment: ki:KeyInfo -> tlen:DataStream.range -> seqn:int -> Bytes.bytes -> (;ki,tlen,seqn)ccsFragment

(* Locally controlling handshake protocols *) 

//TODO better names, maybe: init/accept resume reshake rekey request

// Create instance for a fresh connection (without resumption) 
val init_handshake: ci:ConnectionInfo -> Direction -> protocolOptions -> (;ci)hs_state

// Create instance for a fresh connection (Client-only, resuming some other sessions)
val resume_handshake: ci:ConnectionInfo -> nextSI:SessionInfo -> (;nextSI)PRFs.masterSecret -> protocolOptions -> (;ci)hs_state

// All other calls are affine in the Handshake protocol state


// Idle client starts a full handshake on the current connection
val start_rehandshake: ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state

// Idle client starts an abbreviated handshake resuming the current session 
val start_rekey:       ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state

// (Idle) Server requests an handshake 
val start_hs_request:  ci:ConnectionInfo -> (;ci)hs_state -> protocolOptions -> (;ci)hs_state


// ? resetting; TODO we'll try to get rid of it, and ensure that 
// handshake.fs leaves hs_state in the resulting state after completion
// val new_session_idle:  hs_state -> SessionInfo -> PRFs.masterSecret -> hs_state


(* Sending Handshake and CCS fragments *)

//TODO make SessionDB internal to handshake (or object!)
//TODO systematically rename FullyFinished to Complete etc
//TODO provide support for indexing fragments (probably by directed si, not ki)


type (;ki:KeyInfo,seqn:int) HSFragReply =
  | EmptyHSFrag              (* nothing to send *) 
  | HSFrag of                (tlen:DataStream.range * (;ki,tlen,seqn)fragment)
  | CCSFrag of               (tlen:DataStream.range * (;ki,tlen,seqn)ccsFragment) (* the unique one-byte CCS *) * (newKI:KeyInfo * (;newKI)ccs_data)
  | HSWriteSideFinished of   (tlen:DataStream.range * (;ki,tlen,seqn)fragment) (* signalling that this fragment ends the finished message *)
  | HSFullyFinished_Write of (tlen:DataStream.range * (;ki,tlen,seqn)fragment) * ((si:SessionInfo * (;si)PRFs.masterSecret * Direction){si=ki.sinfo})
val next_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)hs_state -> (;ci.id_out,seqn)HSFragReply * (;ci)hs_state

(* Receiving Handshake and CCS fragments *) 

type (;si:SessionInfo)recv_reply = (* the fragment is accepted, and... *)
  | HSAck (* nothing happens *)
  | HSVersionAgreed of ProtocolVersion (* use this new protocol version for sending *)
  | HSReadSideFinished (* ? *) 
  | HSFullyFinished_Read of ((si':SessionInfo * (;si')PRFs.masterSecret * Direction){si=si'}) (* we can start sending data on the connection *)  
val recv_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)hs_state -> tlen:DataStream.range -> (;ci.id_in,tlen,seqn)fragment -> (;ci.id_in.sinfo)recv_reply Result * (;ci)hs_state
val recv_ccs     : ci:ConnectionInfo -> seqn:int -> (;ci)hs_state -> tlen:DataStream.range -> (;ci.id_in,tlen,seqn)ccsFragment -> ((newKI:KeyInfo * (;newKI)ccs_data) Result) * (;ci)hs_state

val reIndex: oldID:ConnectionInfo -> newID:ConnectionInfo{CompatibleConnections(oldID,newID)} ->
	(;oldID)hs_state -> (;newID)hs_state
