module TLSInfo


(* TODOs 20-12-12:
- VerifyData and SentCCS should be about epochs not sessions (change PRF!)
    
- Fix Sig/VerifyData/Complete as discussed with Cedric

- Declare all Strong predicates. Define in TLS?
  PRF.Strong, CRE.Strong, RSAPMS, DHPMS, StrongHS, Sig.Strong, StrongAE, StrongAuth
  
- Declare all honest predicates
  RSAKeys.Honest(pk) (enc), Sig.Honest(a,pk)
  HonestRSAPMS(pv,pk,epms), HonestDHPMS(p,g,gx,gy)
  extend to HonestMS, HonestKeys
  (* Future: HonestKeys *)

- What is used: DHGroup or DH?

- We need to typecheck ideal code, so rewrite all modules in the style
   #if ideal
   if safeHS(...) 
     ... GEN ...
   else 
   #endif
     .... COERCE ...
This requires concrete safe/auth/strong/honest functions (specify, dont implement)
*)

(* public datatypes and parameters for our TLS API *) 

open Bytes
open TLSConstants


type sessionID = b:bytes {Length(b) <= 32}
// "An arbitrary byte sequence chosen by the server 
// to identify an active or resumable session state."
// We treat [||] as the absence of identifier.

type preRole =
	| Client
	| Server
type Role = r:preRole{r = Client \/ r = Server}

// Client/Server randomness (implemented in Nonce) 
// their first 4 bytes give the local time, 
// so that they are locally pairwise-distinct
type random = (;32) lbytes 
type crand = random
type srand = random

// SessionInfo and epoch: Session and Connection level public immutable data.
// Used for indexing

//CF 04-09 the randoms are not just bytes; where do we rely on collision-resistance?

type pmsData =
    | PMSUnset
    | RSAPMS of encpms:bytes
    | DHPMS  of p:DHGroup.p * g:(;p)DHGroup.g *
		  	      gx:(;p)DHGroup.elt (* Client *) *
			      gy:(;p)DHGroup.elt (* Server *)

// To be defined 
predicate HonestRSAPMS of encpms:bytes
predicate HonestDHPMS of p:DHGroup.p * g:(;p)DHGroup.g *
		  	      gx:(;p)DHGroup.elt (* Client *) *
			      gy:(;p)DHGroup.elt (* Server *)

predicate HonestPMS of pmsData
assume !pd. HonestPMS(pd) <=>
      ((?e. pd = RSAPMS(e) /\ HonestRSAPMS(e)) \/
       (?p,g,gx,gy. pd = DHPMS(p,g,gx,gy)))
(* DHPMS(si) <=> HonestClientExponent(si) /\ HonestServerExponent(si) *)

// TODO this is out of sync with the paper, on client_auth.
type SessionInfo = {
    init_crand: crand;
    init_srand: srand;
    protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
    pmsData: pmsData;
    client_auth: bool;
    clientID: Cert.cert list;
    serverID: Cert.cert list;
    sessionID: sessionID;
    }
// for certificates, the empty list represents the absence of identity 
// (possibly refusing to present requested certs) 
//   
// for sessionID, the empty bytes [||] represents the absence of ID,
// that is, the session is not resumable. 

private type preEpoch =
  | InitEpoch of Role * random  (* our fresh local random *)
  | SuccEpoch of crand * srand  (* the latest randoms     *)
               * si:SessionInfo
	       * pred:preEpoch 

predicate val IsInitEpoch: preEpoch -> bool
predicate val IsSuccEpoch: preEpoch -> bool
private definition !e. IsInitEpoch(e) <=> ?r,b. e = InitEpoch(r,b)
private definition !e. IsSuccEpoch(e) <=> ?c,s,si,pe. e = SuccEpoch(c,s,si,pe)

type epoch = e:preEpoch {IsInitEpoch(e) \/ IsSuccEpoch(e)}
type succEpoch = e:preEpoch {IsSuccEpoch(e)}

function val Pred: epoch -> epoch
private definition !cr,sr,si,pred. Pred(SuccEpoch(cr,sr,si,pred)) = pred

function val EpochSI: succEpoch -> SessionInfo
private definition !c,s,si,p. EpochSI(SuccEpoch(c,s,si,p)) = si

function val EpochSRand: succEpoch -> bytes
function val EpochCRand: succEpoch -> bytes
private definition !b1,b2,si,pe. EpochSRand(SuccEpoch(b1,b2,si,pe)) = b2
private definition !b1,b2,si,pe. EpochCRand(SuccEpoch(b1,b2,si,pe)) = b1

val isInitEpoch: e:epoch -> b:bool{(b = true /\ IsInitEpoch(e)) \/ (b = false /\ IsSuccEpoch(e))}
val epochSI: e:succEpoch -> si:SessionInfo{si = EpochSI(e)}

val epochSRand: e:succEpoch -> b:crand{b = EpochSRand(e)}
val epochCRand: e:succEpoch -> b:srand{b = EpochCRand(e)}

type ConnectionInfo =
	{ role: Role;
	  id_in:  epoch;
      id_out: epoch}

val connectionRole: ci:ConnectionInfo -> r:Role{r = ci.role}

val initConnection: r:Role -> ra:random -> ci:ConnectionInfo{ci.role = r /\ IsInitEpoch(ci.id_in) /\ IsInitEpoch(ci.id_out)}
val nextEpoch: e:epoch -> c:crand -> s:srand -> si:SessionInfo ->
	e':succEpoch{Pred(e') = e /\ EpochSI(e') = si /\
			     EpochCRand(e') = c /\ EpochSRand(e') = s}


/// Predicates specifying cryptographic assumptions on algorithms 

// TODO relocate to TLSConstants?
predicate CPA of cipherAlg //IND-CPA
// some reasonable assumptions:
// assume(CPA(AES_128_CBC))
// assume(CPA(AES_256_CBC))

predicate CMA of hashAlg //INT-CMA_M
// some reasonable assumptions:
// assume(CMA(SHA))
// assume(CMA(SHA256))
// assume(CMA(SHA384))

predicate CTXT of cipherAlg * hashAlg //INT-CTXT
// some reasonable assumptions:
// assume !e. PRF(m)  => CTXT(AES_128_CBC,m) // /\ SPRP(AES_128)
// assume !e. PRF(m)  => CTXT(AES_256_CBC,m) // /\ SPRP(AES_256)
// CF where do we declare & assume CTXTR and SPRP?
predicate StrongAE of cipherSuite
predicate StrongAuth of cipherSuite

definition !s. StrongAE(s)   <=> (?e,m. IsAEADCiphersuite(s) /\ AEAlg(s) = MtE(e,m) /\ CPA(e) /\ CTXT(e,m))
definition !s. StrongAuth(s) <=> (?e,m. IsAEADCiphersuite(s) /\ AEAlg(s) = MtE(e,m) /\ CMA(m))


// Predicates specifying the security of TLS connections 

predicate type cryptopreds = 
| SafeSI  of SessionInfo // The session ciphersuite yields secrecy and integrity
| AuthSI  of SessionInfo // The session ciphersuite yields integrity (not necessarily secrecy)
| SafeHS of epoch // Good handshake for this epoch
| Safe   of epoch // The epoch parameters yield privacy & integrity
| Auth   of epoch // The epoch parameters yield integrity (not necesarily privacy)

(*

// CF Handshake predicates; seems Ok. Why commented out? 
predicate INT_CMA_S of ProtocolVersion * cipherSuite
predicate CRE       of ProtocolVersion * cipherSuite
predicate PRF       of ProtocolVersion * cipherSuite
predicate RSA_PMS   of ProtocolVersion * cipherSuite
predicate DH_PMS    of ProtocolVersion * cipherSuite
predicate StrongHS  of ProtocolVersion * cipherSuite

definition !v,s. StrongHS(v,s) <=> INT_CMA_S(v,s) /\ CRE(v,s) /\ PRF(v,s) /\ ( RSA_PMS(v,s) \/ DH_PMS(v,s) )

definition !e. SafeHS(id) <=> 
      StrongHS(EpochSI(id).protocol_version,CS(id)) 
   /\ ClientPMS(EpochSI(id))
   /\ Honest(ServerKey(id))
// /\ Honest(LTKey(id)) /\ Honest(LTKey(Peer(id)))

*)

//AP Resurrecting this for the time being. What do we do with the comments above?
predicate StrongHS  of ProtocolVersion * cipherSuite
definition !si. SafeSI(si) <=> StrongHS(si.protocol_version,si.cipher_suite) /\ StrongAE  (si.cipher_suite)
definition !si. AuthSI(si) <=> StrongHS(si.protocol_version,si.cipher_suite) /\ StrongAuth(si.cipher_suite)

definition !e. SafeHS(e) <=> StrongHS(EpochSI(e).protocol_version,EpochSI(e).cipher_suite) //AP /\ Complete(e)?

definition !e. Safe(e) <=> SafeHS(e) /\ SafeSI(EpochSI(e))
definition !e. Auth(e) <=> SafeHS(e) /\ AuthSI(EpochSI(e))

// not quite derivable unless we add CTXT => CMA
// CF do we use it?
assume !ki. Safe(ki) => Auth(ki) 

ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => not Safe(ki)
ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => 
    not (?kex,s. EpochSI(ki).cipher_suite = CipherSuite(kex,s))

// so that TLS can exchange any traffic on the initial null connection
assume !e. IsInitEpoch(e) => not Auth(e)


(* Application configuration options *) 

// TODO Consider repackaging client and server options 

type helloReqPolicy =
    | HRPIgnore
    | HRPFull
    | HRPResume

type config = {
    minVer: ProtocolVersion;
    maxVer: ProtocolVersion;
    ciphersuites: cipherSuites;
    compressions: Compression list;

    (* Handshake specific options *)

    (* Client side *)
    honourHelloReq: helloReqPolicy;
    allowAnonCipherSuite: bool;

    (* Server side *)
    request_client_certificate: bool;
    check_client_version_in_pms_for_old_tls: bool;

    (* Common *)
    safe_renegotiation: bool;
	server_name: Cert.hint;
	client_name: Cert.hint;

    (* Sessions database *)
    sessionDBFileName: string;
    sessionDBExpiry: TimeSpan
    }

val defaultConfig: config

private val max_TLSPlaintext_fragment_length: nat
private val max_TLSCompressed_fragment_length: nat
val max_TLSCipher_fragment_length: nat
val fragmentLength: nat

(* Ranges of lengths for byte arrays *) 

type range = low:nat * high:nat { low <= high }
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   
function val Sum: range * range -> range
definition !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val rangeSum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}
