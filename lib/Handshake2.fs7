module Handshake
(* An abstract interface to the Handshake protocol, including PKIs and the session database *)

open Bytes
open Error
open CipherSuites
open TLSInfo
open TLSKey
open AppConfig

type config = protocoOptions option

(* Control Interface *) 

type (;r:Direction,o:config) state (* for each local instance of the protocol *)

val init: d:Direction -> o:protocolOptions -> (;d,Some(o)) state 
val resume: si:SessionInfo -> o:protocolOptions -> (;Role(si),Some(o)) state
val rehandshake: (;Client,None) state -> o:protocolOptions -> (;Client,Some(o)) state
val rekey:       (;Client,None) state -> o:protocolOptions -> (;Client,Some(o)) state
val request:     (;Server,None) state -> o:protocolOptions -> (;Server,Some(o)) state
//CF later, understand how the server can pick options for unrequested rehandshakes

(* Network Interface *)

type (;ki:KeyInfo,l:nat) hsFragment
type (;ki:KeyInfo) fragment = l:nat * (;ki,l) hsFragment
val repr:     ki:KeyInfo -> l:nat -> (;ki,l) hsFragment -> b:bytes{Length(b)=l}
val fragment: ki:KeyInfo -> l:nat -> b:bytes{Length(b)=l} -> (;ki,l) hsFragment

type (;ki:KeyInfo,l:nat) ccsFragment
val ccsRepr:     ki:KeyInfo -> (;ki,1) ccsfragment -> b:bytes{Length(b)=1}
val ccsFragment: ki:KeyInfo -> b:bytes{Length(b)=1} -> (;ki,1) ccsFragment

type (;r:Direction,o:config,ki:KeyInfo) outgoing = 
  | OutIdle of       (;r,o) state
  | OutSome of       (;r,o) state * (;ki) fragment             
  | OutCCS of      s:(;r,o) state * (;ki,1) ccsFragment * (;OutKi(s)) ccsData {OutReady(s)} 
  | OutFinished of   (;r,o) state * (;ki) fragment
  | OutComplete of s:(;r,o) state * (;ki) fragment {Complete(r,o,s)} 
val nextFragment: r:Direction -> o:config -> (;r,o) state -> ki:keyInfo -> (;r,o,ki) outgoing 

type (;r:Direction,o:config) incoming = 
  | InAck of     (;r,o) state 
  | InVersion of (;r,o) state * ProtocolVersion 
  | InFinished   (;r,o) state  
  | InComplete s:(;r,o) state {Complete(s)}  
  | InError of   (;r,o) state * ErrorCause * ErrorKind

val recvFragment: r:Direction -> o:config -> (;r,o) state -> 
  ki:keyInfo -> (;ki) fragment -> (;r,o) incoming

val recvCCS: r:Direction -> o:config -> (;r,o) state -> 
  ki:keyInfo -> (;r,o) state -> (;ki,1) ccsFragment -> 
  s:(;r,o) state * (((;InKi(s)) ccsData {InReady(s)}) Result) 
  
theorem !s, Complete(r,o,s) => (*...*) Safe(Outki(s)) /\ Safe(Inki(s)) 