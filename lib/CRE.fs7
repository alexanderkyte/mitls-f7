module CRE

open Bytes
open TLSConstants
open TLSInfo
open DHGroup

type rsarepr = (;48)lbytes

private val prfMS: si:SessionInfo -> p:bytes -> (;si) PRF.masterSecret

//#begin-abstractionRSA

private type rsaseed = {seed:rsarepr} // treated abstractly almost everywhere in this file
private type (;pk:RSAKey.pk, pv:ProtocolVersion) rsapms = 
   | IdealRSAPMS    of rsaseed 
   | ConcreteRSAPMS of rsarepr

predicate CREHonestRSAPMS of pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms

private definition !pk,pv,pms. CREHonestRSAPMS(pk,pv,pms) <=> ?s. pms = IdealRSAPMS(s)

//private definition !pk,pv,pms. SafeRSAPMS(pk,pv) <=> ?s. pms = IdealRSAPMS(s)

private definition !pk,pv,pms. SafeRSAPMS(pk,pv) <=> CREHonestRSAPMS(pk,pv,pms)

theorem !pk,pv,pms. not CREHonestRSAPMS(pk,pv,pms) => not SafeRSAPMS(pk,pv)

val honestRSAPMS: pk:RSAKey.pk -> pv:ProtocolVersion -> pms: (;pk,pv) rsapms -> b:bool { b=true <=> CREHonestRSAPMS(pk,pv,pms) } 

val genRSA: pk:RSAKey.pk -> pv:ProtocolVersion -> pms:(;pk,pv)rsapms
val coerceRSA: pk:RSAKey.pk -> pv:ProtocolVersion (* MK suspicious {not SafeRSAPMS(pk,pv)} *)-> b:bytes {Length(b)=48} -> (;pk,pv)rsapms
val leakRSA: pk:RSAKey.pk -> pv:ProtocolVersion -> pms:(;pk,pv)rsapms {not SafeRSAPMS(pk,pv)}-> bytes

//#end-abstractionRSA

private function val Fifth: 'a -> 'b
private definition !e1,e2,e3,e4,e5. Fifth((e1,e2,e3,e4,e5)) = e5

private type rsaentry = i':(pk':RSAKey.pk * pv':ProtocolVersion * (;pk',pv')rsapms * csr':bytes * si':SessionInfo) * ms':(;Fifth(i')) PRF.masterSecret
private val rsalog: rsaentry list ref 

val rsaassoc: i:(pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms * csr:bytes * si:SessionInfo) -> 
              (i':(pk':RSAKey.pk * pv':ProtocolVersion * (;pk',pv')rsapms * csr':bytes * si':SessionInfo) * ms':(;Fifth(i')) PRF.masterSecret) list -> 
			  ms:(;Fifth(i)) PRF.masterSecret option

val prfSmoothRSA:
    si:SessionInfo ->
	pv:ProtocolVersion ->
    pms: (;Cert.RSAPKCert(si.serverID),pv) rsapms ->
    (;si) PRF.masterSecret


//#begin-abstractionDH

type dhrepr = bytes

private type dhseed = {seed:dhrepr} // treated abstractly almost everywhere in this file
private type (;p:p, g:(;p) g, gx:(;p) elt, gy:(;p) elt) dhpms =   
   | IdealDHPMS    of dhseed 
   | ConcreteDHPMS of dhrepr

predicate CREHonestDHPMS of p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms

private definition !p,g,gx,gy,pms. CREHonestDHPMS(p,g,gx,gy,pms) <=> ?s. pms = IdealDHPMS(s)

val honestDHPMS: p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt -> pms: (;p,g,gx,gy) dhpms -> b:bool { b=true <=> CREHonestDHPMS(p,g,gx,gy,pms) } 

val sampleDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt ->  (;p,g,gx,gy) dhpms
val coerceDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt {not SafeDHPMS(p,g,gx,gy)}-> (;p)elt -> (;p,g,gx,gy) dhpms
//#end-abstractionDH

//private type dsentry = i:(pk':RSAKey.pk * pv':ProtocolVersion * (;pk',pv')rsapms * csr':bytes * si':SessionInfo) * ms':(;Fifth(i')) PRF.masterSecret
//private val dslog: rsaentry list ref 

//val dhassoc: p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms * bytes * si:SessionInfo -> 
//             ((p':p * g':(;p') g * gx':(;p') elt * gy':(;p') elt * (;p',g',gx',gy') dhpms * bytes) * (;si) PRF.masterSecret) list -> 
//             (;si) PRF.masterSecret option

// AP: Don't we really want *any* link between si and (g,p,gx,gy)?
val prfSmoothDHE:
    si:SessionInfo ->
    p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms ->
    (;si) PRF.masterSecret


