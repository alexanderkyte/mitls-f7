module TLS // excerpts for the paper
open Error
open Bytes
open DataStream
open AppDataStream
open Dispatch
open TLSInfo 


type (;c:cn) query
type (;c:cn) msg_i = r:range * (;ConnectionInKeyInfo(c),  CnStream_i(c), r) delta
type (;c:cn) msg_o = r:range * (;ConnectionOutKeyInfo(c), CnStream_o(c), r) delta

type (;c:cn) ioresult_i =
| Read      of c':(;c) nextCn * d:(;c) msg_i
  {Extend_i(c,c',d) /\ (TXT(CnId(c)) => Write(Peer(CnId(c)), Bytes_i(c'))) }
| Close of TCP.NetworkStream  {TXT(CnId(c)) => Close(Peer(CnId(c)), Bytes_i(c))}
| Fatal     of a:alertDescription {TXT(CnId(c)) => Fatal(Peer(CnId(c)), a, Bytes_i(c))}
| Warning   of c':(;c) nextCn * a:alertDescription 
  {Extend(c,c') /\ TXT(CnId(c)) => Warning(Peer(CnId(c)), a, Bytes_i(c))}
| CertQuery of c':(;c) nextCn * (;c') query {Extend(c, c')} 
| Handshake of c':cn {...}
| ...
val read : c:cn -> (;c) ioresult_i

type (;c:cn,d:(;c) msg_o) ioresult_o =
| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
| WritePartial  of c':(;c) nextCn * d':(;c') msg_o 
  { ?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d') }
| WriteError    of alertDescription option 
| MustRead      of c':cn {...}
val write: c:cn -> d:(;c,rg) msg_o -> (;c,d) ioresult_o

val connect: TCP.Stream -> p:params                  -> (;Client,p) nullCn Result
val resume:  TCP.Stream -> p:params -> sid:sessionID -> (;Client,p) nullCn Result 
val accept:  TCP.Stream -> p:params                  -> (;Server,p) nullCn Result
val shutdown: c:cn -> TCP.Stream Result
val rekey:       c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val rehandshake: c:cn {Role(c)=CtoS} -> (c':(;c) nextCn {Extend(c,c')}) Result
val request:     c:cn {Role(c)=StoC} -> (c':(;c) nextCn {Extend(c,c')}) Result
val authorize: c:cn -> (;c) query -> (c': (;c) nextCn {Extend(c,c')}) Result
val refuse:    c:cn -> (;c) query -> unit 