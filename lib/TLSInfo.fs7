module TLSInfo

open Bytes
open Certificate
open CipherSuites

type sessionID = bytes
type preRole =
	| Client
	| Server
type Role = r:preRole{r = Client \/ r = Server}

//CF 04-09
// the randoms are not just bytes.

type SessionInfo = {
    clientID: cert option;
    serverID: cert option;
    sessionID: sessionID option;
    protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
    init_crand: bytes;
    init_srand: bytes}

private type preEpoch =
	| InitEpoch of Role * ourRand:bytes 
	| SuccEpoch of crand:bytes * srand:bytes * si:SessionInfo * pred:preEpoch 

type epoch = p:preEpoch

predicate NullSessionInfo of SessionInfo
assume !si. NullSessionInfo(si) <=> (si.clientID = None /\ si.serverID = None /\ si.sessionID = None /\
    IsNullCiphersuite(si.cipher_suite) /\ si.compression = NullCompression /\ si.init_crand = [||] /\ si.init_srand = [||] )

val null_sessionInfo: pv:ProtocolVersion -> si:SessionInfo{NullSessionInfo(si)}
val isNullSessionInfo: s:SessionInfo -> b:bool{b=true => NullSessionInfo(s)}

function val EpochSI: epoch -> SessionInfo
val epochSI: e:epoch -> si:SessionInfo{si = EpochSI(e)}

val epochSRand: e:epoch -> b:bytes{!b1,b2,si,pe. e = SuccEpoch(b1,b2,si,pe) => b = b2}
val epochCRand: e:epoch -> b:bytes{!b1,b2,si,pe. e = SuccEpoch(b1,b2,si,pe) => b = b1}

type ConnectionInfo =
	{ role: Role;
	  id_in:  epoch;
      id_out: epoch}

val connectionRole: ci:ConnectionInfo -> r:Role{r = ci.role}

val initConnection: r:Role -> b:bytes ->
	ci:ConnectionInfo
val nextConnection: ci:ConnectionInfo -> b1:bytes -> b2:bytes -> si:SessionInfo ->
	ci':ConnectionInfo

/// Cryptographic assumptions [how to make them toplevel?]

predicate type cryptopreds = 
  | Safe of epoch
  | Auth of epoch

assume !ki. Safe(ki) => Auth(ki)
assume !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => not Safe(ki)
assume !ki. IsNullCiphersuite(EpochSI(ki).cipher_suite) => not Auth(ki)


/// Application configuration options

type helloReqPolicy =
    | HRPIgnore
    | HRPFull
    | HRPResume

type protocolOptions = {
    minVer: ProtocolVersion;
    maxVer: ProtocolVersion;
    ciphersuites: cipherSuites;
    compressions: Compression list;

    (* Handshake specific options *)
    (* Client side *)
    honourHelloReq: helloReqPolicy;
    allowAnonCipherSuite: bool;
    (* Server side *)
    request_client_certificate: bool;
    check_client_version_in_pms_for_old_tls: bool;
    server_cert_file: string; (* FIXME: certificates should be found in a better way. To be fixed *)
    (* Common *)
    certificateValidationPolicy: cert list -> bool;
    safe_renegotiation: bool;

    (* Sessions database *)
    sessionDBFileName: string;
    sessionDBExpiry: TimeSpan
    }

val defaultProtocolOptions: protocolOptions

private val defaultCertificateValidationPolicy: cert list -> bool