module MAC

open Bytes
open TLSConstants
open TLSInfo

(* refined, agile, ideal interface for indexed MACs 
   resistant to existential forgery against chosen message attacks (INT-CMA). 

  This module depends on  

   - a datatype of MAC algorithms (TLSConstants.MAC_alg)
   - an abstract type of indexes (TLSInfo.epoch)
   - a function from indexes to MAC algorithms (macAlg_of_epoch) and its logical spec.
   - functions from MAC algorithms to their key-lengths and tag-lengths, and their logical specs.
   - an function from indexes to booleans that indicates the safe indexes (MAC_safe) and its logical spec;
     (this function is used only #if ideal)
   - an abstract predicate on indexes and message (Msg), 
     specifying the logical property authenticated by safe MACs. 
   
   and the following assumptions:
   
   - we generate (or coerce) at most one key per index.
   - if an index is safe, then its algorithm is computationally strong (INT-CMA).
     (concretely, we would get a probabilistic bound depending on the quantitative usage of each algorithm) 

   ask !ki. Auth(ki) => \/_{idealized a} CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = a

   Notes: - this interface deals with CMA, not the joint CTXT assumption (where we rely on PRF)  
          - this multiplexing similarly applies to any keyed functionality.
		  - concretely, we would get a bound depending on the quantitative usage of each strong algorithm 
		  - pragmatically, we may e.g. assume INT-CMA for both variants of SHA2, but not for MD5 or SHA.
		  - so far we do attempt to prove that the ad hoc constructions of SSL_3p0 are strong.  *)

(* CF TODO implement and typecheck the ideal functionality (preferably from non-agile ideal ones)
           maintaining  a log of authentic MACed messages & correcting verification errors.

   Our concrete core algorithms are implemented by HMAC, 
   after partial application of the algorithm name.
   (we keep using a single HMAC module just for convenience, with constants as their first "a" parameters) 

   Given a strong subset of these algorithms, 
   each of their ideal counterparts is coded & typed as in cma/mac2.fs7, 
   relying on some abstract key type HMAC.key_a
   wrt some HMAC.Msg_a(ki,t) abstract predicate defined below.

   Technically, to typecheck MAC against this collection of ideal interfaces, we define 
   
   private type (;ki:succEpoch) key = | MacKey_a of (;ki) HMAC.key_a { CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = a }
                                      | ConcreteKey of (;ki) keyrepr 
   private definition !ki,t. HMAC.Msg_a(ki,t) <=> 
   ( CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = a /\ (Auth(ki) => Msg(ki,t))

   and we unfold separate branches for each strong a in Mac, Verify, GEN, COERCE, LEAK 
   
   What to include? probably the ideal typing of a single exemplary secure algorithm, importing mac2.fs* *)

type text = bytes
type (;ki:succEpoch) keyrepr = k:bytes {Length(k) = MacSize(CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version)) }
type (;ki:succEpoch) tag     = m:bytes {Length(m) = MacSize(CipherSuiteMACAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version))}
private type (;ki:succEpoch) key = {k:(;ki) keyrepr}

predicate val Msg: epoch * text -> bool

val Mac:    ki:succEpoch -> k:(;ki) key -> t:text{Msg(ki,t)} -> m:(;ki) tag
val Verify: ki:succEpoch -> k:(;ki) key -> t:text -> m:(;ki) tag -> v:bool{ (v=true /\ Auth(ki)) => Msg(ki,t) }

val GEN:    ki:succEpoch -> (;ki) key
val LEAK:   ki:succEpoch {not(Auth(ki))} -> (;ki)key -> (;ki)keyrepr
val COERCE: ki:succEpoch {not(Auth(ki))} -> (;ki)keyrepr -> (;ki)key

type entry = (ki:epoch * t:text * (;ki)tag){Msg(ki,t)}
val log: entry list ref
val tmem: ki:epoch -> t:text -> entry list -> b:bool{
  (b = true) => Msg(ki,t)
}
