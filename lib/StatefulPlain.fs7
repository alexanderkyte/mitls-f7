module StatefulPlain
open TLSInfo
open TLSFragment
open DataStream
open Error
open Bytes
open Formats
open CipherSuites
open TLSKey

type (;ki:KeyInfo) data = (b:bytes){Length(b) = TLSFragment.ADLength(ki) - 8}

function ADSeqn: nat -> bytes -> bytes

type (;ki:KeyInfo)history =
	| Empty
	| History of h:(;ki)history * ad:data * r:range * (;ki,h,ad,r)fragment
and (;ki:KeyInfo,h:history,ad:data,r:range) fragment = {f: bytes}

function val History: KeyInfo -> nat -> history -> bool
// assume !ki. History(ki,0,Empty) // To get uniform style, this will be assumed by the function creating the initial state (GEN/COERCE)

val addFragment: ki:KeyInfo -> seqn:nat -> h:(;ki)history{History(ki,seqn,h)} -> ad:data -> r:range -> f:(;ki,h,ad,r) fragment ->
			     seqn':nat * h': (;ki)history{History(ki,seqn',h')} // History(ki,seqn',h') will be assumed by this function
// AP still has the feeling we don't really all these assumes in the code. We can define (assume) what is the right way of building a history.
// Still, we'll have to prove OOB that we only append one next fragment to any current history (by linearity)

val fragment: ki:KeyInfo -> h:(;ki)history -> ad:data -> r:range -> bytes -> (;ki,h,ad,r) fragment
val repr: ki:KeyInfo -> h:(;ki)history -> ad:data -> r:range -> (;ki,h,ad,r) fragment -> bytes

val TLSFragmentToFragment: ki:KeyInfo -> ct:ContentType -> h:(;ki)history -> rg:range -> (;ki,ct,h,rg) TLSFragment.fragment -> (;ki,h,TLSFragment.ADCT(ki,ct),r) fragment
val FragmentToTLSFragment: ki:KeyInfo -> ct:ContentType -> h:(;ki)history -> rg:range -> (;ki,h,TLSFragment.ADCT(ki,ct),rg) fragment -> (;ki,ct,h,rg) TLSFragment.fragment