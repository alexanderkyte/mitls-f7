module Range

open Bytes
open TLSInfo
open TLSConstants

type range = low:nat * high:nat { low <= high }
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   
function val Sum: range * range -> range
definition !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val rangeSum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}

predicate SubRange of range * range
definition !l0,l1,h0,h1. SubRange((l0,h0),(l1,h1)) <=> l1 <= l0 && h0 <= h1

function val RangeClass: epoch * range -> range
function val TargetLength: epoch * range -> nat
function val CipherRangeClass: epoch * nat -> range

definition !e,r. RangeClass(e,r) = CipherRangeClass(e,TargetLength(e,r))
theorem !e,r. SubRange(r,RangeClass(e,r))

function val IVSize: epoch -> nat
private definition !e.
	(IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) => IVSize(e) = 0 ) /\
	( (not IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) /\
		(EpochSI(e).protocol_version = SSL_3p0 \/ EpochSI(e).protocol_version = TLS_1p0) ) => IVSize(e)=0) /\
	( (not IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) /\
		(EpochSI(e).protocol_version = TLS_1p1 \/ EpochSI(e).protocol_version = TLS_1p2) ) =>
			IVSize(e)= BlockSize(CipherSuiteENCAlg(EpochSI(e).cipher_suite)) )

val ivLength: e:succEpoch -> l:nat{l=IVSize(e)}

// Padding computations
function val BlockAligned: epoch * nat -> nat
private assume !e,l. BlockAligned(e,l) >= 0 /\ BlockAligned(e,l) < BlockSize(CipherSuiteENCAlg(EpochSI(e).cipher_suite))
private val blockAlignPadding: e:succEpoch -> l:nat -> l':nat{l' = BlockAligned(e,l)}

private definition !e,l,h.
	TargetLength(e,(l,h)) =
		IVSize(e) + h + HashSize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)) +
		BlockAligned(e,h + HashSize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)))

val targetLength: e:succEpoch -> r:range -> 
  tlen:nat {tlen = TargetLength(e,r) /\ tlen <= max_TLSCipher_fragment_length}

val cipherRangeClass: e:succEpoch -> 
  tlen:nat{tlen <= max_TLSCipher_fragment_length} -> 
  r:range {r = CipherRangeClass(e,tlen)}

val rangeClass: e:succEpoch -> r0:range -> r1:range{r1 = RangeClass(e,r0)}
