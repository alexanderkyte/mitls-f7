module Handshake

open Data
open Record
open Sessions
open Error_handling
open Formats
open AppCommon

type clientState =
  | ServerHello
  | Certificate
  | ServerKeyExchange
  | CertReq
  | CCCS
  | CFinished
  | CIdle
type serverState =
  | ClientHello
  | Keying
  | ClientKEX
  | CertificateVerify
  | SCCS
  | SFinished
  | SIdle
type protoState =
  | Client of clientState
  | Server of serverState

type pre_hs_state =
  {hs_outgoing: Data.bytes;
   ccs_outgoing: (Data.bytes * Record.ccs_data) option;
   hs_outgoing_after_ccs: Data.bytes;
   hs_incoming: Data.bytes;
   hs_info: Sessions.SessionInfo;
   poptions: protocolOptions;
   pstate: protoState;} 

predicate type preds =
  | HandshakeState of pre_hs_state
  | TLSProposedMKey of Crypto.key * SessionInfo
  | TLSConfirmedMKey of Crypto.key * SessionInfo
  | TLSProposedSKey of Crypto.key * SessionInfo
  | TLSConfirmedSKey of Crypto.key * SessionInfo
  | CCSWrite of ccs_data
  | CCSRead of ccs_data
  | HSFinished of SessionInfo

type hs_state = (hs:pre_hs_state){HandshakeState(hs)}

type HSFragReply =
  | EmptyHSFrag
  | HSFrag of bytes
  | HSWriteSideFinished
  | HSFullyFinished_Write of s:SessionInfo{HSFinished(s)}
  | CCSFrag of bytes * ccs_data

val next_fragment: s:hs_state -> int ->
	(r:HSFragReply * s':hs_state){
		s'.hs_info = s.hs_info /\
		(r = EmptyHSFrag => s' = s) /\
		(!f. r = HSFrag(f) => (UpperProtoSend(s.hs_info,Handshake,f) /\ Pub(f))) /\
		(* TODO: Pub(f) might not be true for the Finished message, in this case a different return value is needed *)
		(* FIXME: The fragments returned after the CCS must be blessed for the next sessioninfo, not the current one!
		          This will also be true for the alert protocol... and input/output session infos at the record layer
		          might not be synchronized... *)
		(!f,ccs. r = CCSFrag(f,ccs) =>
		           (UpperProtoSend(s.hs_info,Change_cipher_spec,f) /\ Pub(f) /\
                            CCSWrite(ccs))
			   )}

type recv_reply =
  | HSAck
  | HSChangeVersion of role * Formats.ProtocolVersionType
  | HSReadSideFinished
  | HSFullyFinished_Read of s:SessionInfo {HSFinished(s)}

val makeHSPacket : HS_msg.handshakeType -> Data.bytes -> Data.bytes
val makeHelloRequestBytes : unit -> Data.bytes
val makeTimestamp : unit -> int
val makeCHello : protocolOptions -> Sessions.sessionID -> HS_msg.clientHello
val b_of_cslist : HS_ciphersuites.CipherSuite list -> Data.bytes -> Data.bytes
val bytes_of_cipherSuites : HS_ciphersuites.CipherSuite list -> Data.bytes
val b_of_complist : Formats.Compression list -> Data.bytes -> Data.bytes
val bytes_of_compressionMethods : Formats.Compression list -> Data.bytes
val makeCHelloBytes : protocolOptions -> Sessions.sessionID -> Data.bytes

val init_handshake: r:role -> protocolOptions -> (info:SessionInfo * s:hs_state){info = InitSessionInfo(r) /\ s.hs_info = info}

val resume_handshake: role -> SessionInfo -> protocolOptions -> hs_state

val start_rehandshake: hs_state -> protocolOptions -> hs_state

val start_rekey: hs_state -> protocolOptions -> hs_state

val start_hs_request: hs_state -> protocolOptions -> hs_state

val new_session_idle: hs_state -> i:SessionInfo -> s:hs_state{s.hs_info = i}

val parse_fragment :
  hs_state ->
    Data.bytes -> hs_state * (HS_msg.handshakeType * Data.bytes) option
val recv_fragment: hs_state -> Record.fragment ->
	(r:(recv_reply Error_handling.Result) * hs_state){
		(!rr. r = Correct(rr) => (!hs,r,pv. rr = HSChangeVersion(hs,r,pv) => pv <> UnknownPV))
	}
val recv_ccs: hs_state -> Record.fragment ->
	(r:(Record.ccs_data Error_handling.Result) * hs_state){
	(!ccs. r = Correct(ccs) => CCSRead(ccs))
	}


assume !ccs. CCSWrite(ccs) =>
                        (NonNullCipherSettings(ccs) /\ TLSProposedMKey(ccs.ccs_mkey,ccs.ccs_info) /\
                         (!sk,iv. ccs.ccs_ciphstate = BlockCipherState(sk,iv) => TLSProposedSKey(sk,ccs.ccs_info)))

assume !ccs. CCSRead(ccs) =>
                (NonNullCipherSettings(ccs) /\ TLSProposedMKey(ccs.ccs_mkey,OtherRole(ccs.ccs_info)) /\
		 (!sk,iv. ccs.ccs_ciphstate = BlockCipherState(sk,iv) => TLSProposedSKey(sk,OtherRole(ccs.ccs_info))) )

(* How can we obtain a confirmed key *)
assume !ccs. CCSWrite(ccs) /\ HSFinished(ccs.ccs_info) => TLSConfirmedMKey(ccs.ccs_mkey,ccs.ccs_info)
assume !ccs. CCSRead(ccs) /\ HSFinished(ccs.ccs_info) => TLSConfirmedMKey(ccs.ccs_mkey,OtherRole(ccs.ccs_info))
assume !ccs,sk,iv. CCSWrite(ccs) /\ HSFinished(ccs.ccs_info) /\ ccs.ccs_cipher_state = BlockCipherState(sk,iv) =>
                TLSConfirmedSKey(sk,ccs.ccs_info)
assume !ccs,sk,iv. CCSRead(ccs) /\ HSFinished(ccs.ccs_info) /\ ccs.ccs_cipher_state = BlockCipherState(sk,iv) =>
                TLSConfirmedSKey(sk,OtherRole(ccs.ccs_info))

(* We can use proposed and confirmed keys in the record layer *)
assume !mk,info. TLSProposedMKey(mk,info) => TLSMKey(mk,info)
(* assume !mk,info. TLSConfirmedMKey(mk,info) => TLSMKey(mk,info) *)

assume !sk,info. TLSProposedSKey(sk,info) => TLSSKey(sk,info)
(* assume !sk,info. TLSConfirmedSKey(sk,info) => TLSSKey(sk,info) *)

(* If a confirmed key is public, then the session is compromised *)
assume !mk,info. TLSConfirmedMKey(mk,info) /\ Compromised(info) => Crypto.Pub_k(mk)
theorem !mk,info. TLSConfirmedMKey(mk,info) /\ Crypto.Pub_k(mk) => Compromised(info)
assume !sk,info. TLSConfirmedSKey(sk,info) /\ Compromised(info) => Crypto.Pub_k(sk)
theorem !sk,info. TLSConfirmedSKey(sk,info) /\ Crypto.Pub_k(sk) => Compromised(info)
