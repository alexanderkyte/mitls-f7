module TLS

open Tcp
open Error
open Bytes
open AppConfig
open DataStream
open AppDataStream
open Dispatch
open TLSInfo

type index  = ConnectionInfo
type conn   = Dispatch.Connection
type params = protocolOptions

val null: i:index{NullKeyInfo(i.id_in) /\ NullKeyInfo(i.id_out)}

type (;c:conn) OutSameConnection = c':conn{ ConnectionInKeyInfo(c) =  ConnectionInKeyInfo(c')}
type (;c:conn)  InSameConnection = c':conn{ConnectionOutKeyInfo(c) = ConnectionOutKeyInfo(c')}
type (;c:conn)    SameConnection = c':conn{     ConnectionIndex(c) =      ConnectionIndex(c')}

function val Dual: ConnectionInfo -> ConnectionInfo
assume !ki. Dual(ki) = { id_in = ki.id_out; id_out = ki.id_in }

predicate val TXT: index -> bool

predicate val Fatal: (KeyInfo * bytes) -> bool
predicate val Close: (KeyInfo * bytes) -> bool
predicate val Write: (KeyInfo * bytes) -> bool
predicate val Read : (KeyInfo * bytes) -> bool

function val WrittenBytes: conn -> bytes
function val    ReadBytes: conn -> bytes

assume !id, s. WrittenBytes(Conn(id, s)) = s.appdata.app_outgoing
assume !id, s.    ReadBytes(Conn(id, s)) = s.appdata.app_incoming


(*
type (;c:conn, rg:range) delta
private type (;ki:KeyInfo, before: (;ki) stream,r:range) delta = {db:bytes}
*)

type (;c:conn) query

predicate val Split :
    (rg0:range           * newrg:range                * rg:range *
     c  :conn            * newc :conn                 *
     d0 :(;c, rg0) delta * newd :(;newc, newrg) delta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val  ReadExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val    NoExtend : (c:conn * c':conn) -> bool

function val WriteBytes : conn -> bytes
function val  ReadBytes : conn -> bytes

function val DeltaBytes : (c:conn * rg:range * (;c, rg) delta) -> bytes

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WriteBytes(c') = WriteBytes(c) @| DeltaBytes(c, rg, d) 
    /\  ReadBytes(c') =  ReadBytes(c)
    /\ Params(c') = Params(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
        ReadBytes(c') =  ReadBytes(c) @| DeltaBytes(c, rg, d)
    /\ WriteBytes(c') = WriteBytes(c)
    /\ Params(c') = Params(c)

definition !c, c'. NoExtend(c, c') <=>
        ReadBytes(c) =  ReadBytes(c')
    /\ WriteBytes(c) = WriteBytes(c')
    /\ Params(c) = Params(c')

type (;c:conn, rg:range, d:(;c, rg) delta) ioresult_o =
| Out_Error         of ErrorKind * ErrorCause
| Out_MustRead      of c':(;c) SameConnection { NoExtend(c, c') }
| Out_WriteComplete of c':(;c) SameConnection { WriteExtend(c, c', rg, d) }

| Out_WritePartial  of c':(;c) SameConnection * rg':range * d':(;c', rg') delta {
     ?d0, rg0.    WriteExtend(c, c', rg0, d0)
               /\ Split(rg0, rg', rg, c, c', d0, d', d)
  }

type (;c:conn) ioresult_i =
| In_Error of ErrorKind * ErrorCause

| In_Warning of c':(;c) SameConnection * alertDescription { NoExtend(c, c') }
| In_Fatal   of c':(;c) SameConnection { TXT(ConnectionIndex(c)) => Fatal(Dual(ConnectionIndex(c)), ReadBytes(c)) }

| In_CertQuery of c':conn * (;c') query

| In_HandshakeDone of c':conn {
    WrittenBytes(c') = [||] /\ ReadBytes(c') = [||]
  }

| In_Close of unit {
    TXT(ConnectionIndex(c)) => Close(Dual(ConnectionIndex(c)), ReadBytes(c))
  }

| In_Read of c':(;c) SameConnection * rg:range * d:(;c, rg) delta {
       ConnectionIndex(c) <> null
    /\ ReadExtend(c, c', rg, d)
    /\ TXT(ConnectionIndex(c)) => Write(Dual(ConnectionIndex(c)), ReadBytes(c'))
  }


// client-only; as is, must be followed by a read until Handshaken
val connect: NetworkStream -> p:params -> (c:conn { ConnectionIndex(c) = null /\ Params(c) = p }) Result
// server-only; as is, must be followed by a read until Handshaken
val accept:  NetworkStream -> p:params -> (c:conn { ConnectionIndex(c) = null /\ Params(c) = p }) Result

// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))
val write: c:conn -> rg:range -> d:(;c, rg) delta -> (;c, rg, d) ioresult_o
val read : c:conn -> (;c) ioresult_i

// ?non-blocking?
val rekey   : c:conn -> (c':conn { ConnectionIndex(c) = ConnectionIndex(c') /\ NoExtend(c, c') }) Result
val shutdown: c:conn -> (c':conn { ConnectionIndex(c) = ConnectionIndex(c') /\ NoExtend(c, c') }) Result
  
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:conn -> (;c) query -> (c':conn { ConnectionIndex(c) = ConnectionIndex(c') /\ NoExtend(c, c') }) Result
val refuse:    c:conn -> (;c) query -> unit
