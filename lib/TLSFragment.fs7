module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites
open DataStream

// Plain type for Dispatch
type (;ki:KeyInfo) history = {
  handshake: (;ki) Handshake.stream;
  alert: (;ki) Alert.stream;
  ccs: (;ki) Handshake.stream;
  appdata: (;ki) AppDataStream.stream;
  log: (;ki) fragmentSequence;
}
and (;ki:KeyInfo,ct:ContentType,h:(;ki) history,rg:range) fragment =
    | FHandshake of (;ki,h.handshake,rg)Handshake.fragment    {ct=Formats.Handshake}
    | FCCS       of (;ki,h.ccs,rg)Handshake.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of (;ki,h.alert,rg)Alert.fragment        {ct=Alert}
    | FAppData   of (;ki,h.appdata,rg)AppDataStream.fragment {ct=Application_data}
and (;ki:KeyInfo) fragmentSequence = (ct:ContentType * h:(;ki) history * rg:range * (;ki,ct,h,rg) fragment) list

predicate Fragment of KeyInfo * range * int * ContentType * bytes

val TLSFragmentRepr: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;ki,ct,h,rg)fragment -> bytes

val TLSFragment: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  bytes -> (;ki,ct,h,rg)fragment 

function val ADLength: ProtocolVersion -> int
assume !pv. (pv = SSL_3p0 /\ ADLength(pv) = 9) \/ (pv <> SSL_3p0 /\ ADLength(pv) = 11)

// Additional Data
type (;pv:ProtocolVersion) addData = (b:bytes){Length(b) = ADLength(pv)}

function val ADBytes: (ProtocolVersion * int * ContentType) -> bytes
assume !pv,seqn,ct.
	( pv = SSL_3p0 /\
	  ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| CTBytes(ct) ) \/
	( pv <> SSL_3p0 /\
          ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| (CTBytes(ct) @| VersionBytes(pv)))

ask !pv,seqn,ct. Length(ADBytes(pv,seqn,ct)) = ADLength(pv)

function val ADct: pv:ProtocolVersion * (;pv)addData -> ContentType
assume !pv,seqn,ct. ADct(pv,ADBytes(pv,seqn,ct)) = ct

function val ADseqn: pv:ProtocolVersion * (;pv)addData -> int
assume !pv,seqn,ct. ADseqn(pv,ADBytes(pv,seqn,ct)) = seqn

private val makeAD: pv:ProtocolVersion ->
	seqn:int -> ct:ContentType ->
	  ad: (;pv)addData{ad=ADBytes(pv,seqn,ct)}

private val parseAD: pv:ProtocolVersion -> 
          ad: (;pv)addData -> 
          (seqn:int * ct:ContentType){ad=ADBytes(pv,seqn,ct)}




