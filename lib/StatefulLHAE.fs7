module StatefulLHAE

open Error
open Bytes
open TLSInfo
open Range


(* MK

Dependencies:
 * StatefulPlain: for the definition of abstract types:
   * StatefulPlain.plain of plaintext and
   * StatefulPlain.history of the current log of plaintexts.


Usage: 
 * We assume that each encryption/decryption state is used at most once.
 * This condition is justified by inspecting uses of StatefulLHAE.encrypt 
   and StatefulLHAE.decrypt and verifying that the old encryption state is 
   discarded.


Assumptions:
 * None

Theorems:
 * (By Typing) The F# code for StatefulLHAE meets its F7 interface.
 * (Corollary) In safe epochs, the history, each plaintext, and LHAE keys are
   kept confidential. 
 * (Corollary) In safe epochs, the overall length of plaintext in
   the history is kept confidential (within a range).
 * (Corollary) In safe epochs, the sequence of plaintexts returned
   by decryption (at the receiver) is a prefix of the sequence of
   plaintexts passed to encryption (at the sender.)

*)

//CF 12/2: do we need pre/post on ciphertext lengths?

type rw =
	| ReaderState 
	| WriterState

//AP: We need the following invariant: StateID(e,LHAE.LHAEKey) = SeqNum(e,StatefulPlain.history)
private type (;ki:epoch,rw:rw) state = {
  key    : (;ki) LHAE.LHAEKey;         // possibly stateful
  history: (;ki) StatefulPlain.history // ghost state, except for the sequence number
}

function val History: e:epoch * rw:rw * (;e,rw)state -> 'a //(;e)StatefulPlain.history
private definition !e,rw,s. History(e,rw,s) = s.history

type (;ki:epoch) reader = r:(;ki,ReaderState) state
type (;ki:epoch) writer = w:(;ki,WriterState) state

val GEN:    ki:succEpoch{Safe(ki)}     -> (;ki)reader * (;ki)writer
val COERCE: ki:succEpoch{not Auth(ki)} -> rw:rw -> b:bytes{Length(b)=LHAE.LHAEKeySize(ki)} -> (;ki,rw)state
val LEAK:   ki:succEpoch{not Auth(ki)} -> rw:rw -> (;ki,rw)state -> b:bytes

val history: ki:epoch -> rw:rw -> s:(;ki,rw) state -> h:(;ki)StatefulPlain.history{h=History(ki,rw,s)}

// Ideally,
// the writer maintains a table (ki, h, ad, range, fragment, cipher) {...} [details?]
// when Safe(ki), the writer uses 0s instead of the actual fragment
// when Auth(ki), the reader decrypts by table lookup
// turning forgeries into errors; retrieving the "right" history index; returning the concrete decrypted range

//CF 21/4: ENCrypted is an event tracking written cipher fragments; not sure about details and contents ?!
//CF e.g.    * the decrypted rg is NOT authenticated
//CF         * the states are not necessarily synchronized; only the histories are when Auth(ki)

type cipher = LHAE.cipher

predicate ENCrypted of e:epoch * h:(;e)StatefulPlain.history * ad:(;e)StatefulPlain.adata * cipher
private definition !e,h,ad,c. 
  ENCrypted(e,h,ad,c) <=> LHAE.ENCrypted(e,LHAEPlain.MakeAD(e,h,ad),c)

val encrypt: ki:succEpoch -> 
  wr:(;ki) writer -> 
  ad:(;ki) StatefulPlain.adata ->
  rg:range ->
  f: (;ki,ad,History(ki,WriterState,wr),rg) StatefulPlain.plain ->
  (wr':(;ki) writer * c:cipher){
    History(ki,WriterState,wr') = 
      StatefulPlain.ExtendHistory(ki,ad,History(ki,WriterState,wr),rg,f)
/\    (Safe(ki) => ENCrypted(ki,History(ki,WriterState,wr),ad,c))} 

val decrypt: ki:succEpoch -> 
  rd:(;ki) reader -> 
  ad:(;ki) StatefulPlain.adata ->
  c:cipher ->
  res:((;ki) reader * rg:range * (;ki,ad,History(ki,ReaderState,rd),rg) StatefulPlain.plain) Result
  { !nrd,rg,f. res = Correct((nrd,rg,f)) => 
               (   History(ki,ReaderState,nrd) = 
                   StatefulPlain.ExtendHistory(ki,ad,History(ki,ReaderState,rd),rg,f) /\
                   rg = CipherRangeClass(ki,Length(c)) /\
 	         (Safe(ki) =>
				( (!nrd,rg,f. res = Correct((nrd,rg,f)) => ENCrypted(ki,History(ki,ReaderState,rd),ad,c)) // /\
				//  (!rg,p. ENCrypted(ki,rd,ad,rg,StatefulPlain.Payload(ki,ad,rg,p),c) => (?nrd,rg. res = Correct((nrd,rg,p))))
				)
			 ) ) }
			 

//CF 21/4: as stated, we need the resulting readers and writers to have explicitly-updated histories (irrespective of AUTH)
//CF 21/4: can we return an option instead? Otherwise we may have to specify which errors can be returned.
