module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open Stream 

type pre_app_state =
  {app_info: SessionInfo;
   app_incoming: Stream;
   app_outgoing: Stream}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes
  | AppDataOutStream of SessionInfo * Stream

type app_state = (aps:pre_app_state){ApplicationState(aps)}

function type funs =
  | InitAppState of SessionInfo

val init : i:SessionInfo -> a:app_state{a = InitAppState(i)}

val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state

val retrieve_data: app_state -> int -> (bytes * app_state) option

val next_fragment: as1:app_state -> int -> 
  (d:Record.fragment * as2:app_state{UpperProtoSend(as1.app_info,Application_data,d,as1.app_outgoing) /\ as2.app_info = as1.app_info}) option

(*
val recv_fragment :
  as1:app_state -> 
  f:Record.fragment{ApplicationFragmentSend(PeerSession(SessionOtherDir(as1.app_info)),f)} -> 
  (as2:app_state{as2.app_info = as1.app_info}) Error_handling.Result
*)

val recv_fragment: aps:app_state ->
          d:fragment{UpperProtoSend(OtherRole(aps.app_info), Application_data, d, aps.app_outgoing)} -> (* FIXME: doesn't make sense yet *)
	  app_state Result

(* Predicates definitions *)
assume !info. InitAppState(info) = {
		app_info = info;
		app_incoming = empty_stream;
		app_outgoing = empty_stream}

assume !aps. AppDataOutStream(aps.app_info,empty_stream)

assume !aps. ApplicationState(aps) <=> (AppDataOutStream(aps.app_info,aps.app_outgoing) /\ 
					(AppDataOutStream(OtherRole(aps.app_info),aps.app_incoming) \/ Compromised(OtherRole(aps.app_info))) ) (* FIXME: Troubles with stream handling *)

ask !i,aps. aps = InitAppState(i) => ApplicationState(aps)
 
(* When can we add data to the outgoing buffer *)
assume !aps,aps',d. ( ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) /\
		    aps'.app_info = aps.app_info /\
		    aps'.app_incoming = aps.app_incoming /\
		    StreamWrite(aps.app_outgoing,d,aps'.app_outgoing) ) =>
		    ApplicationState(aps')

(* When we can send data on the network from the outgoing stream *)
assume !aps,aps',d. ( ApplicationState(aps) /\
		      aps'.app_info = aps.app_info /\
		      aps'.app_incoming = aps.app_incoming /\
		      StreamRead(aps.app_outgoing,d,aps'.app_outgoing)
		    ) =>
		    ( ApplicationState(aps') /\ UpperProtoSend(aps.app_info, Application_data, d, aps.app_outgoing) )

