module Handshake

open Data
open Record
open Sessions
open Error_handling
open Formats
open AppCommon

type clientState =
  | ServerHello
  | Certificate
  | ServerKeyExchange
  | CertReq
  | CCCS
  | CFinished
  | CIdle
type serverState =
  | ClientHello
  | Keying
  | ClientKEX
  | CertificateVerify
  | SCCS
  | SFinished
  | SIdle
type protoState =
  | Client of clientState
  | Server of serverState

type pre_hs_state =
  {hs_outgoing: Data.bytes;
   ccs_outgoing: (Data.bytes * Record.ccs_data) option;
   hs_outgoing_after_ccs: Data.bytes;
   hs_incoming: Data.bytes;
   hs_info: Sessions.SessionInfo;
   poptions: protocolOptions;
   pstate: protoState;} 

predicate type preds =
  | HandshakeState of pre_hs_state
  | TLSProposedMKey of key * SessionInfo
  | TLSConfirmedMKey of key * SessionInfo
  | TLSProposedSKey of key * SessionInfo
  | TLSConfirmedSKey of key * SessionInfo
  | HSFinished of SessionInfo

type hs_state = (hs:pre_hs_state){HandshakeState(hs)}

type HSFragReply =
  | EmptyHSFrag
  | HSFrag of bytes
  | HSWriteSideFinished
  | HSFullyFinished_Write of s:SessionInfo{HSFinished(s)}
  | CCSFrag of bytes * ccs_data

val next_fragment: s:hs_state -> int ->
	(r:HSFragReply * s':hs_state){
		s'.hs_info = s.hs_info /\
		(r = EmptyHSFrag => s' = s) /\
		(!f. r = HSFrag(f) => (UpperProtoSend(s.hs_info,Handshake,f) /\ Pub(f))) /\
		(* TODO: Pub(f) might not be true for the Finished message, in this case a different return value is needed *)
		(!f,ccs. r = CCSFrag(f,ccs) =>
		           (UpperProtoSend(s.hs_info,Change_cipher_spec,f) /\ Pub(f) /\
			    NonNullCipherSettings(ccs) /\ TLSProposedMKey(ccs.ccs_mkey,ccs.ccs_info) /\
			    (!sk,iv. ccs.ccs_ciphstate = BlockCipherState(sk,iv) => TLSProposedSKey(sk,ccs.ccs_info))
			   ))}

type recv_reply =
  | HSAck
  | HSChangeVersion of role * Formats.ProtocolVersionType
  | HSReadSideFinished
  | HSFullyFinished_Read of s:SessionInfo {HSFinished(s)}

val makeHSPacket : HS_msg.handshakeType -> Data.bytes -> Data.bytes
val makeHelloRequestBytes : unit -> Data.bytes
val makeTimestamp : unit -> int
val makeCHello : protocolOptions -> Sessions.sessionID -> HS_msg.clientHello
val b_of_cslist : HS_ciphersuites.CipherSuite list -> Data.bytes -> Data.bytes
val bytes_of_cipherSuites : HS_ciphersuites.CipherSuite list -> Data.bytes
val b_of_complist : Formats.Compression list -> Data.bytes -> Data.bytes
val bytes_of_compressionMethods : Formats.Compression list -> Data.bytes
val makeCHelloBytes : protocolOptions -> Sessions.sessionID -> Data.bytes

val init_handshake: r:role -> protocolOptions -> (info:SessionInfo * s:hs_state){info = InitSessionInfo(r) /\ s.hs_info = info}

val new_session_idle: hs_state -> i:SessionInfo -> s:hs_state{s.hs_info = i}

val rehandshake : hs_state -> bool -> hs_state Error_handling.Result
val parse_fragment :
  hs_state ->
    Data.bytes -> hs_state * (HS_msg.handshakeType * Data.bytes) option
val recv_fragment: hs_state -> Record.fragment ->
	(r:(recv_reply Error_handling.Result) * hs_state){
		(!rr. r = Correct(rr) => (!hs,r,pv. rr = HSChangeVersion(hs,r,pv) => pv <> UnknownPV))
	}
val recv_ccs: hs_state -> Record.fragment ->
	(r:(Record.ccs_data Error_handling.Result) * hs_state){
	(!ccs. r = Correct(ccs) => (NonNullCipherSettings(ccs) /\ TLSProposedMKey(ccs.ccs_mkey,ccs.ccs_info) /\
			    (!sk,iv. ccs.ccs_ciphstate = BlockCipherState(sk,iv) => TLSProposedSKey(sk,ccs.ccs_info)) ))
	}


(* How can we obtain a confirmed key *)
assume !mk,info. TLSProposedMKey(mk,info) /\ HSFinished(info) => TLSConfirmedMKey(mk,info)
assume !sk,info. TLSProposedSKey(sk,info) /\ HSFinished(info) => TLSConfirmedSKey(sk,info)

(* We can use proposed and confirmed keys in the record layer *)
assume !mk,info. TLSProposedMKey(mk,info) => TLSMKey(mk,info)
assume !mk,info. TLSConfirmedMKey(mk,info) => TLSMkey(mk,info)

assume !sk,info. TLSProposedSKey(sk,info) => TLSSKey(sk,info)
assume !sk,info. TLSConfirmedSKey(sk,info) => TLSSkey(sk,info)

(* If a confirmed key is public, then the session is compromised *)
assume !mk,info. TLSConfirmedMKey(mk,info) /\ Pub_k(mk) => Compromised(info)
theorem !mk,info. TLSConfirmedMKey(mk,info) /\ Compromised(info) => Pub_k(mk)
assume !sk,info. TLSConfirmedSKey(sk,info) /\ Pub_k(sk) => Compromised(info)
theorem !sk,info. TLSConfirmedSKey(sk,info) /\ Compromised(info) => Pub_k(sk)
