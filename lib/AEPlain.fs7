module AEPlain

open Bytes
open TLSInfo
open CipherSuites
open DataStream
open Fragment
open Algorithms
open CipherSuites

predicate type uns = Unsafe of KeyInfo
private assume !ki. Unsafe(ki) <=> not (Safe(ki))

function val ADLength: KeyInfo * KeyInfo -> nat
function val IVSize: KeyInfo * KeyInfo -> nat
assume !ki. (ki.sinfo.protocol_version = SSL_3p0 /\ ADLength(ki,ki) = 9) \/
	(ki.sinfo.protocol_version <> SSL_3p0 /\ ADLength(ki,ki) = 11)

type (;ki:KeyInfo) data = (b:bytes){Length(b) = ADLength(ki,ki)}

private type (;ki:KeyInfo,r:range,ad:(;ki)data)AEPlain = {aep: bytes} // FIXME: we miss some predicate here.

val AEPlain: ki:KeyInfo{not Safe(ki)} -> r:range -> ad:(;ki)data -> b:bytes -> (;ki,r,ad)AEPlain
val AERepr:  ki:KeyInfo{not Safe(ki)} -> r:range -> ad:(;ki)data -> (;ki,r,ad)AEPlain -> b:bytes

val AEConstruct: ki:KeyInfo -> r:range -> ad:(;ki)data -> (;ki,r)fragment -> (;ki,r,ad)AEPlain
val AEContents:  ki:KeyInfo -> r:range -> ad:(;ki)data -> (;ki,r,ad)AEPlain -> (;ki,r)fragment


// Plaintext of MAC (addData + TLSFragment.fragment)
private type (;ki:KeyInfo) MACPlain = {macP:bytes}
private type (;ki:KeyInfo) tag = {macT:bytes}

val concat: ki:KeyInfo -> r:range -> 
  ad:(;ki)data ->
  f:(;ki,r,ad)AEPlain ->
  p:(;ki)MACPlain

val mac: ki:KeyInfo -> (;ki) MAC.key -> t:(;ki) MACPlain{MAC.Msg(ki,t.macP)} -> (;ki) tag
val verify: ki:KeyInfo -> (;ki) MAC.key -> text:(;ki) MACPlain -> tag:(;ki) tag ->
	v:bool{v = true /\ Auth(ki) => MAC.Msg(ki,text.macP)}


val padLength: ki:KeyInfo -> nat -> nat
function val RangeCipher: KeyInfo * range -> nat // not injective
val rangeCipher: ki:KeyInfo -> r:range -> tlen:nat{tlen = RangeCipher(ki,r)}
val cipherRange: ki:KeyInfo -> tlen:nat -> r:range{tlen = RangeCipher(ki,r)}


// AP and CF agree: AEPlain is indexed by (ki and) its public length, after encoding (and not by range).
// We define function from:
// - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
// - from tlen to public range of decoded authenticated fragment
// - (and the inverse functions)

function val PlainLength: ki:KeyInfo * tlen:nat -> plen:nat
private assume !ki. IVSize(ki,ki) = BlockSize(CipherSuiteENCAlg(ki.sinfo.cipher_suite))
private assume !ki,tlen.
	( ki.sinfo.protocol_version = SSL_3p0 \/ ki.sinfo.protocol_version = TLS_1p0
		=> PlainLength(ki,tlen) = tlen ) /\
	( ki.sinfo.protocol_version = TLS_1p1 \/ ki.sinfo.protocol_version = TLS_1p2
		=> PlainLength(ki,tlen) + IVSize(ki,ki) = tlen )

private type (;ki:KeyInfo,tlen:nat) plain = {p: (x:bytes){Length(x) = PlainLength(ki,tlen)}}
val plain: ki:KeyInfo{not Safe(ki)} -> tlen:nat -> b:bytes{Length(b) = PlainLength(ki,tlen)} -> (;ki,tlen) plain
val repr:  ki:KeyInfo{not Safe(ki)} -> tlen:nat -> (;ki,tlen) plain -> b:bytes{Length(b) = PlainLength(ki,tlen)}


function val MsgBytes: ki:KeyInfo * (;ki) data * bytes -> bytes
assume !ki,ad,x. MsgBytes(ki,ad,x) = (ad @| IntBytes(2,Length(x))) @| x 
assume !ki,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(ki,ad1,x1) = MsgBytes(ki,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

// Now defined in MAC
// predicate Msg of ki:KeyInfo * tlen:DataStream.range * (;ki,tlen)MACPlain.MACPlain

assume !ki,tlen,pl. MAC.Msg(ki,pl) <=>
  (Corrupt(ki) \/
     (?ad,x. Length(ad) = ADLength(ki,ki) /\
	  pl = MsgBytes(ki,ad,x)// /\ ??
	// TLSFragment.Fragment(ki,tlen,
	// 	       TLSFragment.ADseqn(ki.sinfo.protocol_version,ad),
	// 	       TLSFragment.ADct(ki.sinfo.protocol_version,ad),x)))
	))

ask !ki,t. Corrupt(ki) => MAC.Msg(ki,t)

val pad: l:int -> b:bytes{Length(b) = l}

val check_split: 
  b:bytes -> i:int -> 
  b1:bytes * b2:bytes { Length(b1) = i /\ b = b1 @| b2 }

// TODO: Say that the result of encode is "block-aligned" (more generally: compatible with the current enc algorithm)
val ivLength: ki:KeyInfo -> nat
val encode: ki:KeyInfo -> rg:range -> ad:(;ki) data -> (;ki,rg,ad) AEPlain -> (;ki) tag -> (tlen:nat * (;ki,tlen) plain){tlen=RangeCipher(ki,rg)}
val decode: ki:KeyInfo -> ad:(;ki) data -> tlen:nat -> (;ki,tlen) plain -> (rg:range * (;ki,rg,ad)AEPlain * (;ki)tag * bool){tlen=RangeCipher(ki,rg)}

val encodeNoPad: ki:KeyInfo -> rg:range -> ad:(;ki) data -> (;ki,rg,ad) AEPlain -> (;ki) tag -> (tlen:nat * (;ki,tlen) plain){tlen=RangeCipher(ki,rg)}
val decodeNoPad: ki:KeyInfo -> ad:(;ki) data -> tlen:nat -> (;ki,tlen) plain -> (rg:range * (;ki,rg,ad)AEPlain * (;ki)tag){tlen=RangeCipher(ki,rg)}
