module AppData

open Bytes
open Record
open Error
open TLSInfo
open TLSPlain
open Formats

type (;si:SessionInfo) pre_app_state = {
  app_in_lengths: lengths
  app_incoming: (;si) appdata (* unsolicited data *)
  app_out_lengths: lengths
  app_outgoing: (;si) appdata
}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes

type (;si:SessionInfo) app_state = (aps:(;si)pre_app_state){ApplicationState(aps)}

function type funs =
        | SetSessionInfo of app_state * SessionInfo

(* type app_state // abstract type at the implementation level *)

val init: si:SessionInfo -> r:Direction ->
	      a:(;si)app_state{a.app_info = i /\ StreamBytes(a.app_incoming) = empty_bstr /\ PreviouslyRead(a.app_outgoing) = empty_bstr}


val reset_incoming: si:SessionInfo -> a:(;si)app_state ->
			a':(;si)app_state{a'.app_info = a.app_info /\ a'.app_outgoing = a.app_outgoing /\ IsEmptyStream(a.app_incoming) /\ PreviouslyRead(a.app_incoming) = empty_bstr}

val send_data: si:SessionInfo -> aps:(;si)app_state -> d:bytes{AppDataNextChunk(aps.app_info,d)} ->
	(;si)app_state

val is_outgoing_empty: si:SessionInfo -> (;si)app_state -> bool

val retrieve_data: si:SessionInfo -> (;si)app_state -> (bytes * (;si)app_state)
val is_incoming_empty: si:SessionInfo -> (;si)app_state -> bool

//val reset_outgoing: a:app_state -> a':app_state{a'.app_info = a.app_info /\ a'.app_incoming = a.app_incoming /\ IsEmptyStream(a.app_outgoing) /\ PreviouslyRead(a.app_outgoing) = empty_bstr}
//val set_SessionInfo: a:app_state -> si:SessionInfo -> a':app_state{a' = SetSessionInfo(a,si)}

val next_fragment: ki:KeyInfo -> aps:(;ki.sinfo)app_state ->
  ((i:int * (;ki,i)fragment) * aps':(;ki.sinfo)app_state
                {UpperProtoSend(aps.app_info,Application_data,d) /\ aps'.app_info = aps.app_info /\ aps'.app_incoming = aps.app_incoming /\
                       PreviouslyRead(aps'.app_outgoing) = AppendBytes(PreviouslyRead(aps.app_outgoing),d)}) option

val recv_fragment: ki:KeyInfo -> aps:(;ki.sinfo)app_state -> i:int ->
          d:(;ki,i)fragment{(?rs. UpperProtoSend(OtherRole(aps.app_info),Application_data,d)) \/ Compromised(OtherRole(aps.app_info))} ->
	  (;ki.sinfo)app_state

(* Functions in the logic *)
assume !a,si. SetSessionInfo(a,si) = { app_info = si;
                                       app_incoming = a.app_incoming;
                                       app_outgoing = a.app_outgoing}

(* Application state definition *)
assume !aps. ApplicationState(aps) <=> (Stream(aps.app_incoming) /\ Stream(aps.app_outgoing) /\
					((?raps. ApplicationState(raps) /\
					         Established(raps.app_info,raps.app_outgoing,aps.app_info,aps.app_incoming)) \/
				      Compromised(OtherRole(aps.app_info))))

(* TODO: Application state uniqueness *)
assume !aps,aps'. aps.app_info = aps'.app_info /\ ApplicationState(aps) /\ ApplicationState(aps') =>
        ( StreamID(aps.app_outgoing) = StreamID(aps'.app_outgoing) /\ StreamID(aps.app_incoming) = StreamID(aps'.app_incoming) )

(* When can we add data to the outgoing buffer *)
assume !aps,d. ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)

(* When we can send data on the network from the outgoing stream *) 
(*
assume !aps,d. ApplicationState(aps) /\ StreamRead(aps.app_outgoing,d) => UpperProtoSend(aps.app_info,Application_data,d)

theorem !info,p,d. UpperProtoSend(info,p,d) =>
	(?aps. ApplicationState(aps) /\ info = aps.app_info /\ p = Application_data /\ StreamRead(aps.app_outgoing,d))

ask !aps,rs,d. ApplicationState(aps) /\ UpperProtoSend(OtherRole(aps.app_info),Application_data,d) =>
		((StreamRead(rs,d) /\ StreamID(rs) = StreamID(aps.app_incoming) ) \/ Compromised(OtherRole(aps.app_info)))
*)
