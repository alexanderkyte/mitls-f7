module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open Stream 
open AppCommon
open Bytearray

type pre_app_state =
  {app_info: SessionInfo;
   app_incoming: stream;
   app_outgoing: stream}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes

type app_state = (aps:pre_app_state){ApplicationState(aps)}

function type funs =
        | SetSessionInfo of app_state * SessionInfo

(* type app_state // abstract type at the implementation level *)

(* Application interface *)

(* Add data to be sent to the other party *)
val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state
(* Retrieve data that we received from the other party *)
val retrieve_data: app_state -> int -> (bytes * app_state)
val retrieve_data_available: app_state -> bool

(* Dispatcher interface *)
val init : i:SessionInfo -> a:app_state{a.app_info = i /\ StreamBytes(a.app_incoming) = empty_bstr /\ PreviouslyRead(a.app_outgoing) = empty_bstr}

val reset_incoming: a:app_state -> a':app_state{a'.app_info = a.app_info /\ a'.app_outgoing = a.app_outgoing /\ IsEmptyStream(a.app_incoming) /\ PreviouslyRead(a.app_incoming) = empty_bstr}
val reset_outgoing: a:app_state -> a':app_state{a'.app_info = a.app_info /\ a'.app_incoming = a.app_incoming /\ IsEmptyStream(a.app_outgoing) /\ PreviouslyRead(a.app_outgoing) = empty_bstr}
val set_SessionInfo: a:app_state -> si:SessionInfo -> a':app_state{a' = SetSessionInfo(a,si)}

val next_fragment: aps:app_state -> int -> 
  (d:Record.fragment * aps':app_state
                {UpperProtoSend(aps.app_info,Application_data,d) /\ aps'.app_info = aps.app_info /\ aps'.app_incoming = aps.app_incoming /\
                       PreviouslyRead(aps'.app_outgoing) = AppendBytes(PreviouslyRead(aps.app_outgoing),d)}) option

val recv_fragment: aps:app_state ->
          d:fragment{(?rs. UpperProtoSend(OtherRole(aps.app_info),Application_data,d)) \/ Compromised(OtherRole(aps.app_info))} ->
	  app_state

(* Functions in the logic *)
assume !a,si. SetSessionInfo(a,si) = { app_info = si;
                                       app_incoming = a.app_incoming;
                                       app_outgoing = a.app_outgoing}

(* Application state definition *)
assume !aps. ApplicationState(aps) <=> (Stream(aps.app_incoming) /\ Stream(aps.app_outgoing) /\
					((?raps. ApplicationState(raps) /\
					         Established(raps.app_info,raps.app_outgoing,aps.app_info,aps.app_incoming)) \/
				      Compromised(OtherRole(aps.app_info))))

(* TODO: Application state uniqueness *)
assume !aps,aps'. aps.app_info = aps'.app_info /\ ApplicationState(aps) /\ ApplicationState(aps') =>
        ( StreamID(aps.app_outgoing) = StreamID(aps'.app_outgoing) /\ StreamID(aps.app_incoming) = StreamID(aps'.app_incoming) )

(* When can we add data to the outgoing buffer *)
assume !aps,d. ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)

(* When we can send data on the network from the outgoing stream *) 
(*
assume !aps,d. ApplicationState(aps) /\ StreamRead(aps.app_outgoing,d) => UpperProtoSend(aps.app_info,Application_data,d)

theorem !info,p,d. UpperProtoSend(info,p,d) =>
	(?aps. ApplicationState(aps) /\ info = aps.app_info /\ p = Application_data /\ StreamRead(aps.app_outgoing,d))

ask !aps,rs,d. ApplicationState(aps) /\ UpperProtoSend(OtherRole(aps.app_info),Application_data,d) =>
		((StreamRead(rs,d) /\ StreamID(rs) = StreamID(aps.app_incoming) ) \/ Compromised(OtherRole(aps.app_info)))
*)
