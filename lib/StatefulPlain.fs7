module StatefulPlain
open TLSInfo
open TLSFragment
open DataStream
open Error
open Bytes
open Formats
open CipherSuites

type (;ki:KeyInfo) data = (b:bytes){Length(b) = TLSFragment.ADLength(ki) - 8}

type (;ki:KeyInfo)history =
	| Empty
	| ConsHistory of h:(;ki)history * ad:data * r:range * (;ki,r)sbytes

function val History: KeyInfo * nat * history -> bool
assume !ki. History(ki,0,Empty)

function val SeqN: history -> nat
assume SeqN(Empty) = 0
assume !ki,h,ad,r,x. SeqN(ConsHistory(h,ad,r,x)) = SeqN(h)+1

type (;ki:KeyInfo,h:history,ad:data,r:range)fragment =
	x:(;ki,r)sbytes {Safe(ki) => History(ki,SeqN(h)+1,ConsHistory(h,ad,r,x))}

//val addFragment: ki:KeyInfo -> seqn:nat -> h:(;ki)history{History(ki,seqn,h)} -> ad:data -> r:range -> f:(;ki,h,ad,r) fragment ->
//			     seqn':nat * h': (;ki)history{History(ki,seqn',h')} // History(ki,seqn',h') will be assumed by this function

val fragment: ki:KeyInfo{not Safe(ki)} -> h:(;ki)history -> ad:data -> r:range -> bytes -> (;ki,h,ad,r) fragment
val repr: ki:KeyInfo{not Safe(ki)} -> h:(;ki)history -> ad:data -> r:range -> (;ki,h,ad,r) fragment -> bytes

function val MakeAD:  nat * data -> bytes
assume !sn,ad. MakeAD(sn,ad) = IntBytes(8,sn) @| ad

val makeAD:  ki:KeyInfo -> sn:nat -> ad:(;ki)data ->
	b:bytes{b=MakeAD(sn,ad) /\ Length(b) = TLSFragment.ADLength(ki)}
val parseAD: ki:KeyInfo -> b:bytes{Length(b) = TLSFragment.ADLength(ki)} ->
	(sn:nat * ad:(;ki)data){b=MakeAD(sn,ad)}