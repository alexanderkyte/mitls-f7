module CRE

open Bytes
open TLSConstants
open TLSInfo
open DHGroup

val todo: string -> 'a { false }

// In this file RSA refers to any crypto materials used for the RSA KEX. 
//CF consider splitting the file into two

// representation of PMS as RSA plaintexts.
type rsarepr = (;48)lbytes
//CF we considered indexing it by cv & refining with  ?b. it = VersionBytes(cv) @| b  

private val prfMS: si:SessionInfo {not SafeHS_SI(si)} -> p:bytes -> (;si) PRF.masterSecret

//#begin-abstractionRSA
private type rsaseed = {seed:rsarepr} 

// We have two layers of abstraction:
// - rsaseed, treated abstractly almost everywhere in this module, 
//   we could use a separate agile PRF module & assumption
// - rsapms, treated abstractly outside this module, 
//   so that we can control their usage for the RSA-PMS assumption.

private type (;pk:RSAKey.pk, pv:ProtocolVersion) rsapms = 
   | IdealRSAPMS    of rsaseed // used only ideally & for abstract pms values 
   | ConcreteRSAPMS of rsarepr
// pattern matching is used only in this module for specifying ideal code
// so we also define ideal predicate & test for the module users:
predicate HonestRSAPMS of pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms
private definition !pk,pv,pms. 
  HonestRSAPMS(pk,pv,pms) <=> ?s. pms = IdealRSAPMS(s)

ask !pk,cv,s. not(HonestRSAPMS(pk,cv,ConcreteRSAPMS(s)))

val honestRSAPMS: pk:RSAKey.pk -> cv:ProtocolVersion -> pms: (;pk,cv) rsapms -> b:bool { b=true <=> HonestRSAPMS(pk,cv,pms) } 

// abstract postcondition of RSA encryption (event) 
//CF UNUSED. to be deleted.
predicate EncryptedRSAPMS of pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms * bytes

//CF we may get it as a runtime invariant, attached as a refinement of rsapms.
private theorem !pk,cv,pms. 
  HonestRSAPMS(pk,cv,pms) => SafeRSAPMS(pk,cv) //CF dubious:(/\ EncryptedRSAPMS(pk,pv,pms,epms)) 

//MK some dangerous attempts: 
//MK private definition !pk,pv,pms. SafeRSAPMS(pk,pv) <=> ?s. pms = IdealRSAPMS(s)
//MK private definition !pk,pv,pms,epms. SafeRSAPMS(pk,pv) /\ EncryptedRSAPMS(pk,pv,pms,epms) <=> HonestRSAPMS(pk,pv,pms)
//MK theorem !pk,pv,pms,epms. not HonestRSAPMS(pk,pv,pms) /\ EncryptedRSAPMS(pk,pv,pms,epms) <=> not SafeRSAPMS(pk,pv)

//MK TODO maybe dangerouse as well but at least makes typechecker happy ;)
//MK theorem !pk,pv,pms. (not HonestRSAPMS(pk,pv,pms)) => not SafeRSAPMS(pk,pv)
//MK theorem !pk,pv,pms. SafeRSAPMS(pk,pv) => HonestRSAPMS(pk,pv,pms)
//MK not clearly correct or useful...

val genRSA: pk:RSAKey.pk -> cv:ProtocolVersion -> pms:(;pk,cv)rsapms
{ HonestRSAKey(pk) => HonestRSAPMS(pk,cv,pms) } 

val coerceRSA: pk:RSAKey.pk -> cv:ProtocolVersion -> rsarepr -> (;pk,cv)rsapms
// unrestricted, but we don't get an HonestRSAPMS

val leakRSA: 
  pk:RSAKey.pk -> cv:ProtocolVersion -> 
  pms:(;pk,cv)rsapms {not HonestRSAPMS(pk,cv,pms)} -> rsarepr
// used for concrete RSA encryption 
//#end-abstractionRSA

private function val Fifth: 'a -> 'b
private definition !e1,e2,e3,e4,e5. Fifth((e1,e2,e3,e4,e5)) = e5

private type rsaentry = i:(pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms * csr:bytes * si:SessionInfo) * ms:(;Fifth(i)) PRF.masterSecret
private val rsalog: rsaentry list ref 

val rsaassoc0: si:SessionInfo -> 
              (si':SessionInfo * (;si') PRF.masterSecret) list -> 
			  ms:(;si) PRF.masterSecret option

val rsaassoc: i:(pk:RSAKey.pk * pv:ProtocolVersion * (;pk,pv)rsapms * csr:bytes * si:SessionInfo) -> 
              (i':(pk':RSAKey.pk * pv':ProtocolVersion * (;pk',pv')rsapms * csr':bytes * si':SessionInfo) * ms':(;Fifth(i')) PRF.masterSecret) list -> 
			  ms:(;Fifth(i)) PRF.masterSecret option

val prfSmoothRSA:
    si:SessionInfo ->
	pv:ProtocolVersion ->
    pms: (;Cert.RSAPKCert(si.serverID),pv) rsapms 
	// { DecryptedPMS(si.pmsdata,pms)  } 
	->
    (;si) PRF.masterSecret

//#begin-abstractionDH

type dhrepr = bytes

private type dhseed = {seed:dhrepr} // treated abstractly almost everywhere in this file
private type (;p:p, g:(;p) g, gx:(;p) elt, gy:(;p) elt) dhpms =   
   | IdealDHPMS    of dhseed 
   | ConcreteDHPMS of dhrepr

predicate HonestDHPMS of p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms

private definition !p,g,gx,gy,pms. HonestDHPMS(p,g,gx,gy,pms) <=> ?s. pms = IdealDHPMS(s)

val honestDHPMS: p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt -> pms: (;p,g,gx,gy) dhpms -> b:bool { b=true <=> HonestDHPMS(p,g,gx,gy,pms) } 

val sampleDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt ->  (;p,g,gx,gy) dhpms
val coerceDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt {not SafeDHPMS(p,g,gx,gy)}-> (;p)elt -> (;p,g,gx,gy) dhpms
//#end-abstractionDH

private function val Seventh: 'a -> 'b
private definition !e1,e2,e3,e4,e5,e6,e7. Seventh((e1,e2,e3,e4,e5,e6,e7)) = e7

private type dhentry = i:(p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms * bytes * si:SessionInfo) * ms:(;Seventh(i)) PRF.masterSecret
private val dhlog: dhentry list ref 

val dhassoc: i:(p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms * bytes * si:SessionInfo) -> 
             (i':(p':p * g':(;p') g * gx':(;p') elt * gy':(;p') elt * (;p',g',gx',gy') dhpms * bytes * SessionInfo) * (;Seventh(i')) PRF.masterSecret) list -> 
             (;Seventh(i)) PRF.masterSecret option

// AP: Don't we really want *any* link between si and (g,p,gx,gy)?
val prfSmoothDHE:
    si:SessionInfo ->
    p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms ->
    (;si) PRF.masterSecret
