module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open FIFO

type pre_app_state =
  {app_info: SessionInfo;
   app_outgone: Fifo;

   app_incoming: Fifo;
   app_outgoing: Fifo}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes
  | AppDataOutStream of SessionInfo * bytes

type app_state = (aps:pre_app_state){ApplicationState(aps) /\ aps.app_info.dir = OutDir}

function type funs =
  | InitAppState of SessionInfo

val init : i:SessionInfo{i.dir = OutDir} -> a:app_state{a = InitAppState(i)}

val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state

val retrieve_data: app_state -> int -> (bytes * app_state) option

val next_fragment: as1:app_state -> int -> 
  (d:Record.fragment * as2:app_state{UpperProtoSend(as1.app_info,Application_data,as1.app_outgone,d) /\ as2.app_info = as1.app_info}) option

(*
val recv_fragment :
  as1:app_state -> 
  f:Record.fragment{ApplicationFragmentSend(PeerSession(SessionOtherDir(as1.app_info)),f)} -> 
  (as2:app_state{as2.app_info = as1.app_info}) Error_handling.Result
*)

val recv_fragment: app_state -> fragment -> app_state Result

(* Predicates definitions *)
assume !info. InitAppState(info) = {
		app_info = info;
		app_outgone = empty_bstr;
		app_incoming = empty_bstr;
		app_outgoing = empty_bstr}

assume !aps. AppDataOutStream(aps.app_info,Concat(empty_bstr,empty_bstr))

assume !aps. ApplicationState(aps) <=> (AppDataOutStream(aps.app_info,Concat(aps.app_outgone,aps.app_outgoing)) (* /\ 
					(ApplicationSend(PeerSession(aps.app_info),aps.app_incoming) \/ Compromised(aps.app_info)) *) )
 
(* When can we add data to the outgoing buffer *)
assume !aps,d. (ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) ) =>
				AppDataOutStream(aps.app_info,Concat(aps.app_outgone,Concat(aps.app_outgoing,d)))

(* When we get the next fragment from the fifo, we can send it, provided we associate it with its history *)
assume !aps,aps',f,rem. (ApplicationState(aps) /\ IsConcat(aps.app_outgoing,f,rem) /\ FIFOSend(f)) =>
		(UpperProtoSend(aps.app_info,Application_data,aps.app_outgone,f) /\
		 ApplicationState(aps') /\ IsConcat(aps'.app_outgone,aps.app_outgone,f) /\ aps'.app_outgoing = rem )
