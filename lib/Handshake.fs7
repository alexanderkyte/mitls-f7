module Handshake

open Data
open Record
open Sessions
open Error_handling
open Formats
open AppCommon

type clientState =
  | ServerHello
  | Certificate
  | ServerKeyExchange
  | CertReq
  | CCCS
  | CFinished
  | CIdle
type serverState =
  | ClientHello
  | Keying
  | ClientKEX
  | CertificateVerify
  | SCCS
  | SFinished
  | SIdle
type protoState =
  | Client of clientState
  | Server of serverState

type pre_hs_state =
  {hs_outgoing: Data.bytes;
   ccs_outgoing: (Data.bytes * Record.ccs_data) option;
   hs_outgoing_after_ccs: Data.bytes;
   hs_incoming: Data.bytes;
   hs_info: Sessions.SessionInfo;
   poptions: protocolOptions;
   pstate: protoState;} 

predicate type preds =
  | HandshakeState of pre_hs_state
  | HSFinished of SessionInfo

type hs_state = (hs:pre_hs_state){HandshakeState(hs)}

type HSFragReply =
  | EmptyHSFrag
  | HSFrag of bytes
  | HSWriteSideFinished
  | HSFullyFinished_Write of s:SessionInfo{HSFinished(s)}
  | CCSFrag of bytes * ccs_data

val next_fragment: s:hs_state -> int ->
	(r:HSFragReply * s':hs_state){
		s'.hs_info = s.hs_info /\
		(r = EmptyHSFrag => s' = s) /\
		(!f. r = HSFrag(f) => (UpperProtoSend(s.hs_info,Handshake,f) /\ Pub(f))) /\
		(* TODO: Pub(f) might not be true for the Finished message, in this case a different return value is needed *)
		(* FIXME: The fragments returned after the CCS must be blessed for the next sessioninfo, not the current one!
		          This will also be true for the alert protocol... and input/output session infos at the record layer
		          might not be synchronized... *)
		(!f,ccs. r = CCSFrag(f,ccs) =>
		           (UpperProtoSend(s.hs_info,Change_cipher_spec,f) /\ Pub(f) /\
                            NonNullCipherSettings(ccs))
			   )}

type recv_reply =
  | HSAck
  | HSChangeVersion of role * Formats.ProtocolVersionType
  | HSReadSideFinished
  | HSFullyFinished_Read of s:SessionInfo {HSFinished(s)}

val makeHSPacket : HS_msg.handshakeType -> Data.bytes -> Data.bytes
val makeHelloRequestBytes : unit -> Data.bytes
val makeTimestamp : unit -> int
val makeCHello : protocolOptions -> Sessions.sessionID -> HS_msg.clientHello
val b_of_cslist : HS_ciphersuites.CipherSuite list -> Data.bytes -> Data.bytes
val bytes_of_cipherSuites : HS_ciphersuites.CipherSuite list -> Data.bytes
val b_of_complist : Formats.Compression list -> Data.bytes -> Data.bytes
val bytes_of_compressionMethods : Formats.Compression list -> Data.bytes
val makeCHelloBytes : protocolOptions -> Sessions.sessionID -> Data.bytes

val init_handshake: r:role -> protocolOptions -> (info:SessionInfo * s:hs_state){info = InitSessionInfo(r,None) /\ s.hs_info = info}

val resume_handshake: role -> SessionInfo -> protocolOptions -> hs_state

val start_rehandshake: hs_state -> protocolOptions -> hs_state

val start_rekey: hs_state -> protocolOptions -> hs_state

val start_hs_request: hs_state -> protocolOptions -> hs_state

val new_session_idle: hs_state -> i:SessionInfo -> s:hs_state{s.hs_info = i}

val parse_fragment :
  hs_state ->
    Data.bytes -> hs_state * (HS_msg.handshakeType * Data.bytes) option
val recv_fragment: hs_state -> Record.fragment ->
	(r:(recv_reply Error_handling.Result) * hs_state){
		(!rr. r = Correct(rr) => (!hs,r,pv. rr = HSChangeVersion(hs,r,pv) => pv <> UnknownPV))
	}
val recv_ccs: hs_state -> Record.fragment ->
	(r:(Record.ccs_data Error_handling.Result) * hs_state){
	(!ccs. r = Correct(ccs) => NonNullCipherSettings(ccs))
	}

(* A ccs such that NonNullCipherSettings(ccs) holds implies that there exist
   TLSMKey(mk,info) and TLSSKey(sk,info) (where mk,sk,info are somehow bound to ccs).
   This is enough for the keys to be used in the record layer, and for the dispatcher
   to be in its Finishing/Finished states.
   However, when the HS protocol emits the HSFinished(info) event, then it means we're in
   an opened session, so the dispatcher can go to the open state, and we can lift Pub_K
   to the compromised session *)
   
(* If a confirmed key is public, then the session is compromised *)
assume !mk,info. TLSMKey(mk,info) /\ HSFinished(info) /\ Compromised(info) => Crypto.Pub_k(mk)
theorem !mk,info. TLSMKey(mk,info) /\ HSFinished(info) /\ Crypto.Pub_k(mk) => Compromised(info)
assume !sk,info. TLSSKey(sk,info) /\ HSFinished(info) /\ Compromised(info) => Crypto.Pub_k(sk)
theorem !sk,info. TLSSKey(sk,info) /\ HSFinished(info) /\ Crypto.Pub_k(sk) => Compromised(info)

