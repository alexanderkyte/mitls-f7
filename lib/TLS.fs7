module TLS

open Error
open Bytes
open TLSInfo 
open DataStream (* application-specific module *) 
open AppDataStream
open Dispatch


//TODO: in SameConnection, enforce the chaining for all HS-specific data, in particular to chain successive handshakes.
//TODO: fix alertDescription, so that it only represents the second byte. 
//TODO: check that we are not too restrictive for the ongoing connection once we start negotiating.
//TODO: regroup the bits of the TLS library that are needed in the API.
//TODO: write the "toplevel" automata, from the user viewpoint; consider enforcement by typing, session-style.

type (;r:Role,c:config) nullCn = conn:Connection {
	   Config(conn) = c /\ Role(conn) = r
	/\ CipherSuites.IsNullCiphersuite(ConnectionSIOut(conn).cipher_suite)
	/\ CipherSuites.IsNullCiphersuite(ConnectionSIIn (conn).cipher_suite)
}

type (;c:Connection) nextCn = c':Connection {
	Config(c')  = Config(c) /\ Role(c') = Role(c) /\ CnId(c') = CnId(c)
}

type (;c:Connection) ioresult_i =
| ReadError of ioerror
  // We encountered an error while reading, so the connection dies. 
  // we return the fatal alert we may have sent, if any,
  // or None in case of an internal error.

| Close of Tcp.NetworkStream {
	Auth(CnId(c)) => EvClose(Peer(CnId(c),()), Bytes_i(c))
  }
  // We received an alert notifying the normal closure of the connection; 
  // we learn that we have read everything sent by our peer,
  // and we get back the underlying TCP connection. 

| Fatal of a:alertDescription {
	Auth(CnId(c)) => EvFatal(Peer(CnId(c),()), a, Bytes_i(c))
  }
  // We received an alert notifying the abnornal closure of the connection by our peer
  // We learn that we have read everything sent by our peer.
  
| Warning of c':(;c) nextCn * a:alertDescription {
	Extend(c,c') /\ Auth(CnId(c)) => EvWarning(Peer(CnId(c),()), a, Bytes_i(c))
  }
  // We received a warning (at this point in the input stream)

| CertQuery of c':(;c) nextCn * query {Extend(c, c')} 
  // We received the peer certificates for the next epoch, to be authorized before proceeding.

| Handshaken of c':Connection {
       Role(c') = Role(c)
	/\ Config(c') = Config(c)
	/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
	/\ Bytes_i(c') = [||]
	/\ EvClose(Peer(CnId(c),()), Bytes_i(c))
	/\ Handshake.Complete(CnId(c'),Config(c'))
	/\ (	(EvFalseStart(CnId(c')) =>
				   Bytes_o(c') = Bytes_o(c)
				/\ ConnectionEpochOut(c') = ConnectionEpochOut(c)))
		\/	(	   Bytes_o(c') = [||]
				/\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
	   )
	}
  // We completed a run of the Handshake, moving to the next epoch.
  // we learn that we have read everything sent by our peer in the closing epoch
  // LATER: with additional "Read" events, we could also learn that our peer has read everything we sent in the closing epoch
	
	//Cedric: ?? 
	//AP: /\ Close(CnId(c),Bytes_o(c)) /\  -- and same for Alert protocol, and hanshake.
	// We need to show agreement on the content of all protocols in previous and current connection to express the Alert attack (and therefore authentication)

| Read of c':(;c) nextCn * d:(;ConnectionEpochIn(c),CnStream_i(c)) msg_i {
	Extend_i(c,c',d) /\ (Auth(CnId(c)) => EvWrite(Peer(CnId(c),()), Bytes_i(c')))
  }
  // We received a data fragment, appended to the input stream)

| DontWrite of c':Connection {
	   Role(c') = Role(c)
	/\ Config(c') = Config(c)
	/\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
	/\ Bytes_i(c') = Bytes_i(c)
	/\ (	(EvFalseStart(CnId(c)) => (
				   Bytes_o(c') = Bytes_o(c)
				/\ ConnectionEpochOut(c') = ConnectionEpochOut(c)))
		\/  (      Bytes_o(c') = [||]
				/\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				/\ EvFalseStart(CnId(c'))))
    }
  // AP: TXT(ConnectionInfo) is not precise enough here:
  // in/out directions are not the same, and we want to only refer to the incoming direction
  // We must wait till the next epoch before writing application data again.  
  // Without false start, we have the global invariant that Pending(c) => Bytes_o(c) = [||]
    
type (;c:Connection,d:(;ConnectionEpochOut(c),CnStream_o(c)) msg_o) ioresult_o =
| WriteError of ioerror
  // We encountered an error while writing; 
  // we return the fatal alert we may have sent, if any,
  // or None in case of an internal error.

| WriteComplete of c':(;c) nextCn {Extend_o(c,c',d)}
  // We wrote the message in full. appended to the output stream

| WritePartial  of c':(;c) nextCn * d':(;ConnectionEpochOut(c'),CnStream_o(c')) msg_o {
	?d0. Extend_o(c,c',d0) /\ Split_o(c, d, d0, c', d')
  }
  // We wrote a fragment of the message, appended to the output stream, and return the rest

| MustRead of c':Connection {
		Role(c') = Role(c) 
     /\ Config(c') = Config(c)
	 /\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
     /\ Bytes_i(c') = Bytes_i(c)
	 /\ (	(EvFalseStart(CnId(c)) => (
				   Bytes_o(c') = Bytes_o(c)
				/\ ConnectionEpochOut(c') = ConnectionEpochOut(c)))
		\/	(	   Bytes_o(c') = [||]
				/\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				/\ EvFalseStart(CnId(c'))))
	}

(* Event-driven interface *)

val read: c:Connection -> (;c) ioresult_i
// TODO: document the events possibly recorded by calls to read

val write: c:Connection -> d:(;ConnectionEpochOut(c),CnStream_o(c)) msg_o -> (;c,d) ioresult_o
// On the write side, the following events may be generated:
// - Write(ki,Bytes_o(c')) 
// - Close(ki,Bytes_o(c))
// WriteError reports a local error
// WriteComplete reports write completion
// WritePartial reports partial write completion, and returns the rest
// MustRead signals that the connection cannot be used anymore for writing until a new handshake completes. 
// (it may be a bit too restrictive)

val shutdown: c:Connection -> (c':(;c) nextCn {Extend(c,c')})
//was: (c':(;c) nextCn {Extend(c,c')}) Result
// [shutdown] will internally generate a Close(ki, Bytes_o(c)); releases the TCP socket after shutdown
// AP: I don't agree with current shutdown. With the current interface we cannot have a one-way shutdown.
// Not even if shutdown just sets some flag, and then we have to read. I propose two different
// specialized functions for each behavior:
// - full_shutdown, which returns immediately, and then the user must read until she gets a Close event
// - half_shutdown, where we internally send (write) our close notify, and then we drop the connection.
// Cedric: is it a live comment? do we really need both? 

val connect : Tcp.NetworkStream -> c:config -> (;Client,c) nullCn
val resume  : Tcp.NetworkStream -> sid:sessionID ->  c:config -> (;Client,c) nullCn
// even if the server declines, we authenticate the client's intent to resume from this sid.
// AP: Agreed, but there's no refinement keeping track of the desired sid.

val rekey: c:Connection {Role(c) = Client} -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false  /\ Config(c') = Config(c))
			\/ (b = true   /\ Config(c') = conf    ))
	}

val rehandshake: c:Connection {Role(c) = Client} -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}

val request: c:Connection {Role(c) = Server} -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}

val accept: Tcp.TcpListener -> c:config -> (;Server,c) nullCn
val accept_connected: Tcp.NetworkStream -> c:config -> (;Server,c) nullCn

// we echo the query so that we have an explicit user decision to blame.
val authorize : c:Connection -> q:query -> (c': (;c) nextCn {Extend(c,c') /\ Handshake.Authorize(Config(c),q)})
val refuse    : c:Connection -> q:query -> unit
// AP: we will have to internally send a fatal alert,
// and this might fail. We might want to give some feedback to the user. Same as half_shutdown

val getSessionInfo: k:epoch -> s:SessionInfo{s = EpochSI(k)}

val getEpochIn : c:Connection -> k:epoch{k = ConnectionEpochIn (c)}
val getEpochOut: c:Connection -> k:epoch{k = ConnectionEpochOut(c)}

val getInStream : c:Connection -> s:(;ConnectionEpochIn (c)) stream{s = CnStream_i(c)}
val getOutStream: c:Connection -> s:(;ConnectionEpochOut(c)) stream{s = CnStream_o(c)}

(* For each call through this API, say connect(x,p) returning r,
   we may use homonymous events, say Connect(x,p) & Connected(x,p,r), 
   or something more ad hoc, like Writing, generated internally between Write & Written
   (s/Write/Writing/ later) 

   Missing: 

   predicate val Nego(cp,sp,ki) 
   // ki (or some other part of ci?) is an outcome of negotiating 
   // with initial parameters cp and sp; we will write its logical def.
   // it would be great if ki was unique, and non-existent if cp, sp are not compatible. 

   We miss some "Finished" event, 
   generated by the Handshake for each party, as it sends the CCS, carried by the Finished message
   To generate this event, we have a precise precondition that depends on the ciphersuite etc
   (from Handshake), to support fast start
   
   The other end logically receives that event after verifying the other guy's Finished message
   We reveal that event in the TLS interface, as a consequence of read returning Handshake.
   We may reveal that event early, using another ioresult_i, e.g. to enable "fast start".

   Example: as the client receives notification of a complete handshake, we have a thm:
   
   !c,c'. Read(c,Handshake(c')) => 
          ?sp.   Nego(cp(c),sp,ki(c'))
		      /\ Next(c,c') /\ Epoch(c') = Epoch(c)+1  
		      /\ ?c''. (Authorized(c'',serverCerts(c')) /\ Prior(c'',c))
			  /\ ( StrongHandshakeCipherSuite(ki(c')) /\ Honest(serverCerts(ki(c'))) 
			       => ServerFinished(sp,ki)

   Problem: intuitively, events tracking calls & returns are threaded by their connections,
   but logically that information is missing. To this end, we may explicitly thread connections,
   using 
   
   Next(c,c') <=> UID(c') = UID(c) /\ Seqn(c') = Seqn(c) + 1
   Prior(c,c') <=> UID(c') = UID(c) /\ Epoch(c') = Epoch(c) /\ Seqn(c) < Seqn(c')
     
   *)
