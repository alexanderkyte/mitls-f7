module DH

open Bytes
open DHGroup
open CoreKeys

//#begin-abstraction
private type (;dhp:dhparams, gx:(;dhp)elt) secret = Key of bytes 
//#end-abstraction

// We maintain 2 logs:
// - a log of honest gx and gy values
// - a log for looking up honest pms values using gx and gy values

// Any parameters returned by the Core modules are taken from the trusted DHDB,
// which only contains good parameters.

// 1: log of honest gx and gy values
type honest_entry = (dhp:dhparams * (;dhp) elt){PP(dhp)}
private val honest_log: (honest_entry list) ref

// marks "Honest" exponentials generated using genKey (or serverGen)
predicate type predHE = HonestExponential of dhp:dhparams * gx:(;dhp) elt
private val honest: dhp:dhparams -> e:(;dhp) elt -> b:bool{b = true <=> HonestExponential(dhp,e)}

definition !dhp,gx,gy. PMS.SafeDH(dhp,gx,gy) <=> HonestExponential(dhp,gx) /\ HonestExponential(dhp,gy) /\ PP(dhp)
//SZ Check if we can remove these queries; unless we want to keep them as documentation or sanity checks
ask !dhp,gx,gy. not HonestExponential(dhp,gx) => not PMS.SafeDH(dhp,gx,gy)
ask !dhp,gx,gy. not HonestExponential(dhp,gy) => not PMS.SafeDH(dhp,gx,gy) 
ask !dhp,gx,gy. not PP(dhp) => not PMS.SafeDH(dhp,gx,gy) 
val safeDH: dhp:dhparams -> gx:(;dhp)elt -> gy:(;dhp)elt -> b:bool { b=true <=> PMS.SafeDH(dhp,gx,gy) }

// 2: log for looking up honest pms values using gx and gy values
type entry = dhp:dhparams * gx:(;dhp) elt * gy:(;dhp) elt * pms:(;dhp, gx, gy) PMS.dhpms{PMS.HonestDHPMS(dhp,gx,gy,pms)}
private val log: entry list ref 
private val assoc: dhp:dhparams -> gx:(;dhp)elt -> gy:(;dhp)elt -> entry list -> pmsoption:(;dhp, gx, gy) PMS.dhpms option{!pms. pmsoption=Some(pms) => PMS.HonestDHPMS(dhp,gx,gy,pms)}

val leak  : dhp:dhparams -> gx:(;dhp)elt -> x:(;dhp,gx)secret{not HonestExponential(dhp,gx)} -> bytes
val coerce: dhp:dhparams -> gx:(;dhp)elt{not HonestExponential(dhp,gx)} -> b:bytes -> x:(;dhp,gx)secret

val genKey: dhp:dhparams -> gx:(;dhp)elt * (;dhp,gx) secret{HonestExponential(dhp,gx)}

    
val serverGen: string -> DHDB.dhdb -> nat ->
	(DHDB.dhdb * dhp:dhparams * gs:(;dhp) elt * (;dhp,gs) secret
		{PP(dhp) /\ HonestExponential(dhp,gs)})

val clientGenExp: dhp:dhparams{PP(dhp)} -> gs:(;dhp) elt 
				      -> (gc:(;dhp) elt * res:(;dhp,gs,gc) PMS.dhpms)
					     {HonestExponential(dhp,gc) /\
							(HonestExponential(dhp,gs) => PMS.HonestDHPMS(dhp,gs,gc,res))}

val serverExp: dhp:dhparams{PP(dhp)} -> gs:(;dhp) elt{HonestExponential(dhp,gs)} -> gc:(;dhp) elt -> s:(;dhp,gs) secret 
				   -> res:(;dhp,gs,gc) PMS.dhpms{HonestExponential(dhp,gc) => PMS.HonestDHPMS(dhp,gs,gc,res)}
