module Alert

(* We do not support sending warnings, as there is no good reason to do so *)

open Bytes
open Error
open Formats
open TLSInfo
//open TLSPlain

type alertLevel =
  | AL_warning
  | AL_fatal
  | AL_unknown_level of int
type alertDescription =
  | AD_close_notify
  | AD_unexpected_message
  | AD_bad_record_mac
  | AD_decryption_failed
  | AD_record_overflow
  | AD_decompression_failure
  | AD_handshake_failure
  | AD_no_certificate
  | AD_bad_certificate
  | AD_unsupported_certificate
  | AD_certificate_revoked
  | AD_certificate_expired
  | AD_certificate_unknown
  | AD_illegal_parameter
  | AD_unknown_ca
  | AD_access_denied
  | AD_decode_error
  | AD_decrypt_error
  | AD_export_restriction
  | AD_protocol_version
  | AD_insufficient_security
  | AD_internal_error
  | AD_user_cancelled
  | AD_no_renegotiation
  | AD_unknown_description of int
type alert =
  {level: alertLevel;
   description: alertDescription;}
type pre_al_state =
  {al_info: SessionInfo;
   al_incoming: bytes;
   al_outgoing: bytes;}

predicate type preds =
    | AlertState of pre_al_state

type state = (als:pre_al_state){AlertState(als)}

val init: i:SessionInfo -> s:state{s.al_info = i}

type ALFragReply =
    | EmptyALFrag
    | ALFrag of bytes
    | LastALFrag of bytes

val next_fragment: als:state -> int -> (r:ALFragReply * als':state)
  {   (als'.al_info = als.al_info) 
  /\  (r = EmptyALFrag => als' = als) 
//  /\  (!f. r = ALFrag(f)     => (UpperProtoSend(als.al_info,Alert,f) /\ Pub(f))
//  /\  (!f. r = LastALFrag(f) => (UpperProtoSend(als.al_info,Alert,f) /\ Pub(f)) 
  }

type alert_reply =
  | ALAck of state
  | ALClose of state
  | ALClose_notify of state
val intpair_of_alertDesc: alertDescription -> int * int
val level_of_int: int -> alertLevel
val desc_of_int: int -> alertDescription
val alert_of_intpair: int * int -> alert
val alert_of_bytes: bytes -> alert
val bytes_of_alertDesc: alertDescription -> bytes
val send_alert: state -> alertDescription -> state Result
val handle_alert: state -> alert -> alert_reply Result
//CF temp: val recv_fragment:  state -> Record.fragment -> alert_reply Result

