module AppData

open Error
open TLSInfo
open Formats
open AppDataPlain

// type (;si:SessionInfo) appdata =
//   | SomeAppData of (;si) bytes
//   | NoneAppData // not indexed! an empty buffer is safe in all sessions!
// // so we can make the transition from one session to the other, when the buffer is empty

type (;ci:ConnectionInfo) pre_app_state = {
  app_in_lengths:  (;ci.id_in)  lengths;
  app_incoming:    (;ci.id_in)  appdata; (* unsolicited data *)
  app_out_lengths: (;ci.id_out) lengths;
  app_outgoing:    (;ci.id_out) appdata;
}


//predicate ApplicationState of pre_app_state

type (;ci:ConnectionInfo) app_state = (aps:(;ci)pre_app_state) //{ApplicationState(aps)}

val init: ci:ConnectionInfo -> (;ci)app_state

val reset_incoming: ci:ConnectionInfo -> (;ci)app_state -> (;ci)app_state

val send_data: ci:ConnectionInfo -> (;ci)app_state -> (;ci.id_out)lengths -> (;ci.id_out)appdata ->
		(;ci)app_state

//val is_outgoing_empty: ci:ConnectionInfo -> (;ci)app_state -> bool

val retrieve_data: ci:ConnectionInfo -> (;ci)app_state -> ((;ci.id_in)appdata * (;ci)app_state)

val is_incoming_empty: ci:ConnectionInfo -> (;ci)app_state -> bool

val next_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)app_state ->
	((tlen:int * (;ci.id_out,tlen,seqn)fragment) * (;ci)app_state) option

val recv_fragment: ci:ConnectionInfo -> seqn:int -> (;ci)app_state -> tlen:int -> (;ci.id_in,tlen,seqn)fragment ->
	(;ci)app_state

val reIndex: oldID:ConnectionInfo -> newID:ConnectionInfo{CompatibleIndexes(oldID,newID)} ->
	(;oldID)app_state -> (;newID)app_state

// /// OLD, legacy stuff
// (* type app_state // abstract type at the implementation level *)
// 
// val init: si:SessionInfo -> r:Direction ->
// 	      a:(;si)app_state{a.app_info = i /\ StreamBytes(a.app_incoming) = empty_bstr /\ PreviouslyRead(a.app_outgoing) = empty_bstr}
// 
// 
// val reset_incoming: si:SessionInfo -> a:(;si)app_state ->
// 			a':(;si)app_state{a'.app_info = a.app_info /\ a'.app_outgoing = a.app_outgoing /\ IsEmptyStream(a.app_incoming) /\ PreviouslyRead(a.app_incoming) = empty_bstr}
// 
// val send_data: si:SessionInfo -> aps:(;si)app_state -> d:bytes{AppDataNextChunk(aps.app_info,d)} ->
// 	(;si)app_state
// 
// val is_outgoing_empty: si:SessionInfo -> (;si)app_state -> bool
// 
// val retrieve_data: si:SessionInfo -> (;si)app_state -> (bytes * (;si)app_state)
// val is_incoming_empty: si:SessionInfo -> (;si)app_state -> bool
// 
// //val reset_outgoing: a:app_state -> a':app_state{a'.app_info = a.app_info /\ a'.app_incoming = a.app_incoming /\ IsEmptyStream(a.app_outgoing) /\ PreviouslyRead(a.app_outgoing) = empty_bstr}
// //val set_SessionInfo: a:app_state -> si:SessionInfo -> a':app_state{a' = SetSessionInfo(a,si)}
// 
// val next_fragment: ki:KeyInfo -> aps:(;ki.sinfo)app_state ->
//   ((i:int * (;ki,i)fragment) * aps':(;ki.sinfo)app_state
//                 {UpperProtoSend(aps.app_info,Application_data,d) /\ aps'.app_info = aps.app_info /\ aps'.app_incoming = aps.app_incoming /\
//                        PreviouslyRead(aps'.app_outgoing) = AppendBytes(PreviouslyRead(aps.app_outgoing),d)}) option
// 
// val recv_fragment: ki:KeyInfo -> aps:(;ki.sinfo)app_state -> i:int ->
//           d:(;ki,i)fragment{(?rs. UpperProtoSend(OtherRole(aps.app_info),Application_data,d)) \/ Compromised(OtherRole(aps.app_info))} ->
// 	  (;ki.sinfo)app_state
// 
// (* Functions in the logic *)
// assume !a,si. SetSessionInfo(a,si) = { app_info = si;
//                                        app_incoming = a.app_incoming;
//                                        app_outgoing = a.app_outgoing}
// 
// (* Application state definition *)
// assume !aps. ApplicationState(aps) <=> (Stream(aps.app_incoming) /\ Stream(aps.app_outgoing) /\
// 					((?raps. ApplicationState(raps) /\
// 					         Established(raps.app_info,raps.app_outgoing,aps.app_info,aps.app_incoming)) \/
// 				      Compromised(OtherRole(aps.app_info))))
// 
// (* TODO: Application state uniqueness *)
// assume !aps,aps'. aps.app_info = aps'.app_info /\ ApplicationState(aps) /\ ApplicationState(aps') =>
//         ( StreamID(aps.app_outgoing) = StreamID(aps'.app_outgoing) /\ StreamID(aps.app_incoming) = StreamID(aps'.app_incoming) )
// 
// (* When can we add data to the outgoing buffer *)
// assume !aps,d. ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)
// 
// (* When we can send data on the network from the outgoing stream *) 
// (*
// assume !aps,d. ApplicationState(aps) /\ StreamRead(aps.app_outgoing,d) => UpperProtoSend(aps.app_info,Application_data,d)
// 
// theorem !info,p,d. UpperProtoSend(info,p,d) =>
// 	(?aps. ApplicationState(aps) /\ info = aps.app_info /\ p = Application_data /\ StreamRead(aps.app_outgoing,d))
// 
// ask !aps,rs,d. ApplicationState(aps) /\ UpperProtoSend(OtherRole(aps.app_info),Application_data,d) =>
// 		((StreamRead(rs,d) /\ StreamID(rs) = StreamID(aps.app_incoming) ) \/ Compromised(OtherRole(aps.app_info)))
// *)