module Dispatch

open Bytes
open Error
open DataStream
open TLSInfo
open TLSConstants

type predispatchState =
  | Init 
  | FirstHandshake of ProtocolVersion             (* set by the ServerHello *) 
  | Finishing
  | Finished (* Only for Writing side, used to avoid sending data on a partially completed handshake *)
  | Open
  | Closing of string (* To handle un-graceful closures *)
  | Closed

type dispatchState = d:predispatchState{?pv,s.
	d = Init \/ d = FirstHandshake(pv) \/ d = Finishing \/ d = Finished \/
	d = Open \/ d = Closing(s) \/ d = Closed}

type (;ki:epoch) dState = {
    disp: dispatchState;
    conn: (;ki)Record.ConnectionState;
    }

type (;id:ConnectionInfo) preGlobalState = {
  (* abstract protocol states for HS/CCS, AL, and AD *)
  handshake: (;id) Handshake.hs_state;
  alert    : (;id) Alert.state;
  appdata  : (;id) AppData.app_state;    

  (* connection state for reading and writing *)
  read  : (;id.id_in)  dState;
  write : (;id.id_out) dState;
  (* The actual socket *)
  ns: Tcp.NetworkStream;
  }


predicate GState of ci:ConnectionInfo * (;ci)preGlobalState
type (;id:ConnectionInfo) globalState = gs:(;id) preGlobalState{GState(id,gs)}

definition !ci,gs. GState(ci,gs)  <=>
  ( (Auth(ci.id_out) =>
		(
		AppData.AppOutStream(ci,gs.appdata) = TLSFragment.HistoryStream(ci.id_out,TLSConstants.Application_data,Record.History(ci.id_out,gs.write.conn)) /\
		Handshake.HSOutStream(ci,gs.handshake) = TLSFragment.HistoryStream(ci.id_out,TLSConstants.Handshake,Record.History(ci.id_out,gs.write.conn)) /\
		Handshake.CCSOutStream(ci,gs.handshake) = TLSFragment.HistoryStream(ci.id_out,TLSConstants.Change_cipher_spec,Record.History(ci.id_out,gs.write.conn)) /\
		Alert.AlOutStream(ci,gs.alert) = TLSFragment.HistoryStream(ci.id_out,TLSConstants.Alert,Record.History(ci.id_out,gs.write.conn))
		)
	) /\
    (Auth(ci.id_in)  =>
		(
		AppData.AppInStream(ci,gs.appdata)  = TLSFragment.HistoryStream(ci.id_in, TLSConstants.Application_data,Record.History(ci.id_in, gs.read.conn)) /\
		Handshake.HSInStream(ci,gs.handshake) = TLSFragment.HistoryStream(ci.id_in,TLSConstants.Handshake,Record.History(ci.id_in,gs.read.conn)) /\
		Handshake.CCSInStream(ci,gs.handshake) = TLSFragment.HistoryStream(ci.id_in,TLSConstants.Change_cipher_spec,Record.History(ci.id_in,gs.read.conn)) /\
		Alert.AlInStream(ci,gs.alert) = TLSFragment.HistoryStream(ci.id_in,TLSConstants.Alert,Record.History(ci.id_in,gs.read.conn))
		)
	)
  )
  
  (* /\

(*/\
	(( AppData.AppInBuf(ci,gs.appdata) = None /\
	    AppData.AppInStream( ci,gs.appdata) =
		TLSFragment.HistoryStream(ci.id_in, TLSConstants.Application_data,Record.History(ci.id_in, gs.read.conn))) \/
	  (?r,f. AppData.AppInBuf(ci,gs.appdata) = Some((r,f)) /\
	    Fragment.Extend(ci.id_in,AppData.AppInStream(ci,gs.appdata),r,f) = 
	    TLSFragment.HistoryStream(ci.id_in, TLSConstants.Application_data,Record.History(ci.id_in, gs.read.conn))
	  )
	))
                                 *)
type Connection = Conn of (id:ConnectionInfo * (;id)globalState)

predicate CanWrite of ConnectionInfo
assume !ci,c. Handshake.Complete(ci,c) => CanWrite(ci)

function val ConnectionEpochOut: Connection -> epoch
assume !id,s. ConnectionEpochOut(Conn(id,s)) = id.id_out
function val ConnectionEpochIn:  Connection -> epoch
assume !id,s. ConnectionEpochIn(Conn(id,s))  = id.id_in


function val ConnectionSIOut: Connection -> SessionInfo
assume !id,s. ConnectionSIOut(Conn(id,s)) = EpochSI(id.id_out)
function val ConnectionSIIn: Connection -> SessionInfo
assume !id,s. ConnectionSIIn(Conn(id,s)) = EpochSI(id.id_in)

function val ConnectionInHistory: c:Connection -> (;ConnectionEpochIn(c))TLSFragment.history
assume !id,s. ConnectionInHistory(Conn(id,s)) = Record.History(id.id_in,s.read.conn)
function val ConnectionOutHistory: c:Connection -> (;ConnectionEpochOut(c))TLSFragment.history
assume !id,s. ConnectionOutHistory(Conn(id,s)) = Record.History(id.id_out,s.write.conn)

// Previously in TLS, needed here.
function val CnId: Connection -> ConnectionInfo
private assume !id, s. CnId(Conn(id, s)) = id

function val CnStream_i: c:Connection -> (;ConnectionEpochIn (c)) stream
function val CnStream_o: c:Connection -> (;ConnectionEpochOut(c)) stream
private assume !id, s. CnStream_i(Conn(id, s)) =  AppData.AppInStream(id, s.appdata)
private assume !id, s. CnStream_o(Conn(id, s)) = AppData.AppOutStream(id, s.appdata)

type (;e:epoch,s:(;e)stream)msg_i = r:range * (;e,s,r)delta
type (;e:epoch,s:(;e)stream)msg_o = r:range * (;e,s,r)delta

function val CnBuf_o: c:Connection -> ((;ConnectionEpochOut(c),CnStream_o(c))msg_o) option
private assume !id,s. CnBuf_o(Conn(id,s)) = AppData.AppOutBuf(id,s.appdata)

function val Bytes_o: Connection -> bytes
function val Bytes_i: Connection -> bytes
function val StreamToBytes: ki:epoch * (;ki) stream -> bytes
private assume !c. Bytes_o(c) = StreamToBytes(ConnectionEpochIn (c), CnStream_i(c))
private assume !c. Bytes_i(c) = StreamToBytes(ConnectionEpochOut(c), CnStream_o(c))

predicate EvWrite      of ConnectionInfo * bytes
predicate EvWarning    of ConnectionInfo * alertDescription * bytes
predicate EvClose      of ConnectionInfo * bytes
predicate EvFatal      of ConnectionInfo * alertDescription * bytes
// Write records increasing prefixes of the stream, for each written data fragment, 
// interleaved with warnings, ended by Fatal or Close [we may distinguish between two kinds of close too]
// Write(i,p0), ..., Write(i,p0 @| ... @| pi), Warning(i,p0 @| ... @| pi), ..., Close(i, p0 @| ... @| pn)

function val Role: Connection -> Role
assume !c. Role(c) = CnId(c).role

function val DualRole: Role -> Role
assume DualRole(Client) = Server
assume DualRole(Server) = Client

// Peer(i,()) ghostly refers to the remote peer's ConnectionInfo 
function val Peer: ConnectionInfo * unit -> ConnectionInfo 
assume !ki. Peer(ki, ()) = { id_in = ki.id_out; id_out = ki.id_in; role = DualRole(ki.role) }

predicate Extend   of c:Connection * c':Connection
predicate Extend_o of c:Connection * c':Connection * (;ConnectionEpochOut(c),CnStream_o(c)) msg_o
predicate Extend_i of c:Connection * c':Connection * (;ConnectionEpochIn (c),CnStream_i(c)) msg_i

function val MsgOBytes: c:Connection * (;ConnectionEpochOut(c),CnStream_o(c)) msg_o -> bytes
function val MsgIBytes: c:Connection * (;ConnectionEpochIn (c),CnStream_i(c)) msg_i -> bytes

predicate Split_o of
	  c:Connection
	* (;ConnectionEpochOut(c),CnStream_o(c))msg_o
	* (;ConnectionEpochOut(c),CnStream_o(c))msg_o
	* c':Connection
	* (;ConnectionEpochOut(c'),CnStream_o(c'))msg_o


definition !c, c'. 
	Extend(c, c') <=>    Bytes_i(c') = Bytes_i(c)
                      /\ Bytes_o(c') = Bytes_o(c)

definition !c, c', msg.
	Extend_o(c, c', msg) <=>     Bytes_i(c') = Bytes_i(c)
                              /\ Bytes_o(c') = Bytes_o(c) @| MsgOBytes(c, msg)

definition !c, c', msg. 
	Extend_i(c, c', msg) <=>     Bytes_i(c') = Bytes_i(c) @| MsgIBytes(c, msg)
                              /\ Bytes_o(c') = Bytes_o(c)

val networkStream: Connection -> Tcp.NetworkStream

function val Config: Connection -> config
assume !id,s. Config(Conn(id,s)) = Handshake.Config(id,s.handshake)

type (;r:Role,c:config) nullCn = conn:Connection {
	   Config(conn) = c /\ Role(conn) = r
	/\ TLSConstants.IsNullCiphersuite(ConnectionSIOut(conn).cipher_suite)
	/\ TLSConstants.IsNullCiphersuite(ConnectionSIIn (conn).cipher_suite)
}


predicate NextCn of Connection * Connection
assume !c,c'. NextCn(c,c') <=> ( Config(c')  = Config(c) /\ Role(c') = Role(c) /\ CnId(c') = CnId(c) )
type (;c:Connection) nextCn = c':Connection {NextCn(c,c')}
type query = Cert.certchain

type writeOutcome =
    | WError of string 
    | WriteAgain (* Possibly more data to send *)
    | WAppDataDone (* No more data to send in the current state *)
    | WHSDone
    | WMustRead (* Read until completion of Handshake *)
    | SentFatal of alertDescription * string
    | SentClose

type readOutcome =
    | WriteOutcome of writeOutcome
    | RError of string 
    | RAgain
    | RAppDataDone 
    | RQuery of query
    | RHSDone
    | RClose
    | RFatal of alertDescription
    | RWarning of alertDescription

predicate val IOResult_i : Connection * Connection * readOutcome * 'a -> bool
predicate val IOResult_o : Connection * 'a * Connection * writeOutcome * 'b -> bool

assume !c,m,c',wo,mo. IOResult_o(c,m,c',wo,mo)  <=>
	(
		// Cases needed by the top level interface
	(wo = WAppDataDone /\ mo = None /\ Extend_o(c,c',m) /\ NextCn(c,c'))

)
(*
 \/
        (wo = WAppDataDone /\ (?m0,m'. mo = Some(m') /\ Split_o(c,m,m0,c',m') /\ Extend_o(c,c',m0) /\ NextCn(c,c'))) \/
        (wo = WHSDone /\
		  (
			   Role(c') = Role(c)
	/\ Config(c') = Config(c)
			/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
			/\ Bytes_i(c') = [||]
			/\ EvClose(Peer(CnId(c),()), Bytes_i(c))

			/\ Handshake.Complete(CnId(c'),Config(c'))
			/\ (
				(Handshake.EvSentFinishedFirst(CnId(c'),true) /\
					  Bytes_o(c') = Bytes_o(c)
		   /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
			)
		\/
				(Handshake.EvSentFinishedFirst(CnId(c'),false) /\
					  Bytes_o(c') = [||]
				   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				)
			   )
		   )
		 ) \/
		 (wo = WMustRead /\
		   (
			  	Role(c') = Role(c) 
			 /\ Config(c') = Config(c)
			 /\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
			 /\ Bytes_i(c') = Bytes_i(c)
			 /\ Bytes_o(c') = [||]
			 /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))                                                                                                                                                         
		   )
		 ) \/
		 // Cases needed by dispatch; in practice not giving any refinement,
		 // just completing all the cases.
		 (?err. wo = WError(err) ) \/
	 (wo = WriteAgain ) \/
		 (?ad,s. wo = SentFatal(ad,s) ) \/
		 (wo = SentClose )
	)

  *)                                                                                                                                                              

assume !c,c',ro,mo. IOResult_i(c,c',ro,mo) =>
   (
    // Cases needed by the top level interface
	(ro = RClose /\ (Auth(ConnectionEpochIn(c)) => EvClose(Peer(CnId(c),()),Bytes_i(c)))) \/
	(?ad. ro = RFatal(ad) /\ (Auth(ConnectionEpochIn(c)) => EvFatal(Peer(CnId(c),()),ad,Bytes_i(c)))) \/
	(?ad. ro = RWarning(ad) /\ Extend(c,c') /\ (Auth(ConnectionEpochIn(c)) => EvWarning(Peer(CnId(c),()),ad,Bytes_i(c))) /\ NextCn(c,c')) \/
	(?q. ro = RQuery(q) /\ Extend(c,c') /\ NextCn(c,c')) \/
	(ro = RHSDone /\ 
	  (
		   Role(c') = Role(c)
		/\ Config(c') = Config(c)
		/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
		/\ Bytes_i(c') = [||]
		/\ EvClose(Peer(CnId(c),()), Bytes_i(c))

		/\ Handshake.Complete(CnId(c'),Config(c'))

		/\ (
			(Handshake.EvSentFinishedFirst(CnId(c'),true) /\
				  Bytes_o(c') = Bytes_o(c)
			   /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
			)
			\/
			(Handshake.EvSentFinishedFirst(CnId(c'),false) /\
				  Bytes_o(c') = [||]
			   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
			)
		   )
	  )
	) \/
	(?m. ro = RAppDataDone /\ mo = Some(m) /\
		Extend_i(c,c',m) /\ NextCn(c,c') /\ (Auth(ConnectionEpochIn(c)) => EvWrite(Peer(CnId(c),()), Bytes_i(c')))) \/
	(ro = WriteOutcome(WMustRead) /\ 
		   (
			  	Role(c') = Role(c) 
			 /\ Config(c') = Config(c)
			 /\ ConnectionEpochIn(c') = ConnectionEpochIn(c)
			 /\ Bytes_i(c') = Bytes_i(c)
			 /\ Bytes_o(c') = [||]
			 /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))                                                                                                     
		   )
	) \/
	(ro = WriteOutcome(WHSDone) /\
		  (
			   Role(c') = Role(c)
			/\ Config(c') = Config(c)
			/\ ConnectionEpochIn(c) = Pred(ConnectionEpochIn(c'))
			/\ Bytes_i(c') = [||]
			/\ EvClose(Peer(CnId(c),()), Bytes_i(c))

			/\ Handshake.Complete(CnId(c'),Config(c'))

			/\ (
				(Handshake.EvSentFinishedFirst(CnId(c'),true) /\
					  Bytes_o(c') = Bytes_o(c)
				   /\ ConnectionEpochOut(c') = ConnectionEpochOut(c)
				)
				\/
				(Handshake.EvSentFinishedFirst(CnId(c'),false) /\
					  Bytes_o(c') = [||]
				   /\ ConnectionEpochOut(c) = Pred(ConnectionEpochOut(c'))
				)
			   )
		  )
	) \/
	(?ad,s. ro = WriteOutcome(SentFatal(ad,s)) ) \/
	(ro = WriteOutcome(SentClose) /\ (Auth(ConnectionEpochIn(c)) => EvClose(Peer(CnId(c),()),Bytes_i(c)))
	) \/
	// Cases needed by dispatch; in practice not giving any refinement,
	// just completing all the cases.
	(?err. ro = RError(err)) \/
	(ro = RAgain )
   )


val init: Tcp.NetworkStream -> r:Role -> c:config -> (;r,c)nullCn

val resume: Tcp.NetworkStream -> sessionID -> c:config -> (;Client,c)nullCn

val rehandshake: c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}
val rekey:       c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}
val request:     c:Connection -> conf:config ->
	(b:bool * c':Connection) {
		   Extend(c,c')
		/\ Role(c') = Role(c)
		/\ CnId(c') = CnId(c)
		/\ (   (b = false /\ Config(c') = Config(c))
			\/ (b = true  /\ Config(c') = conf    ))
	}

val full_shutdown:    c:Connection ->
	c':Connection{ Config(c') = Config(c) /\ Role(c') = Role(c) /\
		ConnectionEpochIn(c') = ConnectionEpochIn(c) /\ Extend(c,c')
		// Note: we cannot write anymore
		}
val half_shutdown: c:Connection -> unit

private val moveToOpenState: c:Connection ->
	(;CnId(c))globalState Result

private val closeConnection: c:Connection-> (;c) nextCn

private val abortWithAlert: c:Connection -> alertDescription -> string -> (;c)nextCn

private val pickSendPV: c:Connection -> TLSConstants.ProtocolVersion

private val send: Tcp.NetworkStream -> e:epoch -> w:(;e)dState ->
	TLSConstants.ProtocolVersion -> rg:range -> ct:TLSConstants.ContentType ->
	f:(;e,ct,Record.History(e,w.conn),rg)TLSFragment.fragment -> res: (;e) dState Result{
          !w'. (res = Correct(w') /\ Auth(e)) =>
            (Record.History(e,w'.conn) = TLSFragment.ExtendHistory(e,ct,Record.History(e,w.conn),rg,TLSFragment.TLSContents(f)))}
                                                                                                                                                                
private val recv: c:Connection ->
	((;ConnectionEpochIn(c)) Record.ConnectionState *
	 ct:TLSConstants.ContentType * r:range * 
         (;ConnectionEpochIn(c),ct,ConnectionInHistory(c),r)TLSFragment.fragment) Result

private val readOne: c:Connection ->
	readOutcome * Connection

private val writeOne: c:Connection ->
	(wo:writeOutcome * c':Connection){!m. CnBuf_o(c) = Some(m) => IOResult_o(c,m,c',wo,CnBuf_o(c')) }
     
private val writeAll: c:Connection ->
	writeOutcome * Connection

val read: c:Connection -> 
    (c':Connection  * ro:readOutcome* mo:(;ConnectionEpochIn(c'),CnStream_i(c'))msg_i option)
    {
      IOResult_i(c,c',ro,mo)
    }

val write: c:Connection -> // CnOutBuf(c) = None
	m:(;ConnectionEpochOut(c),CnStream_o(c))msg_o ->
	(c':Connection* wo:writeOutcome* mo:(;ConnectionEpochOut(c'),CnStream_o(c'))msg_o option)
    {
      IOResult_o(c,m,c',wo,mo)
	  // /\ CnOutBuf(c') = None
    }

val authorize: c:Connection -> q:query -> c': (;c) nextCn {Extend(c,c') /\ Handshake.Authorize(Config(c),q)}
val refuse: Connection -> query -> unit

val getEpochIn:   c:Connection -> e:epoch{e=ConnectionEpochIn(c) }
val getEpochOut:  c:Connection -> e:epoch{e=ConnectionEpochOut(c)}
val getInStream:  c:Connection -> s:(;ConnectionEpochIn(c))stream {s = CnStream_i(c)}
val getOutStream: c:Connection -> s:(;ConnectionEpochOut(c))stream{s = CnStream_o(c)}
