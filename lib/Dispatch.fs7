module Dispatch

open Bytes
open Error
open DataStream
open TLSInfo

type predispatchState =
  | Init (* of ProtocolVersion * ProtocolVersion *) (* min and max *)
  | FirstHandshake (* of ProtocolVersion *)             (* set by the ServerHello *) 
  | Finishing
  | Finished (* Only for Writing side, used to avoid sending data on a partially completed handshake *)
  | Open
  | Closing
  | Closed

type dispatchState = d:predispatchState{
	d = Init \/ d = FirstHandshake \/ d = Finishing \/ d = Finished \/
	d = Open \/ d = Closing \/ d = Closed}

type (;ki:epoch) dState = {
    disp: dispatchState;
    conn: (;ki)Record.ConnectionState;
    }

type (;id:ConnectionInfo) preGlobalState = {
  poptions: protocolOptions;
  (* abstract protocol states for HS/CCS, AL, and AD *)
  handshake: (;id) Handshake.hs_state;
  alert    : (;id) Alert.state;
  appdata  : (;id) AppDataStream.app_state;    

  (* connection state for reading and writing *)
  read  : (;id.id_in)  dState;
  write : (;id.id_out) dState;
  (* The actual socket *)
  ns: NetworkStream;
  }

type (;id:ConnectionInfo) globalState = (gs:(;id) preGlobalState)

type Connection = Conn of (id:ConnectionInfo * (;id)globalState)
function val ConnectionIndex: Connection -> ConnectionInfo
assume !id,s. ConnectionIndex(Conn(id,s)) = id

function val ConnectionEpochOut: Connection -> epoch
assume !id,s. ConnectionEpochOut(Conn(id,s)) = id.id_out
function val ConnectionEpochIn:  Connection -> epoch
assume !id,s. ConnectionEpochIn(Conn(id,s))  = id.id_in


function val ConnectionSIOut: Connection -> SessionInfo
assume !id,s. ConnectionSIOut(Conn(id,s)) = EpochSI(id.id_out)
function val ConnectionSIIn: Connection -> SessionInfo
assume !id,s. ConnectionSIIn(Conn(id,s)) = EpochSI(id.id_in)

function val ConnectionInStream: c:Connection -> (;ConnectionEpochIn(c))stream
assume !id,s. ConnectionInStream(Conn(id,s)) = AppDataStream.AppInStream(id,s.appdata)
function val ConnectionOutStream: c:Connection -> (;ConnectionEpochIn(c))stream
assume !id,s. ConnectionOutStream(Conn(id,s)) = AppDataStream.AppOutStream(id,s.appdata)

function val ConnectionInHistory: c:Connection -> (;ConnectionEpochIn(c))TLSFragment.history
assume !id,s. ConnectionInHistory(Conn(id,s)) = Record.History(id.id_in,s.read.conn)
function val ConnectionInHistory: c:Connection -> (;ConnectionEpochIn(c))TLSFragment.history
assume !id,s. ConnectionOutHistory(Conn(id,s)) = Record.History(id.id_out,s.write.conn)

function val Params: Connection -> protocolOptions
assume !id,s. Params(Conn(id,s)) = s.poptions

type (;c:Connection)nextCn = c':Connection{ConnectionIndex(c) = ConnectionIndex(c')}
type query = Certificate.cert

type (e:epoch,s:(;e)stream)msg_i = r:range * (;e,s,r)delta
type (e:epoch,s:(;e)stream)msg_o = r:range * (;e,s,r)delta

type ioerror =
    | EInternal of ErrorCause * ErrorKind
    | EFatal of alertDescription

// Outcomes for top-level functions
type (;c:Connection)ioresult_i =
    | ReadError of ioerror
    | Close     of Tcp.NetworkStream
    | Fatal     of alertDescription
    | Warning   of (;c)nextCn * alertDescription 
    | CertQuery of (;c)nextCn * query
    | Handshaken of Connection
    | Read      of (;c)nextCn * (;ConnectionEpochIn(c),ConnectionInStream(c))msg_i
    | DontWrite of Connection

type (;c:Connection)ioresult_o =
    | WriteError    of ioerror
    | WriteComplete of (;c)nextCn
    | WritePartial  of (;c)nextCn * (;ConnectionEpochOut(c),ConnectionOutStream(c))msg_o
    | MustRead      of Connection

type writeOutcome =
    | WriteAgain (* Possibly more data to send *)
    | WAppDataDone (* No more data to send in the current state *)
    | WHSDone
    | WMustRead (* Read until completion of Handshake *)
    | SentFatal of alertDescription
    | SentClose

type deliverOutcome =
    | RAgain
    | RAppDataDone
    | RQuery of query
    | RHSDone
    | RClose
    | RFatal of alertDescription
    | RWarning of alertDescription

val init: NetworkStream -> Role -> protocolOptions -> Connection

val resume: NetworkStream -> sessionID -> protocolOptions -> Connection Result

val rehandshake: c:Connection -> protocolOptions -> (;c) nextCn
val rekey:       c:Connection -> protocolOptions -> (;c) nextCn
val request:     c:Connection -> protocolOptions -> (;c) nextCn

val shutdown:    c:Connection -> protocolOptions -> (;c) nextCn

val moveToOpenState: c:Connection ->
	(si:SessionInfo * (;si)PRFs.masterSecret * Direction)
		{si=ConnectionSIOut(c) /\ si=ConnectionSIIn(c)} ->
	(;ConnectionIndex(c))globalState Result

val closeConnection: c:Connection-> (;c) nextCn

val pickSendPV: c:Connection -> CipherSuites.ProtocolVersion

val send: c:Connection -> r:range -> ct:ContentType ->
	f:(;ConnectionEpochOut(c),ct,ConnectionOutHistory(c),r)TLSFragment.fragment ->
	(;ConnectionEpochOut(c))dState Result

val writeOne: c:Connection ->
	(writeOutcome * Connection) Result

val deliver: c:Connection -> ct:ContentType -> r:range->
	(;ConnectionEpochIn(c),ct,ConnectionInHistory(c),r)TLSFragment.fragment ->
	(deliverOutcome * Connection) Result

val recv: c:Connection ->
	(c':Connection *
	 ct:ContentType * r:range * 
         (;ConnectionEpochIn(c'),ct,ConnectionInHistory(c'),r)TLSFragment.fragment) Result

val readOne: c:Connection ->
	(deliverOutcome * Connection) Result

val writeAll: c:Connection ->
	(writeOutcome * Connection) Result

val read: c:Connection -> (;c)ioresult_i

val write: c:Connection ->
	(;ConnectionEpochOut(c),ConnectionOutStream(c))msg_o ->
	(;c)ioresult_o

val authorize: Connection -> query -> Connection
val refuse: Connection -> query -> unit

val getEpochIn:   c:Connection -> e:epoch{e=ConnectionEpochIn(c) }
val getEpochOut:  c:Connection -> e:epoch{e=ConnectionEpochOut(c)}
val getInStream:  c:Connection -> s:(;ConnectionEpochIn(c))stream {s = ConnectionInStream(c) }
val getOutStream: c:Connection -> s:(;ConnectionEpochOut(c))stream{s = ConnectionOutStream(c)}