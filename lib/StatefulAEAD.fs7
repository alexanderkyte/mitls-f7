module StatefulAEAD

open TLSInfo
open TLSKey
open Error
open StatefulPlain
open DataStream 
open Bytes
open AEADPlain

// TODO 12-02: 
// - align with paper interface: (KB: Done?)
// -- group & reorder iv,key, and state into one state (hiding eg iv3) 
// -- add refinements!
// -- why returning ENC.cipher? 
// - Do we need to control the cipherlength?  

type cipher = ENC.cipher
predicate STXT of KeyInfo * state * data * fragment * cipher
assume !ki,s,d,f,c. STXT(ki,s,d,f,c) <=>
                    CTXT(ki,IntBytes(8,s.seqn) @| d,
			 {p = (s,f)},c)

val encrypt: ki:KeyInfo -> 
  w:(;ki) writer -> 
  ad:data ->
  r:range ->
  f: (;ki,w,ad,r) fragment{Next(ki,w,ad,r,f)} ->
  (w':(;ki) writer * c:cipher){
    STXT(ki,w,ad,f,c) /\ Log(w') = (ad,f)::Log(w)}

val decrypt: ki:KeyInfo -> 
  r:(;ki) reader -> 
  ad:data ->
  c:ENC.cipher ->
  res:((;ki) reader * rg:(rg:range{rg=CipherRange(ki,c)}) * 
	 (;ki,r,ad,rg) fragment) Result{
    (Safe(ki) => (!rd,rg,f. (res = Correct(rd,rg,f) <=> 
		            (?wr. Log(wr) = Log(r) /\ STXT(ki,wr,ad,f,c)))) /\
    (Auth(ki) => (!rd,rg,f. (res = Correct(rd,rg,f) =>  
		            (?wr,c. Log(wr) = Log(r) /\ STXT(ki,wr,ad,f,c))))))}
