module Handshake

(* An abstract interface to the Handshake protocol, including PKIs and the session database *)

open Bytes
open Error
open CipherSuites
open TLSInfo
open TLSKey

type role = Client | Server 
type config = protocolOptions option
val idle: config (* client-only *)
function val Idle: role * config -> config
definition !o. Idle(Client,o) = idle
definition !o. Idle(Server,o) = o
//TODO: rename ccs_data
//TODO: consider getting rid of epoch-indexed fragments.
//TODO: change Direction to role

(* Control Interface *) 

type (;r:role,o:config) state (* for each local instance of the protocol *)
val init:                               r:role -> o:config -> (;r     ,o) state 
val resume:                     si:SessionInfo -> o:config -> (;Client,o) state
val rehandshake:          (;Client,idle) state -> o:config -> (;Client,o) state
val rekey:                (;Client,idle) state -> o:config -> (;Client,o) state
val request: old:config -> (;Server,old) state -> o:config -> (;Server,o) state

(* the two new KeyInfos can be read off the handshake state *)
function val  InKi: r:role * o:config * (;r,o) state -> epoch 
function val OutKi: r:role * o:config * (;r,o) state -> epoch 
val  inKi: r:role -> o:config -> s:(;r,o) state -> ki:epoch {ki = InKi(r,o,s)}
val outKi: r:role -> o:config -> s:(;r,o) state -> ki:epoch {ki = OutKi(r,o,s)}

predicate val  InputReady: r:role * o:config * (;r,o) state -> bool (* Ready to input with new keys*)
predicate val OutputReady: r:role * o:config * (;r,o) state -> bool (* Ready to output with new keys *)
predicate val    Complete: r:role * o:config * (;r,o) state -> bool (* Completed Handshake *)

(* Network Interface *)

type (;ki:epoch,l:nat) hsFragment
type (;ki:epoch) fragment = l:nat * (;ki,l) hsFragment
val repr:     ki:epoch -> l:nat -> (;ki,l) hsFragment -> b:bytes{Length(b)=l}
val fragment: ki:epoch -> l:nat -> b:bytes{Length(b)=l} -> (;ki,l) hsFragment

type (;ki:epoch,l:nat) ccsFragment
val ccsRepr:     ki:epoch -> (;ki,1) ccsFragment -> b:bytes{Length(b)=1}
val ccsFragment: ki:epoch -> b:bytes{Length(b)=1} -> (;ki,1) ccsFragment

type (;r:role,o:config,ki:epoch) outgoing = 
  | OutIdle of               (;r,o) state
  | OutSome of               (;r,o) state * (;ki) fragment             
  | OutCCS of              s:(;r,o) state * (;ki,1) ccsFragment * (;OutKi(r,o,s)) ccs_data {OutputReady(r,o,s)} 
  | OutFinished of           (;r,o) state * (;ki) fragment
  | OutComplete of s:(;r,Idle(r,o)) state * (;ki) fragment {Complete(r,o,s)} 
val nextFragment: r:role -> o:config -> (;r,o) state -> ki:epoch -> (;r,o,ki) outgoing 

type (;r:role,o:config) incoming = 
  | InAck of                (;r,o) state 
  | InVersion of            (;r,o) state * ProtocolVersion
  | InFinished of           (;r,o) state  
  | InComplete of s:(;r,Idle(r,o)) state {Complete(r,o,s)}  
  | InError of              (;r,o) state * ErrorCause * ErrorKind
val recvFragment: r:role -> o:config -> (;r,o) state -> 
  ki:epoch -> (;ki) fragment -> (;r,o) incoming
val recvCCS: r:role -> o:config -> (;r,o) state ->
  ki:epoch -> (;ki,1) ccsFragment -> 
  s:(;r,o) state * (((;InKi(r,o,s)) ccs_data {InputReady(r,o,s)}) Result) 

(*   
!s, Complete(r,o,s) =>
  InReady(r,o,s) /\ OutReady(r,o,s) /\
  Confirmed(OutKi(s)) /\ Confirmed(InKi(s)) 
*)