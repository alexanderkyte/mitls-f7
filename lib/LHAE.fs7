module LHAE

open Bytes
open Error
open TLSInfo
open Range

open TLSConstants

type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}
(* no need to be more precise on the length *)

private type (;ki:epoch) LHAEKey =
    | MtEK of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnlyK of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO Define LHAESize. 
// TODO In the code, (LHAESize * 2) is computed in TLSConstants.getKeyExtensionLength

function val LHAESize: ki:epoch -> nat
private definition !ki,si,enc,mac. si = EpochSI(ki) =>
	(( CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version) = MACOnly(mac) =>
	  LHAESize(ki) = MacSize(mac) ) /\
	 ( CipherSuiteAuthEncAlg(si.cipher_suite,si.protocol_version) = MtE(enc,mac) =>
	  LHAESize(ki) = MacSize(mac) +
					    EncKeySize(enc) +
					    Range.IVSize(ki) ))

//CF '13 who wrote this? when? 
//TODO Why is this failing? Because of LHAESize not being what I want, I cannot typecheck COERCE.
//TODO ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => LHAESize(ki,ki) = MacSize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))

val GEN:    ki:succEpoch     -> encryptor:(;ki)LHAEKey * decryptor:(;ki)LHAEKey
val COERCE: ki:succEpoch{not Auth(ki)} -> b:bytes{Length(b) = LHAESize(ki)} -> (;ki)LHAEKey
val LEAK:   ki:succEpoch{not Auth(ki)} -> (;ki)LHAEKey -> b:bytes

private val mteKey: ki:epoch -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) LHAEKey

//FIXME: next two should be ask
private assume !e,si. si = EpochSI(e) =>
	( (si.protocol_version = SSL_3p0 \/ si.protocol_version = TLS_1p0)
		=> IVSize(e) = 0 ) /\
	( (si.protocol_version = TLS_1p1 \/ si.protocol_version = TLS_1p2) 		=> IVSize(e) = EncAlgBlockSize(CipherSuiteENCAlg(si.cipher_suite,si.protocol_version)) )

// We have two variants for encryption and decryption: 
// the first (primed) is concrete; the second is idealized at safe indexes.

predicate ENCrypted of e:epoch * ad:(;e)LHAEPlain.adata * rg:range *  
                      (;e,ad,rg)LHAEPlain.plain * cipher

// private definition !e,ad,rg,p,c.
// 	ENCrypted(e,ad,rg,p,c) <=>
// 		?k,p'. ENC.ENCrypted(e,Length(c),k,)

val encrypt': ki:succEpoch -> (;ki) LHAEKey -> ad:(;ki)LHAEPlain.adata ->
  rg:range -> p:(;ki,ad,rg) LHAEPlain.plain ->
  ((;ki) LHAEKey * c:cipher){Length(c) = TargetLength(ki,rg)}

val encrypt : ki:succEpoch -> (;ki) LHAEKey -> ad:(;ki)LHAEPlain.adata ->
  rg:range -> p:(;ki,ad,rg) LHAEPlain.plain ->
  ((;ki) LHAEKey * c:cipher){Length(c) = TargetLength(ki,rg)
  			  /\ ?p'. LHAEPlain.Payload(ki,ad,rg,p) = 
                                  LHAEPlain.Payload(ki,ad,RangeClass(ki,rg),p') /\
                                  ENCrypted(ki,ad,RangeClass(ki,rg),p',c)}

//CF unclear whether the log should include the plaintext; tried without, should rollback...
type entry = ki:succEpoch * ad:(;ki) LHAEPlain.adata * rg:range * p:(;ki,ad,rg) LHAEPlain.plain * c:ENC.cipher { ENCrypted(ki,ad,rg,p,c)}
private val log: entry list ref
private val cmem: ki:succEpoch -> ad:(;ki)LHAEPlain.adata -> c:cipher ->  
  entry list -> res:(r:range * (;ki,ad,r)LHAEPlain.plain) option { 
    ( !rg,p. res = Some ((rg,p)) => ENCrypted(ki,ad,rg,p,c) ) /\
	( res = None => !rg,p. not ENCrypted(ki,ad,rg,p,c) )}

private val safe: ki:succEpoch -> b:bool { b = true <=> Auth(ki) }

//CF a corollary of affine encryptions:
theorem !ki,d,rg0,p0,rg1,p1,c. (ENCrypted(ki,d,rg0,p0,c) /\ ENCrypted(ki,d,rg1,p1,c)) => p0 = p1

val decrypt': ki:succEpoch -> k:(;ki) LHAEKey -> ad:(;ki)LHAEPlain.adata ->
  c:cipher -> res: 
  ( ( 
    (;ki) LHAEKey *  
    rg:range * 
    p:(;ki,ad,rg) LHAEPlain.plain) {rg = CipherRangeClass(ki,Length(c))
                                    ///\ !p',rg'. ENCrypted(ki,ad,rg',p',c) => p=p'
									 } ) Result

// { (* partial functional correctness when decrypting what we encrypted *)
//   !pl,p,tag,rg.
//	(    Length(c) = EncryptedLength(ki,rg)
//	  /\ MACed(e,ad,pl,tag) // nb Encode.MACed has extra args.
//     /\ Encoded(e,ad,pl,tag,p) 
//     /\ ENCrypted(e,Length(c),StateID(e,Encryptor(k)),p,c)  
//   => ?k',r'. res = Correct((k',r',pl)) } 

val decrypt: ki:succEpoch -> (;ki) LHAEKey -> ad:(;ki)LHAEPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) LHAEKey *  rg:range * (;ki,ad,rg) LHAEPlain.plain)
     {rg = CipherRangeClass(ki,Length(c))}
  ) Result
   {
    (Safe(ki) => 
        (   (!k,r,p. res = Correct((k,r,p)) => ENCrypted(ki,ad,r,p,c)) 
	 /\ (!r,p. ENCrypted(ki,ad,r,p,c) => (?k,r'. res = Correct((k,r',p))))
		))}
// The last two lines are equivalent to (but easier to verify than)
// !p. CTXT(ki,ad,p,c) <=> (?k,r. res = Correct((k,r,p)))

(* CF 13-01-07 verification notes

We need a full independent spec of StrongAE & StAE
something like the functions below and the corresponding logical specs.

let strongAE pv cs = match cs with
  | NullCipherSuite | SCSV of _ | OnlyMACCipherSuite(_,_) -> false 
  | CipherSuite(_,ea) ->
      match ea with 
	    | MtE(eAlg, hAlg) -> int_cma pv hAlg && 
		                     ind_cpa pv eAlg && 
							 int_ctxt pv hAlg eAlg 
		| AEAD (_,_)      -> false // until we handle GCM 

let strongAuth pv cs = match cs with
  | NullCipherSuite | SCSV of _ -> false 
  | OnlyMACCipherSuite(_,hAlg)  -> int_cma hAlg 
  | CipherSuite(_,ea) -> 
      match ea with 
	    | MtE(eAlg, hAlg) -> int_cma pv hAlg  
		| AEAD (_,_)      -> false // until we handle GCM 
 
and the corresponding logical specs such that, e.g.,

ask !pv,cs. StrongAE(pv,cs) -> StrongAuth(pv,cs)
ask INT_CTXT(pv,h,e) -> 
     pv = TLS_1p2 
  \/ ?kex,hAlg. e = CipherSuite(kex,MtE(_,hAlg) && ... 

(Note that we actually don't need full CMA when we have CTXT,
 but this is practically irrelevant.)  


There are several ideal properties of AEAD:

1. (When Safe:) filter out any cipher that is not an honest encryption---a.k.a "INT-CTXT" 

2. (When Safe:) additionally decrypt by table lookup---so that we can get plain secrecy by typing 
                TODO implemented by #ideal in AEAD.fs

3. (When Auth:) filter out any (ki,plain,AD) forgery---aka "INT-PTXT" or "CMA"
                TODO implemented by #ideal in MAC.fs

For F7 clarity, we distinguish several verification steps (using flags/Makefile):

1. (When Safe, decryption correctness:) decryptions of honest ciphers always succeed, returning the plaintext
   Together with CTXT & our "at most one encryption per AD" assumption, this justifies moving from 1 to 2.
   We might also explain it with a "Decryption error oracle". 

2. If we decrypt by table lookup, then, we implement parametric AEAD (to complete the Safe proof)
   this essentially rely on CPA of the underlying encryption.

3. (When Auth, irrespective of Safe & CTXT:) AEAD is PTXT wrt to some user-defined Msg property.

We need to agree e.g. that #if ideal refers to typechecking 2. 

The postcondition of decryption thus consists of

// proved in step 3, sufficient to retrieve Msg(ki,ad,p) as a predicate attached to the CTXT log
(Auth(ki) => ((!p. (?r. res = Correct(ki,r,p)) 
               <=> ( ?c. CTXT(ki,ad,p,c))))
/\
// a stronger "Safe" authentication property, which also yields Msg(ki,ad,p)
(Safe(ki) => ((!p. ( ?r. res = Correct(ki,r,p)) 
		       <=> ( CTXT(ki,ad,p,c)))           
/\
// a functional property
(Safe(ki) => ?p. res = Correct((ki,Range(ki,c),p))) \/ res = Error(AD_bad_record_mac,"")

--- The sequence of games is 

* indistinguishability of filtering out bad ciphers at safe indexes (by CTXT assumption) 
  The joint CTXT assumption still has to be proved "by hand" for now, 
  although the functional property above helps.

* indistinguishability of decryption by lookup at safe indexes
  (by typechecking a full spec for the two variants when the lookup succeeds)

* secrecy by typing (CPA), relying on nested plains.
  for that step, we need to encapsulate Encode & Mac encryption processing into DataStream; 

  the current, specific approach is to idealize repr as max-sized-zero at safe indexes
  within encode (by ENC-CPA parametricity) then typecheck parametricy over delta.  

  a generic pattern would be (up to indexing)
  
  abstract_repr: delta -> high_bytes (within a range)
  abstract_map: (bytes -> bytes) -> high_bytes -> high_bytes (within computed range)

  
(independently:)

* CMA for Auth but not Safe.   

*)

(* CF 12-04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that CipherRange depends on the TLS version too.
*)
