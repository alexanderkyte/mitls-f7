module MACPlain

open Bytes
open TLSInfo

// Plaintext of MAC (addData + TLSFragment.fragment)
private type (;ki:KeyInfo,tlen:int) MACPlain = {p:bytes}

function val MsgBytes: pv:CipherSuites.ProtocolVersion * (;pv) TLSFragment.addData * bytes  -> bytes
assume !pv,ad,x. MsgBytes(pv,ad,x) = (ad @| IntBytes(2,Length(x))) @| x 
assume !pv,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(pv,ad1,x1) = MsgBytes(pv,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

predicate Msg of ki:KeyInfo * tlen:int * (;ki,tlen)MACPlain.MACPlain

assume !ki,tlen,pl. Msg(ki,tlen,pl) <=>
  (Corrupt(ki) \/
     (?ad,x. Length(ad) = TLSFragment.ADLength(ki.sinfo.protocol_version) /\
	  pl.p = MsgBytes(ki.sinfo.protocol_version,ad,x) /\
	  TLSFragment.Fragment(ki,tlen,
			       TLSFragment.ADseqn(ki.sinfo.protocol_version,ad),
			       TLSFragment.ADct(ki.sinfo.protocol_version,ad),x)))

ask !ki,tlen,t. Corrupt(ki) => Msg(ki,tlen,t)

val MACPlain: ki:KeyInfo -> tlen:int -> 
  ad:(;ki.sinfo.protocol_version) TLSFragment.addData ->
  f:(;ki,tlen,ad)TLSFragment.AEADPlain -> 
  p:(;ki,tlen)MACPlain{TLSFragment.AEADMsg(ki,tlen,ad,f) <=> Msg(ki,tlen,p)}

val reprMACPlain: ki:KeyInfo -> tlen:int -> (;ki,tlen)MACPlain -> bytes

// Result of MAC
type (;ki:KeyInfo,tlen:int) MACed = {m:bytes}
val MACed: ki:KeyInfo -> tlen:int -> bytes -> (;ki,tlen)MACed
val reprMACed: ki:KeyInfo -> tlen:int -> (;ki,tlen)MACed -> bytes

// MAC-only ciphersuites
val parseNoPad: ki:KeyInfo -> tlen:int -> 
  ad:(;ki.sinfo.protocol_version) TLSFragment.addData -> b:bytes -> 
  ((;ki,tlen,ad)TLSFragment.AEADPlain * (;ki,tlen)MACed)
