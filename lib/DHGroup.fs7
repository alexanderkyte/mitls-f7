module DHGroup

open Bytes

type p = bytes // DH modulus, actually a bignum
//MK we should also keep track of the subgroup order q

// For public parameters and exchange values.
// We use an abstract predicate to ensure that elements 
// are bytes that have been correctly generated or checked,
// e.g. Elt(p,g,b) => Num(b) in [2..p-1] /\ order(b) = order(g)

predicate type preds = Elt of bytes * bytes * bytes

type (;p:p) g = g:bytes{ Elt(p,g,g) } // for the group generator

type (;p:p, g:(;p) g) elt = b:bytes{ Elt(p,g,b) } 
 
// Marks "Strong" parameter generation used by compliant servers,
// formally a precondition for signing them with an honest key.
predicate type predPP = PP of p:p * g:(;p) g

val dhparams: p:p -> (;p) g -> CoreKeys.dhparams
val genElement: p:p -> g:(;p) g -> (;p,g) elt

//MK should ultimately take also q as input
val checkElement: p:p -> g:(;p) g -> b:bytes -> (b':(;p,g) elt {b = b'}) option