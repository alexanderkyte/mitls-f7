module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites

// Plain type for Dispatch
type (;ki:KeyInfo,tlen:int,seqn:int,ct:ContentType) fragment =
    | FHandshake of (;ki,seqn,tlen)Handshake.fragment    {ct=Formats.Handshake}
    | FCCS       of (;ki,seqn,tlen)Handshake.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of (;ki,seqn,tlen)Alert.fragment        {ct=Alert}
    | FAppData   of (;ki,seqn,tlen)AppDataPlain.fragment {ct=Application_data}

val repr: ki:KeyInfo -> tlen:int -> seqn:int -> ct:ContentType -> (;ki,tlen,seqn,ct)fragment -> bytes
val TLSfragment: ki:KeyInfo -> tlen:int -> seqn:int -> ct:ContentType -> bytes -> (;ki,tlen,seqn,ct)fragment

// Plain type for AEAD
private type addData = bytes
function val ADBytes: ProtocolVersion * int * ContentType -> addData

private assume !pv,seqn,ct.
	( pv = SSL_3p0 /\
	  ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| CTBytes(ct) ) \/
	  ADBytes(pv,seqn,ct) =
		IntBytes(8,seqn) @| CTBytes(ct) @| VersionBytes(pv)

private val makeAD: pv:ProtocolVersion ->
	seqn:int -> ct:ContentType ->
	ad:addData{ad=ADBytes(pv,seqn,ct)}

private val parseAD: pv:ProtocolVersion -> ad:addData -> (seqn:int * ct:ContentType){ad=ADBytes(pv,seqn,ct)}

function val ADct: ProtocolVersion * addData -> ContentType
private assume !pv,seqn,ct,ad.
	ad=ADBytes(pv,seqn,ct) => ct=ADct(pv,ad)

function val ADseqn: ProtocolVersion * addData -> int
private assume !pv,seqn,ct,ad.
	ad=ADBytes(pv,seqn,ct) => seqn=ADseqn(pv,ad)

private type (;ki:KeyInfo,tlen:int,ad:addData) AEADFragment = (;ki,tlen,ADseqn(ki.sinfo.protocol_version,ad),ADct(ki.sinfo.protocol_version,ad))fragment


val AEADFragment: ki:KeyInfo -> tlen:int -> ad:addData -> bytes -> (;ki,tlen,ad)AEADFragment{?seqn,ct. ad=ADBytes(ki.sinfo.protocol_version,seqn,ct)}
val AEADRepr: ki:KeyInfo -> tlen:int -> ad:addData -> f:(;ki,tlen,ad)AEADFragment -> b:bytes{?seqn,ct. ad=ADBytes(ki.sinfo.protocol_version,seqn,ct)}

val AEADToDispatch: ki:KeyInfo -> tlen:int -> seqn:int -> ct:ContentType -> ad:addData{ad=ADBytes(ki.sinfo.protocol_version,seqn,ct)} -> (;ki,tlen,ad)AEADFragment -> (;ki,tlen,seqn,ct)fragment
val DispatchToAEAD: ki:KeyInfo -> tlen:int -> seqn:int -> ct:ContentType -> ad:addData{ad=ADBytes(ki.sinfo.protocol_version,seqn,ct)} -> (;ki,tlen,seqn,ct)fragment -> (;ki,tlen,ad)AEADFragment
