module Bytes

(* Binary representations, using byte arrays *)

type nat = n:int {0 <= n} // a convenient abbreviation 
type bytes = byte array


function val Length: bytes -> int 
val length: b:bytes -> l:nat {Length(b) = l}
assume !x:bytes, y:bytes. Length(x @| y) = Length(x) + Length(y)

type (;l:nat) lbytes = b:bytes {Length(b) = l}

function val ListLength: 'a list -> nat
assume ListLength(op_Nil()) = 0
assume !x,y. ListLength(op_ColonColon(x,y)) = 1 + ListLength(y)
assume !l. Length(array_of_list(l)) = ListLength(l)


val createBytes: l:int -> int -> (;l) lbytes
// val zeroCreate: l:int -> b:bytes {Length(b) = l}

val equalBytes: b0:bytes -> b1:bytes -> 
  r:bool {(r = true /\ b0 = b1) \/ (r = false /\ b0 <> b1)}


(* array concatenation (append) *)

val op_AtBar: b1:bytes -> b2:bytes -> b:bytes{b = b1 @| b2}
//val append: b1:bytes -> b2:bytes -> b:bytes{b = b1 @| b2}

val split:
  b:bytes -> i:nat{Length(b) >= i} ->
  b1:bytes * b2:bytes { Length(b1) = i /\ b = b1 @| b2 }

val split2: b:bytes -> i:nat -> j:nat  {Length(b) >= i+j} ->
  b1:bytes * b2:bytes * b3:bytes { Length(b1)=i /\ Length(b2)=j /\ b = b1 @| b2 @| b3}

// empty array is an identity for append
// assume !x. [||] @| x = x
assume !x. x @| [||] = x

// append is injective when using fixed lengths.
assume !b1,b2,c1,c2. 
  (b1 @| b2 = c1 @| c2 /\ Length(b1)=Length(c1)) => (b1=c1 /\ b2=c2)   

assume !b1,b2,c1,c2. 
  (b1 @| b2 = c1 @| c2 /\ Length(b2)=Length(c2)) => (b1=c1 /\ b2=c2)   

// append is associative
assume !b1,b2,b3. (b1 @| b2) @| b3 = b1 @| (b2 @| b3)

(* integer multi-byte representations *)

function val IntBytes: int * int -> bytes

//CF: we need stronger preconditions, e.g.
//    (l=1 /\ 0 <= l /\ l < 256)
// \/ (l=2 /\ 0 <= l /\ l < 65536)
// /\ (l=4 /\ 0 <= l) 
val bytes_of_int: l:int -> i:int -> b:bytes{b = IntBytes(l,i)}
val int_of_bytes: b:bytes {Length(b)<=8} -> i:nat{b = IntBytes(Length(b),i)}

assume !l:int, i:int. Length(IntBytes(l,i)) = l
assume !l:int, i0:int, i1:int. IntBytes(l,i0) = IntBytes(l,i1) => i0=i1

(* We want a notion of equivalent representation that does not include length. 
   Where do we use this? *)
//function val EquivRepr: bytes -> bytes -> true
//assume !l1:int, l2:int, i:int. EquivRepr(IntBytes(l1,i),IntBytes(l2,i))


(* string representations *)

function val Utf8: string -> bytes 
val utf8:  s:string -> b:bytes { b = Utf8(s) }
val iutf8: b:bytes -> s:string { b = Utf8(s) }

// utf8 is injective
assume !x:string, y:string. ( Utf8(x)=Utf8(y) => x = y )


(* misc, to be relocated *)

//assume !x. x <= x
//assume 0 <= 1

(* Time spans *)
type DateTime
type TimeSpan
val now: unit -> DateTime
val newTimeSpan: nat -> nat -> nat -> nat -> TimeSpan
val addTimeSpan: DateTime -> TimeSpan -> DateTime
val greaterDateTime: DateTime -> DateTime -> bool

(* List operation functions. *)
function val Unfold: bytes * bytes list -> bytes
function val UnfoldBack: bytes list * bytes -> bytes
val fold: (bytes -> bytes -> bytes) -> s:bytes -> bl:bytes list -> b:bytes{b=Unfold(s,bl)}
val filter: ('a -> bool) -> 'a list -> 'a list
val foldBack: (bytes -> bytes -> bytes) -> bl:bytes list -> s:bytes -> b:bytes{b=UnfoldBack(bl,s)}
val exists: ('a -> bool) -> 'a list -> bool // Used parametrically in HS.

val memr: 'a list -> 'a -> bool 

val choose: ('a -> 'b option) -> 'a list -> 'b list // Not used parametrically in HS, but types are not defined here.
val tryFind: ('a -> bool) -> 'a list -> 'a option
val listLength: l:('a list) -> len:nat{ListLength(l)=len}
val listHead: l:('a list){ListLength(l) > 0} -> 'a
