module StatefulLHAE

open Error
open TLSError
open Bytes
open TLSInfo
open Range
open StatefulPlain //CF added for lighter notations

(* CF 
   This module is parameterized by StatefulPlain, providing  
   abstract types 'plain' for plaintext and 'history' for sequences of plaintexts

   The functionality is indexed by epochs, also treated abstractly, as follows:

   On each epoch, we can use:
   - an (abstract, comparable) instance identifier
     [Consisting of CSR, Role, plus the index of the derived key] 
   - an AE algorithm 
   - two idealization predicates Auth & Safe 

   From this module's viewpoint, we can (linearly) re-index
   as long as none of those are affected.
   
   Usage restrictions: 
   1. Auth & Safe depend only on the instance & the algorithm strength
      Auth must imply StrongAuth(alg), Safe must imply StrongAE(alg) 
      [Hence the actual idealization parameter is just SafeHS.] 
   
   2. The user may call GEN at most once for every instance 
      [This ensures that Auth readers & writers share the same algorithm] 

   3. The user may encrypt (or decrypt) at most once with each state.
      [This is currently enforced by code inspection.]

We may define 

type (;ki:epoch,rw:rw) state = (;I(ki),rw:rw) st 
// this permits decryption at any epoch with matching I(ki)
// this is inocuous because there is at most one such epoch.

or hide it under a "re-indexing" function that enforces some of those restrictions.

Questions: 

  - SafeHS depend *only* on the instance identifier [right?] 
    so signature verification etc are not taken into account:
    they are just means to deduce SafeHS from application-level assumptions.

    In particular, matching Finished is not usable to define safety.

  - Intuitively, parametricity is not affected because of the agreement on epochs
    between readers & writers plus the linearity assumption. 
	How to make it formal? 
	In the lookup table, as we decrypt, 
	we will now get a value indexed by the writer's epoch, ki' or I(ki').

    One possibility is to index plaintexts etc tightly, 
    using I(ki), or even (CSR,Role), a rather large change that 
	propagates to the main API.

    Another may be to return a ghost writer index ki', and use Complete => ki = ki'.
	For instance, StatefulPlain might provide a re-indexing identity

  - What is the purpose of the Safe => ... postconditons of encryp & decrypt? 
    whould it be Auth => ... ? why relying both on type abstraction and refinements? 

*)


(* MK old? 
Theorems:
 * (By Typing) The F# code for StatefulLHAE meets its F7 interface.
 * (Corollary) In safe epochs, the history, each plaintext, and LHAE keys are
   kept confidential. 
 * (Corollary) In safe epochs, the overall length of plaintext in
   the history is kept confidential (within a range).
 * (Corollary) In safe epochs, the sequence of plaintexts returned
   by decryption (at the receiver) is a prefix of the sequence of
   plaintexts passed to encryption (at the sender.)

*)


//AP: We need the following invariant: StateID(e,LHAE.LHAEKey) = SeqNum(e,history)
private type (;ki:epoch,rw:rw) state = {
  key    : (;ki) LHAE.LHAEKey;  // possibly stateful
  history: (;ki) history        // ghost state, except for the sequence number
}
 
(*KB SHOULD BE:
private type (;si:SessionInfo,rw:rw) protostate = {
  key    : (;(;si) PRF.masterSecret,cr:bytes,sr:bytes) LHAE.LHAEKey;         
}

private type (;ki:epoch,rw:rw) state = {
  key    : (;(;EpochSI(ki)) PRF.masterSecret,cr:bytes,sr:bytes) LHAE.LHAEKey;         
  history: (;ki) history; 
}

val changeState: ki:epoch -> rw:rw -> (;EpochSI(ki),rw) protostate{Complete(ki,..)} -> (;ki,rw) state
*)

function val History: e:epoch * rw:rw * (;e,rw)state -> 'a //(;e)history
private definition !e,rw,s. History(e,rw,s) = s.history

type (;ki:epoch) reader = r:(;ki,Reader) state
type (;ki:epoch) writer = w:(;ki,Writer) state

val GEN:    ki:succEpoch               -> (;ki)reader * (;ki)writer
val COERCE: ki:succEpoch{not Auth(ki)} -> rw:rw -> b:bytes{Length(b)=LHAE.LHAEKeySize(ki)} -> (;ki,rw)state
val LEAK:   ki:succEpoch{not Auth(ki)} -> rw:rw -> (;ki,rw)state -> b:bytes

val history: ki:epoch -> rw:rw -> s:(;ki,rw) state -> h:(;ki)history{h=History(ki,rw,s)}

// Ideally,
// the writer maintains a table (ki, h, ad, range, fragment, cipher) {...} [details?]
// when Safe(ki), the writer uses 0s instead of the actual fragment
// when Auth(ki), the reader decrypts by table lookup
// turning forgeries into errors; retrieving the "right" history index; returning the concrete decrypted range

//CF 21/4: ENCrypted is an event tracking written cipher fragments; not sure about details and contents ?!
//CF e.g.    * the decrypted rg is NOT authenticated
//CF         * the states are not necessarily synchronized; only the histories are when Auth(ki)

type cipher = LHAE.cipher

predicate ENCrypted of e:epoch * h:(;e)history * ad:(;e)adata * cipher
private definition !e,h,ad,c. 
  ENCrypted(e,h,ad,c) <=> 
  (?ad'. B(ad') = LHAEPlain.MakeAD(e,h,B(ad)) /\ 
         LHAE.ENCrypted(e,ad',c))

val encrypt:
  ki:succEpoch -> wr:(;ki) writer -> 
  ad:(;ki) adata ->
  rg:range ->
  f: (;ki,ad,History(ki,Writer,wr),rg) plain ->
  (wr':(;ki) writer * c:cipher)
  {   History(ki,Writer,wr') = ExtendHistory(ki,ad,History(ki,Writer,wr),rg,f)
  /\  (Safe(ki) => ENCrypted(ki,History(ki,Writer,wr),ad,c)) } 

val decrypt: 
  ki:succEpoch -> rd:(;ki) reader -> 
  ad:(;ki) adata ->
  c:cipher ->
  r:((;ki) reader * rg:range * (;ki,ad,History(ki,Reader,rd),rg) plain) Result
  { !nrd,rg,f. r = Correct((nrd,rg,f)) => 
               (   History(ki,Reader,nrd) = 
                   ExtendHistory(ki,ad,History(ki,Reader,rd),rg,f) /\
                   rg = CipherRangeClass(ki,Length(c)) /\
 	         (Safe(ki) =>
				( (!nrd,rg,f. r = Correct((nrd,rg,f)) => ENCrypted(ki,History(ki,Reader,rd),ad,c)) // /\
				//  (!rg,p. ENCrypted(ki,rd,ad,rg,Payload(ki,ad,rg,p),c) => (?nrd,rg. res = Correct((nrd,rg,p))))
				)
			 ) ) }
			 
//CF 21/4: as stated, we need the resulting readers and writers to have explicitly-updated histories (irrespective of AUTH)
//CF 21/4: can we return an option instead? Otherwise we may have to specify which errors can be returned.
