module Sig

// TLS uses three signatures algorithms, together with an hash algorithm.
// We verify TLS security relative to those combinations of algorithms
// providing CMA-security, as specified in this interface. 
// However, none of them are CMA-secure in the standard model.

// This interface is adapted from the one described in CCS'11.
// Its implementation is *not* verified for now.

//*********************** Cryptographic agility **************************** 

// note that the *same* key is used with different hashes. 
// so we will need joint security for them

// TLS 1.2 provides explicit support for it:
// [1.2] - Substantial cleanup to the client's and server's ability to
//         specify which hash and signature algorithms they will accept.
//         Note that this also relaxes some of the constraints on signature
//         and hash algorithms from previous versions of TLS.

// TODO: there is some adhocness processing of those algs left in Handhshake.fs
  
 // implements SignatureAndHashAlgorithm, with fewer values for hashAlg
type alg = Algorithms.sigAlg * Algorithms.hashAlg // hashAlg does *not* include some values from the spec.

type text = Bytes.bytes
type (;a:alg) sigv = Bytes.bytes
  // TODO: specify their size, 36 with RSA, 20 with DSA
  // with TLS 1.2, this explicitly contains a; see DigitallySigned struct 

// Summary of the extension logic for the client:
// - specific to TLS 1.2
// - cs indicates sigAlg but not hashAlg, but "this is historical"
// - extension indicates supported algs (not necessarily following the cs)
// - no extension == client supports exactly the default alg

// let defaultAlg cs =
//   let a = 
//     match cs with 
//     | RSA | DH_RSA | DHE_RSA | RSA_PSK (* | ECDH_RSA | ECDHE_RSA *) -> RSA
//     | DH_DSS | DHE_DSS                                              -> DSA
//   (*| ECDH_ECDSA | ECDHE_ECDSA                                      -> ECDSA in
//   (a, SHA1)

// TODO: how to extract & checks the algs from certs?
// TODO: how does the server control the choice of algorithms? For now hardcoded.

//********************** Ideal Functionality for Signing *********************** 

type (;a:alg) skey 
type (;a:alg) vkey = Bytes.bytes //TODO: relate to sk

// AP: These are "Coerce"-like.
val create_skey: Algorithms.hashAlg -> Algorithms.skeyparams -> skey
val create_vkey: Algorithms.hashAlg -> Algorithms.pkeyparams -> vkey

function val PK: 'a -> vkey // a:alg * (;a)skey -> vkey
predicate val Msg: alg * vkey * text -> bool

// FIXME: Local dummy definition of "Strong", until we relocate CMA/CTXT and the like to algorithm.
predicate val Strong: alg -> bool

val gen:     a:alg -> pk:(;a) vkey * sk:(;a) skey { pk = PK(sk) }
val sign:    a:alg -> sk:(;a) skey -> t:text{Msg(a,PK(sk),t)} -> (;a) sigv
val verify:  a:alg -> pk:(;a) vkey -> t:text -> m:(;a) sigv -> b:bool {b=true /\ Strong(a) => Msg(a,pk,t)}

// AP: Commenting out these "leak"-like functions, until we implement them.
// 
// val PkBytes: a:alg -> pkey -> bytes
// val SkBytes: a:alg -> sk:skey {!t. Msg(a,pk,t) } -> bytes // a.k.a. leak

// TODO: adjust compromise model, connect it to HSK (mostly for the benefit of the adversary)
