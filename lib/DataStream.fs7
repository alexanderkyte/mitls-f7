module DataStream

(* Application-level bytes streams exchanged over TLS;            *)
(* depending on the safety of their indexes,                      *) 
(* these streams are treated abstractly by our TLS implementation *)

open TLSInfo
open Bytes
open Error

/// Auxiliary functions for ranges

private val min: a:nat -> b:nat -> c:nat{(a<=b /\ c=a) \/ (a>b /\ c=b)}
private val max: a:nat -> b:nat -> c:nat{(a>=b /\ c=a) \/ (a<b /\ c=b)}
val splitRange: ki:succEpoch -> r:range -> (r0:range * r1:range){r = Sum(r0,r1)} 
(* TODO first range should fit in a fragment: FitsInFrag(ki,fragmentLength,r0)? *)
(* TODO exclude unexpectedErrors, or return a "result" *)

/// Bytestreams

// we communicate deltas indexed by all preceding bytes on the stream.  
// TLS guarantees abstraction for every delta with a safe index; 
// this is the main basis for application-level integrity and secrecy 

// used only as a ghost index:
// streams have no destructors, so they do not leak secrets
// they are used abstractly by TLS, except that
// their logical definition is needed for authentication in application code.
private type (;ki:epoch) stream = {sb:bytes list}

// the implementation of this type is application-specific 
// but it must provide the following functions to TLS
private type (;ki:epoch, h:(;ki)stream, r:range) delta = {contents: (;r) rbytes}

predicate EmptyStream of ki:epoch * (;ki) stream 
definition !ki,s. EmptyStream(ki,s) <=> s = {sb = []}
ask !ki,s,s'. EmptyStream(ki,s) /\ EmptyStream(ki,s') => s = s'

function val ExtendStream: 'a * 'b * 'c * 'd -> 'e
private definition !ki,s,r,d. ExtendStream(ki,s,r,d) = {sb = d.contents :: s.sb } 

// used only by the application; could be omitted for TLS
private val createDelta: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta  

//CF we need a better verification pattern for multi-user interfaces.
//CF a cheap one is to use different names plus ifdefs in the .fsi

// used by TLS
val init: ki:epoch -> s:(;ki) stream{EmptyStream(ki,s)}
val append: 
  ki:epoch -> s: (;ki) stream -> r:range ->
  d:(;ki,s,r) delta -> s':(;ki) stream{s' = ExtendStream(ki,s,r,d)}

val deltaPlain: 
  ki:epoch{not Auth(ki)} -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaRepr: 
  ki:epoch{not Safe(ki)} -> s:(;ki) stream -> r:range -> 
  c: (;ki,s,r) delta -> (;r) rbytes

val split: ki:epoch -> s:(;ki) stream -> 
  r0:range -> r1:range -> d:(;ki,s,Sum(r0,r1)) delta -> 
  (d0:(;ki,s,r0) delta * d1:(;ki,ExtendStream(ki,s,r0,d0),r1) delta)

//CF: We need linearity on the stream! 

(* This would be the application interface: 

val deltaPlain: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaRepr: 
  ki:epoch -> s:(;ki) stream -> r:range -> 
  c: (;ki,s,r) delta -> (;r) rbytes 

*)