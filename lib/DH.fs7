module DH

open Bytes
open DHGroup

// "Strong" parameter generation used by compliant servers,
// formally a precondition for signing them with an honest key.
predicate val PP: p:p * g:(;p) g -> bool
private val goodPP: p:p * g:(;p) g -> bool

//#begin-abstraction
type (;p:p,g:(;p)g,gx:(;p)elt) secret
//#end-abstraction

// the RFCs are vague about best practices for ppgen
val gen_pp:     unit -> p:p * g:(;p) g {PP(p,g)}
val default_pp: unit -> p:p * g:(;p) g {PP(p,g)}

predicate HonestExponent of p:p * g:(;p)g * gx:(;p)elt
val genKey: p:p -> g: (;p) g -> gx:(;p) elt * (;p,g,gx) secret{
  HonestExponent(p,g,gx)}

val exp: p:p -> g:(;p)g -> gx:(;p) elt -> gy:(;p) elt -> x:(;p,g,gx) secret -> res:(;p,g,gx,gy) PMS.dhpms //MK say something about honesty of pmsId
//MK: { HonestExponent(p,g,gx)  /\ HonestExponent(p,g,gy) => 
//MK:    TLSInfo.HonestDHPMSData(p,g,gx,gy) }
    

val serverGen: unit -> (p:p * g:(;p) g * gs:(;p) elt * (;p,g,gs) secret{HonestExponent(p,g,gs)})

val clientGenExp: p:p -> g:(;p) g -> gs:(;p) elt -> (gc:(;p) elt * (;p,g,gc) secret * res:(;p,g,gc,gs) PMS.dhpms){HonestExponent(p,g,gc) /\ (HonestExponent(p,g,gs) => 
    PMS.HonestDHPMS(p,g,gc,gs,res))}

val serverExp: p:p -> g:(;p) g -> gs:(;p) elt{HonestExponent(p,g,gs)} -> gc:(;p) elt -> s:(;p,g,gs) secret -> res:(;p,g,gc,gs) PMS.dhpms{HonestExponent(p,g,gc) => PMS.HonestDHPMS(p,g,gc,gs,res)}
