module TLS

open Error
open Bytes
open AppConfig
open DataStream
open Dispatch

// Remove the following types ASAP (i.e. when Dispatch.fs7 compiles)
type NetworkStream

type index
type range
type (;id:index) state
type parameters

type conn = Conn of (id:index * (;id) state)

predicate val TXT: index -> bool

function val Dual: index -> index

predicate val Fatal: (index * bytes) -> bool
predicate val Close: (index * bytes) -> bool
predicate val Write: (index * bytes) -> bool
predicate val Read : (index * bytes) -> bool

function val WrittenBytes: conn -> bytes
function val    ReadBytes: conn -> bytes

function val Parameters: conn -> parameters 

val parameters: c:conn -> p:parameters {p = Parameters(c)}

type (;c:conn, rg:range) delta
type (;c:conn) query

predicate val Split :
    (rg0:range           * newrg:range                * rg:range *
     c  :conn            * newc :conn                 *
     d0 :(;c, rg0) delta * newd :(;newc, newrg) delta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val  ReadExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val    NoExtend : (c:conn * c':conn) -> bool

function val WriteBytes : conn -> bytes
function val  ReadBytes : conn -> bytes

function val DeltaBytes : (c:conn * rg:range * (;c, rg) delta) -> bytes

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WriteBytes(c') = WriteBytes(c) @| DeltaBytes(c, rg, d) 
    /\  ReadBytes(c') =  ReadBytes(c)
    /\ Parameters(c') = Parameters(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
        ReadBytes(c') =  ReadBytes(c) @| DeltaBytes(c, rg, d)
    /\ WriteBytes(c') = WriteBytes(c)
    /\ Parameters(c') = Parameters(c)

definition !c, c'. NoExtend(c, c') <=>
        ReadBytes(c) =  ReadBytes(c')
    /\ WriteBytes(c) = WriteBytes(c')
    /\ Parameters(c) = Parameters(c')

type (;c:conn, rg:range, d:(;c, rg) delta) ioresult_o =
| Out_Error         of ErrorKind * ErrorCause
| Out_MustRead      of c':(;c) SameConnection { NoExtend(c, c') }
| Out_WriteComplete of c':(;c) SameConnection { WriteExtend(c, c', rg, d) }

| Out_WritePartial  of c':(;c) SameConnection * rg':range * d':(;c', rg') delta {
     ?d0, rg0.    WriteExtend(c, c', rg0, d0)
               /\ Split(rg0, rg', rg, c, c', d0, d', d)
  }

type (;c:conn) ioresult_i =
| In_Error of ErrorKind * ErrorCause

| In_Warning of c':(;c) SameCommection * alertDescription { NoExtend(c, c') }
| In_Fatal   of c':(;c) SameConnection { TXT(CID(c)) => Fatal(Dual(CID(c)), ReadBytes(c)) }

| In_CertQuery of c':conn * (;c') query

| In_HandshakeDone of c':conn {
    WrittenBytes(c') = [||] /\ ReadBytes(c') = [||]
  }

| In_Close of unit {
    TXT(CID(c)) => Close(Dual(CID(c)), ReadBytes(c))
  }

| In_Read of c':(;c) SameConnection * rg:range * d:(;c, rg) delta {
       CID(c) <> null
    /\ SameConnection(c, c')
    /\ ReadExtend(c, c', rg, d)
    /\ TXT(CID(c)) => Write(Dual(CID(c)), ReadBytes(newc))
  }

val null: index // NULL_NULL ciphersuite

// client-only; as is, must be followed by a read until Handshaken
val connect: NetworkStream -> p:parameters -> (c:conn { CID(c) = null /\ Parameters(c) = p }) Result
// server-only; as is, must be followed by a read until Handshaken
val accept:  NetworkStream -> p:parameters -> (c:conn { CID(c) = null /\ Parameters(c) = p }) Result

// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))
val write: c:conn -> rg:range -> d:(;c, rg) delta -> (;c, rg, d) ioresult
val read : c:conn -> (;c) ioresult_i

// ?non-blocking?
val rekey   : c:conn -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
val shutdown: c:conn -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
  
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:conn -> (;c) query -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
val refuse:    c:conn -> (;c) query -> unit
