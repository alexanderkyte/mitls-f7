module PRF

open Bytes
open TLSInfo
open StatefulAEAD

type repr = (;48)lbytes
private type (;si:SessionInfo) masterSecret = {bytes: repr}

val keyGen: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret -> 
  (w:(;ci.id_out)StatefulAEAD.writer * r:(;ci.id_in)StatefulAEAD.reader){
    StatefulPlain.EmptyHistory(ci.id_out,w.history) /\
    StatefulPlain.EmptyHistory(ci.id_in,r.history)}

         (* No label, it's hardcoded. Of course we can make it explicit -> *)
         (* No seed (crandom @| srandom), it can be retrieved from epoch (and not SessionInfo!) -> *)

predicate VerifyData of SessionInfo * Role * bytes
predicate AuthSI of SessionInfo

val makeVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
                   log:bytes{VerifyData(si,r,log)} -> 
                   bytes (* length depends on cs, 12 by default *)

val checkVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
				   log:bytes (* the log *) ->
				   vd:bytes (* the expected value *) ->
				   b:bool{b = true /\ AuthSI(si) => 
                                          VerifyData(si,r,log)}

val ssl_certificate_verify: si:SessionInfo -> (;si)masterSecret -> TLSConstants.sigAlg -> bytes -> bytes

// FIXME we need to add something like {not Auth(si)}, but Auth is defined on epochs, not sessions
val coerce: si:SessionInfo{not AuthSI(si)} -> repr -> (;si)masterSecret
