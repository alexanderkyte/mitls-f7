module Handshake

// We haven't yet verified the Handshake implementation against this interface.

open Bytes
open Error
open TLSInfo
open DataStream
open StatefulAEAD
open TLSConstants

(* Message Predicates *)
type HandshakeType =
    | HT_hello_request
    | HT_client_hello
    | HT_server_hello
    | HT_certificate
    | HT_server_key_exchange
    | HT_certificate_request
    | HT_server_hello_done
    | HT_certificate_verify
    | HT_client_key_exchange
    | HT_finished

function val HTBytes: HandshakeType -> bytes

private assume
    HTBytes(HT_hello_request      ) = [|  0uy |] /\ 
    HTBytes(HT_client_hello       ) = [|  1uy |] /\
    HTBytes(HT_server_hello       ) = [|  2uy |] /\
    HTBytes(HT_certificate        ) = [| 11uy |] /\
    HTBytes(HT_server_key_exchange) = [| 12uy |] /\
    HTBytes(HT_certificate_request) = [| 13uy |] /\
    HTBytes(HT_server_hello_done  ) = [| 14uy |] /\
    HTBytes(HT_certificate_verify ) = [| 15uy |] /\
    HTBytes(HT_client_key_exchange) = [| 16uy |] /\
    HTBytes(HT_finished           ) = [| 20uy |]


val htBytes: ht:HandshakeType -> b:bytes{b=HTBytes(ht)}
val parseHt: b:bytes -> (ht:HandshakeType{b=HTBytes(ht)}) Result 

function val MessageBytes: bytes * bytes -> bytes
val messageBytes: ht:HandshakeType -> x:bytes -> m:bytes{m = MessageBytes(HTBytes(ht),x)}
val parseMessage: buf:bytes -> ((rem:bytes * ht:bytes * x:bytes * to_log:bytes){to_log = MessageBytes(ht,x)}) option

val makeFragment: ki:epoch -> b:bytes -> (r:range * (;ki,r) Fragment.fragment) * bytes

(* Ignoring Extensions *)

function val LenBytes: int * bytes -> bytes

(* verify data authenticated by the Finished messages *)
type log = bytes         (* message payloads so far, to be eventually authenticated *) 
type cVerifyData = bytes (* ClientFinished payload *)
type sVerifyData = bytes (* ServerFinished payload *)

function val ClientHelloMsg: (ProtocolVersion * bytes * sessionID * cipherSuites * Compression list * bytes) -> bytes
function val ClientHelloBytes: (ProtocolVersion * bytes * sessionID * cipherSuites * Compression list * bytes) -> bytes
definition !cv,clRdm,sid,clientCipherSuites,cm,ext,b.
  ClientHelloMsg(cv,clRdm,sid,clientCipherSuites,cm,ext) = b <=> (?b1,b2. 
                ContainsCompressions(b2,cm) /\ ContainsCipherSuites(b1,clientCipherSuites) /\
                b = (VersionBytes(cv) @| 
                 clRdm @| 
                 LenBytes(1, sid) @| 
                 LenBytes(2,b1) @| 
                 LenBytes(1,b2) @| 
                 ext)
				 )

definition !cv,clRdm,sid,clientCipherSuites,cm,ext.
  ClientHelloBytes(cv,clRdm,sid,clientCipherSuites,cm,ext) = 
    MessageBytes(HTBytes(HT_client_hello), ClientHelloMsg(cv,clRdm,sid,clientCipherSuites,cm,ext))
                

val parseClientHello: m:bytes -> 
	(pv:ProtocolVersion * cr:bytes * sid:sessionID * cs:cipherSuites * cm:Compression list * ext:bytes{
		m=ClientHelloMsg(pv,cr,sid,cs,cm,ext)}) Result
val clientHelloBytes: c:config -> cr:bytes -> sid:sessionID -> ext:bytes -> m:bytes{
	    m=ClientHelloBytes(c.maxVer,cr,sid,c.ciphersuites,c.compressions,ext)}

function val ServerHelloMsg: (ProtocolVersion * bytes * sessionID * cipherSuite * Compression * bytes) -> bytes

function val ClientOrServerCertificateMsg: bytes list -> bytes

function val CertificateRequestMsg: ProtocolVersion * certType list * Sig.alg list option * string list -> bytes

function val ClientKeyExchangeMsg_RSA: ProtocolVersion * si:SessionInfo * RSAKeys.pk * (;si)RSAPlain.pms -> bytes

function val ClientKeyExchangeMsg_DHE: bytes -> bytes

function val ServerKeyExchangeMsg_DHE:  ProtocolVersion * p:bytes * g:bytes * y:bytes * Sig.alg * sign:bytes-> bytes

function val ServerKeyExchangeMsg_DH_anon: bytes * bytes * bytes -> bytes

function val CertificateVerifyMsg: si:SessionInfo * (;si)PRFs.masterSecret * a:Sig.alg * Cert.certchain * (;a)Sig.pkey * log -> bytes

function val ServerHelloDoneMsg: unit -> bytes

function val ServerFinishedMsg: si:SessionInfo * (;si)PRFs.masterSecret * log -> bytes
function val ClientFinishedMsg: si:SessionInfo * (;si)PRFs.masterSecret * log -> bytes

type serverState =  (* note that the CertRequest bits are determined by the config *) 
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of SessionInfo * ProtocolVersion * RSAKeys.sk * log
   | ServerCheckingCertificateRSA of SessionInfo * ProtocolVersion * RSAKeys.sk * log * bytes
   | ClientKeyExchangeRSA         of SessionInfo * ProtocolVersion * RSAKeys.sk * log

   | ClientCertificateDH          of SessionInfo * log
   | ServerCheckingCertificateDH  of SessionInfo * log * bytes
   | ClientKeyExchangeDH          of SessionInfo * log 

   | ClientCertificateDHE         of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * (;p,g,gx)DHE.secret * log
   | ServerCheckingCertificateDHE of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * (;p,g,gx)DHE.secret * log * bytes
   | ClientKeyExchangeDHE         of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * (;p,g,gx)DHE.secret * log

   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * (;p,g,gx)DHE.secret * log

   | CertificateVerify            of si:SessionInfo * (;si)PRFs.masterSecret * log 
   | ClientCCS                    of si:SessionInfo * (;si)PRFs.masterSecret * log
   | ClientFinished               of (si:SessionInfo * (;si)PRFs.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * log){EpochSI(e)=si}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRFs.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * cVerifyData * log){EpochSI(e)=si}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRFs.masterSecret * cVerifyData * sVerifyData

   | ServerWritingCCSResume       of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;epochSI(ew))PRFs.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ClientCCSResume              of e:succEpoch * (;e)StatefulAEAD.reader * sVerifyData * (;EpochSI(e))PRFs.masterSecret * log
   | ClientFinishedResume         of si:SessionInfo * (;si)PRFs.masterSecret * sVerifyData * log

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type clientState = 
   | ServerHello                  of crand * sessionID (* * bytes for extensions? *) * cVerifyData * sVerifyData * log

   | ServerCertificateRSA         of SessionInfo * log
   | ClientCheckingCertificateRSA of SessionInfo * log * bytes
   | CertificateRequestRSA        of SessionInfo * log (* In fact, CertReq or SHelloDone will be accepted *)
   | ServerHelloDoneRSA           of SessionInfo * Cert.sign_cert * log

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of SessionInfo * log
   | ClientCheckingCertificateDHE of SessionInfo * log * bytes
   | ServerKeyExchangeDHE         of SessionInfo * log
   | CertificateRequestDHE        of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * log
   | ServerHelloDoneDHE           of SessionInfo * Cert.sign_cert * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * log

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHE.p * g:(;p)DHE.g * gx:(;p)DHE.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRFs.masterSecret * log
   | ServerCCS              of (si:SessionInfo * (;si)PRFs.masterSecret * e:succEpoch * (;e)StatefulAEAD.reader * cVerifyData * log){EpochSI(e)=si}
   | ServerFinished         of si:SessionInfo * (;si)PRFs.masterSecret * cVerifyData * log

   | ServerCCSResume        of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;EpochSI(ew))PRFs.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ServerFinishedResume   of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRFs.masterSecret * log
   | ClientWritingCCSResume of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRFs.masterSecret * sVerifyData * log
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of clientState
  | PSServer of serverState

private type pre_hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config; 
  sDB: SessionDB.SessionDB;
  (* current handshake & session we are establishing *) 
  pstate: protoState;
}

(*--- controlinterface *)
(* Control Interface *)

private type (;ci:ConnectionInfo) hs_state = pre_hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
predicate val Authorize: config * Cert.cert -> bool
predicate val Complete: ConnectionInfo * config -> bool
predicate EvSentFinishedFirst of ConnectionInfo * bool
// AP: Not sure the SentCCS event is useful;
// rather I'd welcome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool

function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream

predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
assume !ci,s. EmptyStreams(ci,s) <=> (
		EmptyStream(ci.id_in,HSInStream(ci,s)) /\
		EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
		EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
		EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
assume !ci,s,s'. SameStreams(ci,s,s') <=> (
		HSInStream(ci,s') = HSInStream(ci,s) /\
		CCSInStream(ci,s') = CCSInStream(ci,s) /\
		HSOutStream(ci,s') = HSOutStream(ci,s) /\
		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:        r:Role            -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = r /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)
		}
val resume:      nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ ci.role = Client /\
		IsNullCiphersuite(EpochSI(ci.id_in).cipher_suite) /\
		IsNullCiphersuite(EpochSI(ci.id_out).cipher_suite) /\
		EmptyStreams(ci,s)}
val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val rekey:       ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s))) /\
		SameStreams(ci,s,s')
		}
val authorize:   ci:ConnectionInfo -> s:(;ci)hs_state -> c:Cert.certchain  ->
	s':(;ci,Config(ci,s))nextState { Authorize(Config(ci,s),c) /\ SameStreams(ci,s,s') }
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState{SameStreams(ci,s,s')}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState{SameStreams(ci,hs,s')}
  | OutSome of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutCCS of  (rg:range * f:(;ci.id_out,rg)Fragment.fragment * 
               ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * s':(;ci',Config(ci,hs))nextState)
               { SentCCS(ci'.id_out) /\
			     StatefulPlain.EmptyHistory(ci'.id_out,cs.history) /\
			      ci.id_out = Pred(ci'.id_out) /\
                              ci.id_in = ci'.id_in /\
                              ci.role = ci'.role /\
				 (Auth(ci.id_out) => Fragment.Fragment(ci.id_out,CCSOutStream(ci,hs),rg,f) ) /\
				 EmptyStream(ci'.id_out,HSOutStream(ci',s')) /\
				 EmptyStream(ci'.id_out,CCSOutStream(ci',s')) /\
				 HSInStream(ci',s') = HSInStream(ci,hs) /\
				 CCSInStream(ci',s') = CCSInStream(ci,hs)
				 }
  | OutFinished of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true) /\
				(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
				HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
				CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
				HSInStream(ci,s') = HSInStream(ci,hs) /\
				CCSInStream(ci,s') = CCSInStream(ci,hs)
				}
  | OutComplete of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs)) /\
					(Auth(ci.id_out) => Fragment.Fragment(ci.id_out,HSOutStream(ci,hs),rg,f) ) /\
					HSOutStream(ci,s') = Fragment.Extend(ci.id_out,HSOutStream(ci,hs),rg,f) /\
					CCSOutStream(ci,s') = CCSOutStream(ci,hs) /\
					HSInStream(ci,s') = HSInStream(ci,hs) /\
					CCSInStream(ci,s') = CCSInStream(ci,hs)
				   }
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.certchain * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getMinVersion:        ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

/// Misc

// 
// //TODO? change sessionID to uniformally use [||] instead of None.
// 
// /// Handshake message format 
// 
// // we need a precise spec, as verifyData is a series of such messages.
// 
// function val MessageBytes: HandshakeType * bytes -> bytes 
// definition !ht,payload. MessageBytes(ht,payload) = HTBytes(ht) @| VLBytes(3,data)
// 
// val makeMessage: ht:HandshakeType -> payload:bytes -> msg:bytes { msg = MessageBytes(ht,payload) }
// val parseMessage: hs_state -> (hs_state * ht:HandshakeType * payload:bytes * msg:bytes { msg = MessageBytes(ht,payload) }) option
// //TODO unclear how to usefully maintain hs_state invariant; pass instead state.incoming? 
// 
// /// Client Hello 
// 
// 
// function val ClientHelloBytes: ... 
// definition !cv,clRdm,sid,clientCipherSuites,cm,ext.
//   ClientHelloBytes(cv,clRdm,sid,clientCipherSuites,cm,ext) = 
//     MessageBytes(
// 	  HT_client_hello, 
//       VersionBytes cv @| CRBytes clRdm @| SidBytes sid @| CipherSuitesBytes clientCipherSuites @| CompressionsBytes cm @| ext )
// 
// //TODO get rid of the intermediate record
// //TODO factor out extension processing
// val makeClientHelloBytes: ... -> msg:bytes { msg = ClientHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( cv,clRdm,sid,clientCipherSuites,cm,ext { MessageBytes(HT_client_hello,payload) =  ClientHelloBytes(...) }  ) Result
// 
// /// Server Hello 
// 
// function val ServerHelloBytes: ... // (sv,sr,sid,cs,cm,extensions) 
// definition !sv,sr,sid,cs,cm,ext.
//   ServerHelloBytes(sv,sr,sid,cs,cm,ext) =
//     MessageBytes(
// 	  HT_server_hello, 
//       VersionBytes sv @| CRBytes sr @| SidBytes sid @| CipherSuiteBytes cs @| CompressionsBytes cm @| ext )
// 
// val makeServerHelloBytes: ... -> msg:bytes { msg = ServerHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( sv,sr,sid,cs,cm,ext { MessageBytes(HT_server_hello,payload) = ServerHelloBytes(sv,sr,sid,cs,cm,ext) } ) Result
// 
// /// Certificate chains
// 
// function val CertificateListBytes: Cert.cert list -> bytes
// definition CertificateListBytes([]) = [||] 
// definition !c,cs. CertificateListBytes(c::cs) = CertificateBytes(c) @| CertificateListBytes(cs)
// 
// function val CertsBytes: Cert.cert list -> bytes
// definition !cs. CertsBytes(cs) = VLBytes 3 (CertificateListBytes(cs))
// 
// function val CertificateBytes: Cert.cert list -> bytes
// definition !certs. CertificateBytes(certs) = MessageBytes(HT_certificate,CertsBytes(certs))
// 
// val makeCertificateBytes: certs:Cert.cert list -> msg:bytes { msg = CertificateBytes(certs) }
// val parseCertificate: payload:bytes -> (certs:Cert.cert list{ MessageBytes(HT_certificate,CertsBytes(certs)) = CertificateBytes(certs) } ) Result
// 
// /// Server Hello Done
// 
// val serverHelloDoneBytes: msg:bytes { msg = Message(HT_server_hello_done,[||]) }
// 
// /// Client Key Exchange (for now only for RSA); note that this message is randomized.
// 
// predicate val ClientKeyExchangeBytes: pms * pkey * bytes -> bool (* with some injectivity properties *)
// definition !pms,pkey. ClientKeyExchangeBytes(pms,pkey,msg) =
//   ?cipher. Encrypted(pms,pkey,cipher) /\ msg = MessageBytes(HT_client_key_exchange, cipher)
// 
// //TODO makeClientKeyExchangeBytes actually generates the pms?!
// 
// val makeClientKexRsaBytes: pms:pms -> pkey:pkey -> msg:bytes { ClientKeyExchangeBytes(pms,pkey,msg) }  
// val parseClientKexRsa: si:SessionInfo -> payload:bytes -> pms:pms { !cs. si.serverID = Some(cs)  = ClientKeyExchangeBytes(pms,CertsPKey(cs),MessageBytes(HT_client_key_exchange,payload)) } 
// 
// /// State-machine invariants (sample)
// 
// // Full handshake, RSA with anonymous client, waiting for ClientKeyExchange:
// 
// config, si, log { 
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,    certs, ts 
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(certs)
//       @|  serverHelloDoneBytes
//      
//  /\ (si.sessionID = [||] \/ si.sessionID <> clientSid) (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.maxVer) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ si.compression in config.compressions
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(certs)
// }
// 
// // Idem, after a few more steps
// 
// config, si, log, pms {
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,     cs, ts,    cipher  
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(cs)
//       @|  serverHelloDoneBytes
// 	  @|  ClientKeyExchangeBytes(cipher)
//      
//  /\ si.sessionID <> clientSid (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.ver) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(cs)
// 
//  (* after ClientKeyExchange *)
//  /\ ...
// 
//  (* after accepting Finished *) 
//  /\ ( Honest(pms) /\ StrongHS(si.cipherSuite) -> ?clientConfig. ClientFinished(clientConfig,si) /\ clientVer = clientConfig.maxVer /\ ...  (* we may also rewrite the whole invariant by unification *) ) 
// 
// }
// 
// 
// 