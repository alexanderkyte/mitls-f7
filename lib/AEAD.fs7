module AEAD

open Bytes
open Error
open DataStream
open TLSInfo
open CipherSuites
open Algorithms
open AEADPlain (* parameter *)

predicate type pred = Unreachable of KeyInfo

type cipher = b:bytes{Length(b) <= DataStream.max_TLSCipher_fragment_length}

private type (;ki:KeyInfo) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO: Define AEADSize. 
// In the code, (AEADSize * 2) is computed in CipherSuites.getKeyExtensionLength

function val AEADSize: ki:KeyInfo * unit -> nat
private assume !ki.
	( IsOnlyMACCiphersuite(ki.sinfo.cipher_suite) =>
	  AEADSize(ki,()) = MacKeySize(CipherSuites.CipherSuiteMACAlg(ki.sinfo.cipher_suite)) ) /\
	( IsAEADCiphersuite(ki.sinfo.cipher_suite) =>
	  AEADSize(ki,()) = MacKeySize(CipherSuites.CipherSuiteMACAlg(ki.sinfo.cipher_suite)) +
					    EncKeySize(CipherSuites.CipherSuiteENCAlg(ki.sinfo.cipher_suite)) +
					    AEPlain.IVSize(ki,ki) )

// Why is this failing? Because of AEADSize not being what I want, I cannot typecheck COERCE.
//ask !ki. IsOnlyMACCiphersuite(ki.sinfo.cipher_suite) => AEADSize(ki,ki) = MacKeySize(CipherSuites.CipherSuiteMACAlg(ki.sinfo.cipher_suite))

val GEN:    ki:KeyInfo{Safe(ki)} -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:KeyInfo{not Auth(ki)} -> b:bytes{Length(b) = AEADSize(ki,())} -> (;ki)AEADKey
val LEAK:   ki:KeyInfo{not Auth(ki)} -> (;ki)AEADKey -> b:bytes

(* KB: 18/4. Define CTXT or assume in code? The following assume is a stop-gap *)
private assume !ki,ad,p,c. CTXT(ki,ad,p,c)

val mteKey: ki:KeyInfo -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) AEADKey

val encrypt: ki:KeyInfo -> (;ki) AEADKey -> ad:(;ki) data ->
  rg:range -> p:(;ki,rg,ad) AEADPlain ->
  ((;ki) AEADKey * c:cipher){Length(c)=AEPlain.RangeCipher(ki,rg) /\ CTXT(ki,ad,p,c)}

val decrypt: ki:KeyInfo -> (;ki) AEADKey -> ad:(;ki) data ->
  c:cipher -> res: 
  ( ((;ki) AEADKey * rg:range * (;ki,rg,ad) AEADPlain){Length(c) = AEPlain.RangeCipher(ki,rg)}) Result{
    !k,r,p. res = Correct((k,r,p)) =>
          (Safe(ki) => CTXT(ki,ad,p,c)) /\
          (Auth(ki) => CTXT(ki,ad,p,c))}
      
// CF 04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that RangeCipher depends on the TLS version too.
