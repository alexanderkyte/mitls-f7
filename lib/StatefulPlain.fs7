module StatefulPlain

(* 'plain' module for Stateful AEAD *) 

open Bytes
open TLSConstants
open TLSInfo
open Range

(* The record header includes the CT and the protocol version if > SSL3. *)

function val ADLength: epoch -> nat
private definition !e. 
    (EpochSI(e).protocol_version = SSL_3p0  /\ ADLength(e) = 1) \/
	(EpochSI(e).protocol_version <> SSL_3p0 /\ ADLength(e) = 3)
ask !e. 0 <= ADLength(e) // needed for parsing and not entailed by ADLength's type

type (;e:epoch) adata = (b:bytes){Length(b) = ADLength(e)} 

function val ADBytes: (epoch * ContentType) -> cbytes //(;e)StatefulPlain.adata
private definition !e,ct.
	( EpochSI(e).protocol_version = SSL_3p0 /\ 
            ADBytes(e,ct) = CTBytes(ct) ) \/
	( EpochSI(e).protocol_version <> SSL_3p0 /\
	    ADBytes(e,ct) = (CTBytes(ct) @| VersionBytes(EpochSI(e).protocol_version)))

function val ParseAD: (e:epoch * cbytes) -> ContentType
definition !b,e,ct. ParseAD(e,ADBytes(e,ct)) = ct

val makeAD:  e:succEpoch -> ct:ContentType -> ad:(;e)adata{B(ad)=ADBytes(e,ct)}
private val parseAD: e:succEpoch -> ad:(;e)adata -> ct:ContentType{ParseAD(e,B(ad))=ct}

private type (;e:epoch,ad:cbytes,r:range) fragment = {contents: (;e,ParseAD(e,ad),r)TLSFragment.fragment}

function val Payload: e:epoch * ad:cbytes * r:range * (;e,ad,r)fragment -> cbytes
private definition !e,ad,r,f.
        Payload(e,ad,r,f) = TLSFragment.Payload(e,ParseAD(e,ad),r,f.contents)


type (;e:epoch) prehistory = (ad:(;e)adata * r:range * f:(;e,B(ad),r)fragment) list

// The message sequence number (kept independently, as this is not ghost state)
function val HLength: e:epoch * (;e)prehistory -> nat
private definition !e.          HLength(e,[]) = 0
private definition !e,h,ad,r,f. HLength(e,(ad,r,f)::h) = HLength(e,h)+1

predicate StAEHistory of e:epoch * (;e)prehistory

type (;e:epoch)history = (sn:nat * ph:(;e)prehistory){sn = HLength(e,ph) /\ (Auth(e) => StAEHistory(e,ph))}
function val SeqN: e:epoch * (;e)history -> nat
definition !e,sn,h. SeqN(e,(sn,h)) = sn
function val EmptyHistory: e:epoch -> (;e) history
function val ExtendHistory: e:epoch * ad:(;e)adata * h:(;e) history * r:range * (;e,ad,r) fragment -> 'a //(;e)history
private definition !e. EmptyHistory(e) = (0,[])
private definition !e,n,h,d,r,f. ExtendHistory(e,d,(n,h),r,f) = (n+1,(d,r,f)::h)

predicate StAESent of e:epoch * ad:cbytes *  h:(;e)history * r:range * (;e,ad,r)fragment

private definition !e. StAEHistory(e,[])
private definition !e,ad,sn,h,r,f. StAEHistory(e,h) /\ StAESent(e,B(ad),(sn,h),r,f) => StAEHistory(e,(ad,r,f)::h)
//CF how do we prove this?
theorem !e,ad,sn,h,r,f. StAESent(e,B(ad),(sn,h),r,f) => (StAEHistory(e,h) /\ HLength(e,h) = sn)

function val StAEToRecord: e:epoch * ct:ContentType * r:range * f:(;e,ADBytes(e,ct),r)fragment -> 'a // (;e,ct,r)TLSFragment.fragment
private definition !e,ct,r,f. StAEToRecord(e,ct,r,f) = f.contents 
function val Multiplexed: e:epoch * (;e) history -> 'b //(;e)TLSFragment.history
definition !e. Multiplexed(e,EmptyHistory(e)) = TLSFragment.EmptyHistory(e)
(*
definition !e,ad,sh,sh',h,ct,r,f. 
  (sh' = ExtendHistory(e,ad,sh,r,f) /\
   ct = ParseAD(e,B(ad)) /\
//   B(ad) =  ADBytes(e,ct) /\
   h = Multiplexed(e,sh)) => 
  (Multiplexed(e,sh') = TLSFragment.ExtendHistory(e,ct,h,r,StAEToRecord(e,ct,r,f)))
  *)
definition !e,ad,sh,r,f. 
   Multiplexed(e,ExtendHistory(e,ad,sh,r,f)) = 
   TLSFragment.ExtendHistory(e,ParseAD(e,B(ad)),
                             Multiplexed(e,sh),
                             r,StAEToRecord(e,ParseAD(e,B(ad)),r,f))

private definition !e,ad,sh,r,f. 
	StAESent(e,ad,sh,r,f) <=> 
        TLSFragment.RecordSent(e,ParseAD(e,ad),Multiplexed(e,sh),r,f.contents)

//------------------------------------------------------------------------------------------------------
// `Plain' interface towards StatefulLHAE, encapsulating TLS-specific headers and content types
//------------------------------------------------------------------------------------------------------

type (;e:epoch,ad:(;e)adata,h:(;e)history,r:range) plain =
	f:(;e,B(ad),r)fragment{Auth(e) => StAESent(e,B(ad),h,r,f)}

val plain:        e:succEpoch{not Auth(e)} -> h:(;e)history -> ad:(;e)adata -> r:range -> b:(;r)rbytes -> p:(;e,ad,h,r) plain {B(b) = Payload(e,B(ad),r,p)}
val repr:         e:succEpoch{not Safe(e)} -> h:(;e)history -> ad:(;e)adata -> r:range -> p:(;e,ad,h,r) plain -> b:(;r)rbytes {B(b) = Payload(e,B(ad),r,p)}
val reprFragment: e:succEpoch{not Safe(e)} -> ad:(;e)adata -> r:range -> f:(;e,B(ad),r) fragment -> b:(;r)rbytes {B(b) = Payload(e,B(ad),r,f)}

val widen: e:succEpoch -> ad:(;e)adata -> r:range -> 
  f:(;e,B(ad),r) fragment -> 
  f':(;e,B(ad),RangeClass(e,r)) fragment{
    Payload(e,B(ad),r,f) = Payload(e,B(ad),RangeClass(e,r),f') /\
    !h. StAESent(e,B(ad),h,r,f) => StAESent(e,B(ad),h,RangeClass(e,r),f')}

//------------------------------------------------------------------------------------------------------
// `internal' interface towards TLSFragment
//------------------------------------------------------------------------------------------------------

val emptyHistory: e:epoch -> h:(;e)history{h = EmptyHistory(e)}
val extendHistory: e:epoch -> ad:(;e)adata ->
	h:(;e)history -> r:range -> f:(;e,ad,h,r)plain ->
	h':(;e)history{h' = ExtendHistory(e,ad,h,r,f)}

//------------------------------------------------------------------------------------------------------
// Auxiliary definitions for typing
//------------------------------------------------------------------------------------------------------

private val consHistory: e:epoch -> h:(;e)prehistory ->
	ad:(;e)adata -> r:range -> x:(;e,B(ad),r)fragment ->
	h':(;e)prehistory{h' = (ad,r,x)::h}

//CF Sent grows linearly
//CF assume !e.          Sent(e,(0,[]))
//CF assume !e,h,ad,r,x. Sent(e,ExtendHistory(e,h,ad,r,x)) => Sent(e,h)
//CF assume !e,ad,h,h',r,f. (Auth(e) /\ StAESent(e,ad,h,r,f) /\ StAESent(e,ad,h',r,f) /\ SeqN(e,h) = SeqN(e,h')) => h = h'

//CF usage? 
assume !e,ad,h,h',r,f. (Auth(e) /\ StAEHistory(e,h) /\ StAEHistory(e,h') /\ HLength(e,h) = HLength(e,h')) => h = h'

//CF usage? 
val RecordPlainToStAEPlain: e:succEpoch -> 
        ct:ContentType ->
        ad:(;e)adata{B(ad) = ADBytes(e,ct)}  -> 
        h:(;e) TLSFragment.history ->
	st:(;e) history{h = Multiplexed(e,st)} -> rg:range -> 
	f:(;e,ct,h,rg) TLSFragment.plain -> 
	sf:(;e,ad,st,rg) plain{f = StAEToRecord(e,ct,rg,sf)}

val StAEPlainToRecordPlain: e:succEpoch -> 
        ct:ContentType ->
        ad:(;e)adata{B(ad) = ADBytes(e,ct)} -> 
        h:(;e) TLSFragment.history ->
	st:(;e) history{h = Multiplexed(e,st)} -> rg:range -> 
        d:(;e,ad,st,rg) plain ->
	f:(;e,ct,h,rg) TLSFragment.plain{f=StAEToRecord(e,ct,rg,d)}
