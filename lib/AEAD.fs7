module AEAD

open Bytes
open Error
open TLSInfo

open TLSConstants

(* no need to be more precise on the length *)
type cipher = b:bytes{Length(b) <= max_TLSCipher_fragment_length}

private type (;ki:epoch) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO Define AEADSize. 
// TODO In the code, (AEADSize * 2) is computed in TLSConstants.getKeyExtensionLength

function val IVSize: epoch -> nat
val ivLength: e:succEpoch -> l:nat{l=IVSize(e)}
function val AEADSize: ki:epoch -> nat
private definition !ki,si. si = EpochSI(ki) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = HashSize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) ) /\
	( IsAEADCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = HashSize(TLSConstants.CipherSuiteMACAlg(si.cipher_suite)) +
					    EncKeySize(TLSConstants.CipherSuiteENCAlg(si.cipher_suite)) +
					    IVSize(ki) )

//CF '13 who wrote this? when? 
//TODO Why is this failing? Because of AEADSize not being what I want, I cannot typecheck COERCE.
//TODO ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => AEADSize(ki,ki) = HashSize(TLSConstants.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))

val GEN:    ki:succEpoch{Safe(ki)}     -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:succEpoch{not Auth(ki)} -> b:bytes{Length(b) = AEADSize(ki)} -> (;ki)AEADKey
val LEAK:   ki:succEpoch{not Auth(ki)} -> (;ki)AEADKey -> b:bytes

(* KB: 2/5. Partial implementation of CTXT in the code. *)
predicate val CTXT: 'a * 'b * 'c * 'd -> bool
predicate val NotCTXT: 'a * 'b * 'd -> bool
assume !ki,d,p,c. NotCTXT(ki,d,c) => not CTXT(ki,d,p,c)
assume !ki,d,p,p',c. (CTXT(ki,d,p,c) /\ CTXT(ki,d,p',c)) => p = p'
private val mteKey: ki:epoch -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) AEADKey

// Padding computations
private val blockAlignPadding: e:succEpoch -> nat -> nat

// Some trivial ranges
private assume !e,l.
	( IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/ CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128 ) =>
		Encode.CipherRange(e,(l,l),l+HashSize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)))
private val rangeCipher: e:succEpoch -> r:range -> tlen:nat{Encode.CipherRange(e,r,tlen) /\ tlen <= max_TLSCipher_fragment_length}
private val cipherRange: e:succEpoch -> tlen:nat{tlen <= max_TLSCipher_fragment_length} -> r:range{Encode.CipherRange(e,r,tlen)}

//FIXME: next two should be ask
private assume !e,si. si = EpochSI(e) =>
	( si.protocol_version = SSL_3p0 \/ si.protocol_version = TLS_1p0
		=> IVSize(e) = 0 ) /\
	( si.protocol_version = TLS_1p1 \/ si.protocol_version = TLS_1p2
		=> IVSize(e) = BlockSize(CipherSuiteENCAlg(si.cipher_suite)) )
private assume !e,si,tlen. si = EpochSI(e) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) => Encode.PlainLength(e,tlen) = tlen ) /\
    ( IsAEADCiphersuite(si.cipher_suite) /\ tlen >= IVSize(e) =>
	  Encode.PlainLength(e,tlen) = tlen - IVSize(e) )

// We have two variants for encryption and decryption: 
// the first (primed) is concrete; the second is idealized at safe indexes.

val encrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){Encode.CipherRange(ki,rg,Length(c))}

val encrypt : ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  rg:range -> p:(;ki,ad,rg) AEADPlain.plain ->
  ((;ki) AEADKey * c:cipher){Encode.CipherRange(ki,rg,Length(c)) /\
                             ((* Safe(ki) => *) CTXT(ki,ad,p,c))}

//CF unclear whether the log should include the plaintext; tried without, should rollback...
type entry = ki:succEpoch * ad:(;ki) AEADPlain.adata * c:ENC.cipher { ?p. CTXT(ki,ad,p,c) }
private val log: entry list ref
private val cmem: ki:succEpoch -> ad:(;ki)AEADPlain.adata -> c:cipher ->  
  entry list -> r:bool { r = true => ?p. CTXT(ki,ad,p,c) } 

private val honest: ki:succEpoch -> b:bool { b = true <=> Auth(ki) }

//CF a corollary of affine encryptions:
assume !ki,d,p0,p1,c. (CTXT(ki,d,p0,c) /\ CTXT(ki,d,p1,c)) => p0 = p1

val decrypt': ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {!k,r,p. res = Correct((k,r,p)) => Encode.CipherRange(ki,r,Length(c))}

val decrypt : ki:succEpoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.adata ->
  c:cipher -> res: 
  ( ((;ki) AEADKey *  rg:range * (;ki,ad,rg) AEADPlain.plain)) Result
   {(!k,r,p. res = Correct((k,r,p)) => Encode.CipherRange(ki,r,Length(c))) /\
    (Auth(ki) => 
        ((!k,r,p. res = Correct((k,r,p)) => CTXT(ki,ad,p,c)) /\
         (!p. CTXT(ki,ad,p,c) => (?k,r. res = Correct((k,r,p))))))}
// The last two lines are equivalent to (but easier to verify than)
// !p. CTXT(ki,ad,p,c) <=> (?k,r. res = Correct((k,r,p)))

(* CF 13-01-07 working notes 

There are several ideal properties of AEAD:

1. (When Safe:) filter out any cipher that is not an honest encryption---a.k.a "INT-CTXT" 
2. (When Safe:) additionally decrypt by table lookup---so that we can get plain secrecy by typing 
3. (When Auth:) filter out any (ki,plain,AD) forgery---aka "INT-PTXT" or "CMA" 

For F7 clarity, we distinguish several verification steps (using flags/Makefile):

1. (When Safe, decryption correctness:) decryptions of honest ciphers always succeed, returning the plaintext
   Together with CTXT & our "at most one encryption per AD" assumption, this justifies moving from 1 to 2.
   We might also explain it with a "Decryption error oracle". 

2. If we decrypt by table lookup, then, we implement parametric AEAD (to complete the Safe proof)
   this essentially rely on CPA of the underlying encryption.

3. (When Auth, irrespective of Safe & CTXT:) AEAD is PTXT wrt to some user-defined Msg property.

We need to agree e.g. that #if ideal refers to typechecking 2. 

The postcondition of decryption thus consists of

// proved in step 3, sufficient to retrieve Msg(ki,ad,p) as a predicate attached to the CTXT log
(Auth(ki) => ((!p. (?r. res = Correct(ki,r,p)) 
               <=> ( ?c. CTXT(ki,ad,p,c))))
/\
// a stronger "Safe" authentication property, which also yields Msg(ki,ad,p)
(Safe(ki) => ((!p. ( ?r. res = Correct(ki,r,p)) 
		       <=> ( CTXT(ki,ad,p,c)))           
/\
// a functional property
(Safe(ki) => ?p. res = Correct((ki,Range(ki,c),p))) \/ res = ConstantError)

--- The sequence of games is 

* indistinguishability of filtering out bad ciphers at safe indexes (by CTXT assumption) 
* indistinguishability of decryption by lookup at safe indexes (by matching its Correct & Error results) 
* secrecy by typing (CPA), relying on nested plains.
  for that step, we need to encapsulate Encode & Mac encryption processing into DataStream; 
  a generic pattern is (up to indexing)
  
  abstract_repr: delta -> high_bytes (within a range)
  abstract_map: (bytes -> bytes) -> high_bytes -> high_bytes (within computed range)

  a more specific approach is to idealize repr as max-sized-zero at safe indexes
  within encode (by ENC-CPA parametricity) then typecheck parametricy over delta.  

  
(independently:)

* CMA for Auth but not Safe.   

*)

(* CF 12-04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that CipherRange depends on the TLS version too.
*)
