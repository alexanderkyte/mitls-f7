module TLS

open Error
open Bytes
open AppConfig

// Remove the following types ASAP (i.e. when Dispatch.fs7 compiles)
type NetworkStream

type index
type range
type (;id:index) state
type parameters

type conn = Conn of (id:index * (;id) state)

predicate val TXT: index -> bool

function val Dual: index -> index

predicate val Fatal: (index * bytes) -> bool
predicate val Close: (index * bytes) -> bool
predicate val Write: (index * bytes) -> bool
predicate val Read : (index * bytes) -> bool

function val WrittenBytes: conn -> bytes
function val    ReadBytes: conn -> bytes

function val CID: conn -> index
assume !id, s. CID(Conn(id, s)) = id

function val Parameters: conn -> parameters 

val parameters: c:conn -> p:parameters {p = Parameters(c)}

type (;c:conn, rg:range) delta
type (;c:conn) query

predicate val Split :
    (rg0:range           * newrg:range                * rg:range *
     c  :conn            * newc :conn                 *
     d0 :(;c, rg0) delta * newd :(;newc, newrg) delta * d :(;c, rg) delta)
    -> bool

predicate val WriteExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val  ReadExtend : (c:conn * c':conn * rg:range * (;c, rg) delta) -> bool
predicate val    NoExtend : (c:conn * c':conn) -> bool

function val WriteBytes : conn -> bytes
function val  ReadBytes : conn -> bytes

function val DeltaBytes : (c:conn * rg:range * (;c, rg) delta) -> bytes

definition !c, c', rg, d. WriteExtend(c, c', rg, d) <=>
       WriteBytes(c') = WriteBytes(c) @| DeltaBytes(c, rg, d) 
    /\  ReadBytes(c') =  ReadBytes(c)
    /\ Parameters(c') = Parameters(c)

definition !c, c', rg, d. ReadExtend(c, c', rg, d) <=>
        ReadBytes(c') =  ReadBytes(c) @| DeltaBytes(c, rg, d)
    /\ WriteBytes(c') = WriteBytes(c)
    /\ Parameters(c') = Parameters(c)

definition !c, c'. NoExtend(c, c') <=>
        ReadBytes(c) =  ReadBytes(c')
    /\ WriteBytes(c) = WriteBytes(c')
    /\ Parameters(c) = Parameters(c')

type ioresult_o =
| IO_O_Error         of ErrorKind * ErrorCause
| IO_O_MustRead      of conn
| IO_O_WriteComplete of conn
| IO_O_WritePartial  of c:conn * rg:range * d:(;c, rg) delta

type ioresult_i =
| IO_I_Error         of ErrorKind * ErrorCause
| IO_I_Warning       of alertDescription
| IO_I_Fatal         of alertDescription
| IO_I_Read          of c:conn * rg:range * d:(;c, rg) delta
| IO_I_CertQuery     of c:conn * (;c) query
| IO_I_HandshakeDone of c:conn
| IO_I_Close

val null: index // NULL_NULL ciphersuite

// client-only; as is, must be followed by a read until Handshaken
val connect: NetworkStream -> p:parameters -> (c:conn { CID(c) = null /\ Parameters(c) = p }) Result
// server-only; as is, must be followed by a read until Handshaken
val accept:  NetworkStream -> p:parameters -> (c:conn { CID(c) = null /\ Parameters(c) = p }) Result

// On the write side, the following events may be generated:
// - Write(ki,WrittenBytes(c')) 
// - Close(ki,WrittenBytes(c))
val write: c:conn -> rg:range -> d:(;c, rg) delta ->
  obb:ioresult_o {
       !newc   . obb = IO_O_MustRead(newc) => (CID(c) = CID(newc) /\ NoExtend(c, newc))
    /\ !newc   . obb = IO_O_WriteComplete(newc) => (CID(c) = CID(newc) /\ WriteExtend(c, newc, rg, d))
    /\ !newc, newrg, newd.
	     obb = IO_O_WritePartial (newc, newrg, newd) => CID(c) = CID(newc) /\
	       ?d0, rg0.    WriteExtend(c, newc, rg0, d0)
	                 /\ Split(rg0, newrg, rg, c, newc, d0, newd, d)
    }

val read: c:conn ->
   obb:ioresult_i {
        !newc, a. obb = IO_I_Warning(newc, a)  =>
           TXT(CID(c)) => (CID(c) = CID(newc) /\ NoExtend(c, newc))

     /\ !e. obb = IO_I_Fatal(e) =>
           TXT(CID(c)) => (CID(c) = CID(newc) /\ Fatal(Dual(CID(c)), ReadBytes(c)))

     /\ obb = IO_I_Close => TXT(CID(c)) => Close(Dual(CID(c)), ReadBytes(c))

     /\ !newc, rg, d. obb = IO_I_Read(newc, rg, d) =>
	     CID(c) <> null
          /\ CID(c) = CID(newc)
          /\ ReadExtend(c, newc, rg, d)
          /\ TXT(CID(c)) => Write(Dual(CID(c)), ReadBytes(newc))

     /\ !newid, newc. obb = IO_I_HandshakeDone(newid, newc) =>
	       WrittenBytes(newc) = [||] /\ ReadBytes(newc) = [||]
   }

// ?non-blocking?
val rekey   : c:conn -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
val shutdown: c:conn -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
  
// [shutdown] will internally generate a Close(ki, WrittenBytes(c)) 
// Cannot write afterwards (dynamically enforced)

// we echo the query so that we have an explicit user decision to blame.
val authorize: c:conn -> (;c) query -> (c':conn { CID(c) = CID(c') /\ NoExtend(c, c') }) Result
val refuse:    c:conn -> (;c) query -> unit
