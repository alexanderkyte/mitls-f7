module Dispatch

open AppData
open Alert
open Data
open Formats
open Handshake
open Record
open Sessions
open Stream

type predispatchState =
  | Init
  | FirstHandshake
  | Finishing
  | Open
  | Closing
  | Closed

type dispatchState = ds:predispatchState{ds = Init \/ ds = FirstHandshake \/
                ds = Finishing \/ ds = Open \/ ds = Closing \/ ds = Closed}

type dState = {
    disp: dispatchState;
    conn: ConnectionState;
    }

type preConnection =
  {ds_info: SessionInfo;
   handshake: Handshake.hs_state;
   alert: Alert.al_state;
   appdata: AppData.app_state;
   read: dState;
   write: dState;}


predicate type preds =
	| DispSend of dState * ContentType * fragment
	| NoFrags of SessionInfo * ContentType * int * int
	| ContentMap of SessionInfo * ContentType * int * fragment * bytes
	| UpperProtoSend of SessionInfo * ContentType * bytes * Stream
        | ValidConnection of preConnection
	| DispState of dState
        | ReadState of dState
        | WriteState of dState

type Connection = c:preConnection{ValidConnection(c)}

val init :
  Tcp.NetworkStream ->
      r:role -> po:Handshake.protocolOptions{ po.minVer <> UnknownPV /\ po.maxVer <> UnknownPV} ->
      c:Connection{c.read.disp = Init /\ c.write.disp = Init}

val next_fragment :
        int -> c:Connection{c.write.disp <> Closed /\ 
	                    (?ct,n,f,outgone. ContentMap(c.write.conn.rec_info,ct,n,f,outgone))} ->
                ((bool * c':Connection{
                        ?f'. ContentMap(c.write.conn.rec_info,ct,c.write.conn.seq_num,f',Concat(outgone,f))}
                 )) Error_handling.Result

val max_TLSPlaintext_fragment_length : int
val fragmentLength : int

val sendNextFragments : Connection -> Connection Error_handling.Result

val deliver :
  Formats.ContentType ->
    Record.fragment -> c:Connection{c.read.disp <> Closed} -> (bool * Connection) Error_handling.Result

val readNextAppFragment : Connection -> Connection Error_handling.Result

(* Definition of ValidConnection, implicitly expressing all the found invariants *)
assume !c. ValidConnection(c) <=> 
  (ReadState(c.read) /\ 
   WriteState(c.write) /\
   HandshakeState(c.handshake) /\
   AlertState(c.alert) /\
   ApplicationState(c.appdata) /\
   c.ds_info = c.read.conn.rec_info /\
   c.ds_info = c.write.conn.rec_info /\
   c.ds_info = c.handshake.hs_info /\
   c.ds_info = c.alert.al_info /\
   c.ds_info = c.appdata.app_info
  )

(* ReadState and WriteState invariants *)
(* Which protocols can be sent in which dispatch states *)
assume !dstate,proto,f. DispSend(dstate,proto,f) <=> (
	((dstate.disp = Init \/ dstate.disp = FirstHandshake) /\
	        proto <> Application_data) \/
	(dstate.disp = Finishing /\
	        (proto = Handshake \/ proto = Alert)) \/
	(dstate.disp = Open) \/
	(dstate.disp = Closing /\ proto = Alert)
	)

(* Crypto state associated with each dispatch state *)
assume !dstate. DispState(dstate) <=> (
	((dstate.disp = Init \/ dstate.disp = FirstHandshake) =>
	 (dstate.conn.sparams.bulk_cipher_algorithm = BCA_null /\
	 dstate.conn.sparams.mac_algorithm = MA_null)) /\
	((dstate.disp = Finishing \/ dstate.disp = Open) =>
	 (dstate.conn.sparams.bulk_cipher_algorithm <> BCA_null /\
	 dstate.conn.sparams.mac_algorithm <> MA_null))
	)

(* Mapping protocol history to record seq_num *)
assume !info,ct,n,n'. n > n' => NoFrags(info,ct,n,n')
assume !cs,ct,ct',n',f. NoFrags(cs.ds_info,ct,cs.write.conn.seq_num+1,n') /\ FragmentSend(cs.write.conn.rec_info,cs.write.conn.seq_num,ct',f) /\ ct' <> ct /\ n' >= cs.write.conn.seq_num+1 =>
		NoFrags(cs.ds_info,ct,cs.write.conn.seq_num,n')

assume !cs,ct,f. FragmentSend(cs.write.conn.rec_info,cs.write.conn.seq_num,ct,f) /\ cs.write.conn.seq_num = 0 => ContentMap(c.write.conn.rec_info,ct,0,f,empty_Fifo)
assume !cs,ct,f. NoFrags(cs.ds_info,ct,0,cs.write.conn.seq_num-1) /\ FragmentSend(cs.write.conn.rec_info,cs.write.conn.seq_num,ct,f) => ContentMap(c.write.conn.rec_info,ct,cs.write.conn.seq_num,emptyFifo)
assume !cs,ct,f,f',n,outgone. ContentMap(c.write.conn.rec_info,ct,n,f,outgone) /\ NoFrags(c.write.conn.rec_info,ct,n+1,c.write.conn.seq_num-1) /\
			      FragmentSend(cs.write.conn.rec_info,cs.write.conn.seq_num,ct,f') =>
			         ContentMap(c.write.conn.rec_info,ct,c.write.conn.seq_num,f',Concat(outgone,f))

assume !read. ReadState(read) <=> 
    (RecvConnState(read.conn) /\ DispState(read))

assume !write. WriteState(write) <=> 
    (SendConnState(write.conn) /\ DispState(write))

assume !c,f,f',outgone,sn. ValidConnection(c) /\
	     DispSend(c.write,Application_data,f) /\
	     UpperProtoSend(c.ds_info,Application_data,f,(*FIXME*)f) /\
	     ContentMap(c.ds_info,Application_data,sn,f',outgone) /\
	     sn < c.write.conn.seq_num /\
	     NoFrags(c.ds_info,Application_data,sn+1,c.write.conn.seq_num-1) =>
               FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Application_data,f)

assume !c,f. ValidConnection(c) /\
	     DispSend(c.write,Handshake,f) /\
	     HandshakeFragmentSend(c.handshake.hs_info,f) /\
             Pub(f) =>
	       FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Handshake,f)

assume !c,f. ValidConnection(c) /\
	     DispSend(c.write,Change_cipher_spec,f) /\
	     HandshakeCCSSend(c.handshake.hs_info,f) /\
             Pub(f) =>
	       FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Change_cipher_spec,f)

assume !c,f. ValidConnection(c) /\
	     DispSend(c.write,Alert,f) /\
	     AlertFragmentSend(c.alert.al_info,f) /\
             Pub(f) =>
	       FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Alert,f)

(* ARCHIVE FOLLOWS: *)


(* ValidHSState and CCS invariants *)
(*
assume !hs,write. WriteState(write) => (ValidHSState(hs) <=> ( ValidHSDataOut(hs.hs_outgoing) /\
				       (write.conn.sparams.bulk_cipher_algorithm = BCA_null => Pub(hs.hs_outgoing) )))

assume !cs,ct,f. (SendConnState(cs) /\ ct = Handshake /\ ValidHSDataOut(f))
		    => FragmentSend(cs,ct,f)
*)
(* The following assume has to be proven by the Handhshake protocol. *)
(*
assume !hs,ccs,cp,info,pv,compr,sparams,mk,cstate. (hs.ccs_outgoing = Some((ccs,cp)) /\ cp = (info,pv,compr,sparams,mk,cstate)) => (pv <> UnknownPV /\
		(ValidStreamCipherSettings(ccs) \/ ValidBlockCipherSettings(ccs)))


assume !hs,ccs,cp,write. (WriteState(write) /\ hs.hs_outgoing = empty_bstr /\ hs.ccs_outgoing = Some((ccs,cp))) => (
		ValidHSState(hs) <=> (
			ValidHSDataOut(hs.hs_outgoing_after_ccs) /\ 
			ValidCCSDataOut(ccs) /\
			((write.disp = FirstHandshake /\ write.conn.sparams.bulk_cipher_algorithm = BCA_null /\ Pub(ccs)) \/
			( write.disp = Open /\ write.conn.sparams.bulk_cipher_algorithm <> BCA_null))
			
		))

assume !cs,ct,f. (SendConnState(cs) /\ ct = Change_cipher_spec /\ ValidCCSDataOut(f))
		    => FragmentSend(cs,ct,f)
*)        
(* FIXME: This should happen only after ccs has been sent!
			And the fact that the counter restarts (modeled in send_setCrypto) should break the stream property (not modeled) *)
(* Valid Alert state invariants *)
(*
assume !alstate,write. WriteState(write) => (ValidAlState(alstate) <=> (ValidAlDataOut(alstate.al_outgoing) /\ Pub(alstate.al_outgoing)))

assume !cs,ct,f. (SendConnState(cs) /\ ct = Alert /\ ValidAlDataOut(f))
		    => FragmentSend(cs,ct,f)
*)
(* FIXME: Next assumption is cheating *) 
(* ValidAppstate invariants *)
(*
assume !appstate,write. (WriteState(write) /\ write.disp = Open) => (ValidAppState(appstate) <=>
ValidAppDataOut(appstate.app_outgoing))

assume !cs,ct,f. (SendConnState(cs) /\ ct = Application_data /\ ValidAppDataOut(f))
		    => FragmentSend(cs,ct,f)
*)
(* Distributivity of concat *)
(*
assume !d,f,rem. IsConcat(d,f,rem) /\ ValidAppDataOut(d) => ValidAppDataOut(f) /\ ValidAppDataOut(rem)
assume !d,f,rem. IsConcat(d,f,rem) /\ ValidHSDataOut(d) => ValidHSDataOut(f) /\ ValidHSDataOut(rem)
assume !d,f,rem. IsConcat(d,f,rem) /\ ValidAlDataOut(d) => ValidAlDataOut(f) /\ ValidAlDataOut(rem)
*)
