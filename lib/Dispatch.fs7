module Dispatch

open AppData
open Alert
open Data
open Formats
open Handshake
open Record
open Sessions
open Stream
open AppCommon
open Error_handling
open Bytearray

type predispatchState =
  | Init
  | FirstHandshake
  | Finishing
  | Finished
  | Open
  | Closing
  | Closed

type dispatchState = ds:predispatchState{ds = Init \/ ds = FirstHandshake \/
                ds = Finishing \/ ds = Finished \/ ds = Open \/ ds = Closing \/ ds = Closed}

type dState = {
    disp: dispatchState;
    conn: ConnectionState;
    }

type preConnection =
  {ds_info: SessionInfo;
   handshake: Handshake.hs_state;
   alert: Alert.al_state;
   appdata: AppData.app_state;
   read: dState;
   write: dState}


predicate type preds =
	| DispSend of dState * ContentType
	| ContentMap of SessionInfo * int * ContentType * bytes
        | ValidConnection of preConnection
	| DispInv of dState
	| DispRead of dState
	| DispReadBlockProposed of ConnectionState
	| DispReadStreamProposed of ConnectionState
	| DispReadBlockConfirmed of ConnectionState
	| DispReadStreamConfirmed of ConnectionState
	| DispWrite of dState
	| DispWriteBlockProposed of ConnectionState
	| DispWriteStreamProposed of ConnectionState
	| DispWriteBlockConfirmed of ConnectionState
	| DispWriteStreamConfirmed of ConnectionState


type Connection = c:preConnection{ValidConnection(c)}

val init :
  Tcp.NetworkStream ->
      r:role -> po:protocolOptions{ po.minVer <> UnknownPV /\ po.maxVer <> UnknownPV} ->
      c:Connection{c.read.disp = Init /\ c.write.disp = Init}

val resume: Tcp.NetworkStream -> role -> SessionInfo -> protocolOptions{ po.minVer <> UnknownPV /\ po.maxVer <> UnknownPV} ->
        c:Connection{c.read.disp = Init /\ c.write.disp = Init}

val ask_rehandshake: Connection -> protocolOptions -> Connection

val ask_rekey: Connection -> protocolOptions -> Connection

val ask_hs_request: Connection -> protocolOptions -> Connection

val appDataAvailable: Connection -> bool
val getSessionInfo: Connection -> SessionInfo

val moveToOpenState: c:Connection{c.read.disp = Finishing /\ TLSConfirmedMKey(c.read.conn.mk,OtherRole(c.read.conn.rec_info)) /\
	(!sk,iv. c.read.conn.cipher_state = BlockCipherState(sk,iv) => TLSConfirmedSKey(sk,OtherRole(c.read.conn.rec_info))) /\
	(c.write.disp = Finishing \/ c.write.disp = Finished) /\
	TLSConfirmedMKey(c.write.conn.mk,c.write.conn.rec_info) /\
	(!sk,iv. c.write.conn.cipher_state = BlockCipherState(sk,iv) => TLSConfirmedSKey(sk,c.write.conn.rec_info))} ->
	s:SessionInfo{c.read.conn.rec_info = s /\ c.write.conn.rec_info = s} -> c':Connection{c'.write.disp = Open /\ c'.read.disp = Open}

val next_fragment :
        int ->  c:Connection{c.write.disp <> Closed} -> 
                ((bool Error_handling.Result) * c':Connection)
                (* maybe say that c' = IncSeqNum(c) ? *)

val sendNextFragments : Connection -> (unit Error_handling.Result) * Connection

val deliver :
  Formats.ContentType ->
    Record.fragment -> c:Connection{c.read.disp <> Closed} -> (bool Error_handling.Result) * Connection

val readNextAppFragment : Connection -> (unit Error_handling.Result) * Connection

val writeOneAppFragment: Connection -> bytes -> ((bytes * bytes) Result) * Connection

val readOneAppFragment: Connection -> int -> (bytes Result) * Connection

(* Definition of ValidConnection, implicitly expressing all the found invariants *)
assume !c. ValidConnection(c) <=> 
  (DispRead(c.read) /\
   DispWrite(c.write) /\
   HandshakeState(c.handshake) /\
   AlertState(c.alert) /\
   ApplicationState(c.appdata) /\
   c.ds_info = c.handshake.hs_info /\
   c.ds_info = c.alert.al_info /\
   c.ds_info = c.appdata.app_info /\
   ( c.write.disp = Open =>
	c.ds_info = c.write.conn.rec_info ) /\
   ( c.read.disp = Open =>
	c.ds_info = c.read.conn.rec_info ) /\
    ContentMap(c.write.conn.rec_info,c.write.conn.seq_num,Application_data,PreviouslyRead(c.appdata.app_outgoing)) /\
    (ContentMap(OtherRole(c.read.conn.rec_info),c.read.conn.seq_num,Application_data,StreamBytes(c.appdata.app_incoming)) \/
	 Crypto.Pub_k(c.read.conn.mk) )

(* Similarly for HS, Alert:
   ContentMap(c.ds_info,Handshake,c.write.conn.seq_num,PreviouslyRead(c.handshake.hs_outgoing)) /\
   ContentMap(c.ds_info,Alert,c.write.conn.seq_num,PreviouslyRead(c.alert.al_outgoing)) /\
*)
  )

(* Invariants on the Dispatch automaton *)
assume !dstate. DispInv(dstate) <=> (
	((dstate.disp = Init \/ dstate.disp = FirstHandshake) =>
	 (dstate.conn.sparams.bulk_cipher_algorithm = BCA_null /\
	 dstate.conn.sparams.mac_algorithm = MA_null)) /\
	((dstate.disp = Finishing \/ dstate.disp = Finished \/ dstate.disp = Open) =>
	 (dstate.conn.sparams.bulk_cipher_algorithm <> BCA_null /\
	 dstate.conn.sparams.mac_algorithm <> MA_null))
	)

assume !read. DispRead(read) <=> (
                RecvConnState(read.conn) /\
                DispInv(read) /\
                (read.disp = Finishing => (DispReadBlockProposed(read.conn) \/ DispReadStreamProposed(read.conn))) /\
                (read.disp = Open => (DispReadBlockConfirmed(read.conn) \/ DispReadStreamConfirmed(read.conn)))
                )

assume !recv. DispReadBlockProposed(recv) <=> (
                        TLSProposedMKey(recv.mk,OtherRole(recv.rec_info)) /\
                        (?sk,iv. recv.cipher_state = BlockCipherState(sk,iv) /\
                         TLSProposedSKey(sk,OtherRole(recv.rec_info)))
                        )

assume !recv. DispReadStreamProposed(recv) <=> (
                        TLSProposedMKey(recv.mk,OtherRole(recv.rec_info)) /\
                        recv.cipher_state = StreamCipherState )

assume !recv. DispReadBlockConfirmed(recv) <=> (
                        TLSConfirmedMKey(recv.mk,OtherRole(recv.rec_info)) /\
                        (?sk,iv. recv.cipher_state = BlockCipherState(sk,iv) /\
                         TLSConfirmedSKey(sk,OtherRole(recv.rec_info)))
                        )

assume !recv. DispReadStreamConfirmed(recv) <=> (
                        TLSConfirmedMKey(recv.mk,OtherRole(recv.rec_info)) /\
                        recv.cipher_state = StreamCipherState )

assume !write. DispWrite(write) <=> (
                SendConnState(write.conn) /\
                DispInv(write) /\
                ((write.disp = Finishing \/ write.disp = Finished) => (DispWriteBlockProposed(write.conn) \/ DispWriteStreamProposed(write.conn))) /\
                (write.disp = Open => (DispWriteBlockConfirmed(write.conn) \/ DispWriteStreamConfirmed(write.conn)))
                )

assume !send. DispWriteBlockProposed(send) <=> (
                        TLSProposedMKey(send.mk,send.rec_info) /\
                        (?sk,iv. send.cipher_state = BlockCipherState(sk,iv) /\
                         TLSProposedSKey(sk,send.rec_info))
                        )

assume !send. DispWriteStreamProposed(send) <=> (
                        TLSProposedMKey(send.mk,send.rec_info) /\
                        send.cipher_state = StreamCipherState )

assume !send. DispWriteBlockConfirmed(send) <=> (
                        TLSConfirmedMKey(send.mk,send.rec_info) /\
                        (?sk,iv. send.cipher_state = BlockCipherState(sk,iv) /\
                         TLSConfirmedSKey(sk,send.rec_info))
                        )

assume !send. DispWriteStreamConfirmed(send) <=> (
                        TLSConfirmedMKey(send.mk,send.rec_info) /\
                        send.cipher_state = StreamCipherState )          

(* Which protocols can be sent in which dispatch states *)
assume !dstate,proto. DispSend(dstate,proto) <=> (
	((dstate.disp = Init \/ dstate.disp = FirstHandshake) /\
	        proto <> Application_data) \/
	(dstate.disp = Finishing /\
	        (proto = Handshake \/ proto = Alert)) \/
	(dstate.disp = Open) \/
	(dstate.disp = Closing /\ proto = Alert)
	)


assume !c,protocol,s,f.
             ValidConnection(c) /\
             DispSend(c.write,protocol) /\
	     UpperProtoSend(c.ds_info,protocol,f) => 
               FragmentSend(c.ds_info,c.write.conn.seq_num,protocol,f)

theorem !i,n,p,f. FragmentSend(i,n,p,f) => (?c. ValidConnection(c) /\ DispSend(c.write,p) /\
                                            UpperProtoSend(c.ds_info,p,f) /\
                                            i = c.ds_info /\ n = c.write.conn.seq_num)

(* On the receive side, we need something:
ask !c,p,f. ValidConnection(c) /\ FragmentSend(c.ds_info,c.read.conn.seq_num,p,f) =>
            (.....)
*)

(* By linearity *)
theorem !i,n,p,f,p',f'. FragmentSend(i,n,p,f) /\ FragmentSend(i,n,p',f') => (p = p' /\ f = f')

assume !i,ct. ContentMap(i,0,ct,empty_bstr)
assume !i,n,ct,h,f. ContentMap(i,n,ct,h) /\ FragmentSend(i,n,ct,f) =>
                   ContentMap(i,n+1,ct,AppendBytes(h,f))
assume !i,n,ct,h,ct',f. ContentMap(i,n,ct,h) /\ FragmentSend(i,n,ct',f) /\ ct <> ct' =>
                   ContentMap(i,n+1,ct,h)

ask !c,f,c'. ContentMap(c.write.conn.rec_info,c.write.conn.seq_num,Application_data,PreviouslyRead(c.appdata.app_outgoing)) /\
             FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Application_data,f) /\
             c'.write.conn.rec_info = c.write.conn.rec_info /\ c'.write.conn.seq_num = c.write.conn.seq_num + 1 /\
             PreviouslyRead(c'.appdata.app_outgoing) = AppendBytes(PreviouslyRead(c.appdata.app_outgoing),f) =>
                ContentMap(c'.write.conn.rec_info,c'.write.conn.seq_num,Application_data,PreviouslyRead(c'.appdata.app_outgoing))

ask !conn,conn',sk,iv,iv'. conn.cipher_state = BlockCipherState(sk,iv) /\ conn' = UpdateIV(conn,iv') => conn'.cipher_state = BlockCipherState(sk,iv')
(* FIXME: next assume should be an ask, but it's failing *)
assume !write,write',iv. DispWrite(write) /\ write'.disp = write.disp /\ write'.conn = IncSeqNum(UpdateIV(write.conn,iv)) => DispWrite(write')

ask !c,f,iv,c'. ValidConnection(c) /\ c.write.disp = Open /\ c'.ds_info = c.ds_info /\ c'.handshake = c.handshake /\ c'.alert = c.alert /\ c'.read = c.read /\
                c'.write.conn = IncSeqNum(UpdateIV(c.write.conn,iv)) /\ c'.write.disp = c.write.disp /\
                ApplicationState(c'.appdata) /\ c'.appdata.app_info = c.appdata.app_info /\ c'.appdata.app_incoming = c.appdata.app_incoming /\
                FragmentSend(c.write.conn.rec_info,c.write.conn.seq_num,Application_data,f) /\
                PreviouslyRead(c'.appdata.app_outgoing) = AppendBytes(PreviouslyRead(c.appdata.app_outgoing),f) =>
                        ValidConnection(c')
