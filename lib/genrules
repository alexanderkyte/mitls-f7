#! /usr/bin/env python

# --------------------------------------------------------------------
import sys, os, re, time, xml.etree.ElementTree as etree

# --------------------------------------------------------------------
MSBUILD = 'http://schemas.microsoft.com/developer/msbuild/2003'

MKHEADER = '''\
include ../Makefile.config

lib7     = ../../../lib/fs7-interfaces/
libperv  = $(lib7)pervasives.fs7 $(lib7)tuples.fs7
lperv    = -pervasives $(lib7)pervasives.fs7 -tuples $(lib7)tuples.fs7
libfs7   = $(lib7)pi.fs7 $(lib7)formulas.fs7
f7flags += -timeout 1 --define avoid --define verify --define ideal --verbose -nokindcheck $(lperv) $(libfs7)

.PHONY: default clean

-include Makefile.tc7

default: \
Error.tc7 \
Nonce.tc7 \
TLSInfo.tc7 \
DataStream.tc7 \
AppFragment.tc7 \
HSFragment.tc7 \
TLSFragment.tc7 \
StatefulPlain.tc7 \
AEADPlain.tc7 \
AEAD.tc7 \
StatefulAEAD.tc7 \
Record.tc7

# pending: TLSConstants.tc7 Range.tc7 RSAKeys.tc7 Encode.tc7 AppData.tc7 Alert.tc7 Dispatch.tc7 TLS.tc7
# trusted: Bytes.tc7 DER.tc7 Tcp.tc7 DHGroup.tc7 HASH.tc7 ENC.tc7

clean:
	rm -f *.smp *.tc7
'''

# --------------------------------------------------------------------
class Object(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)

# --------------------------------------------------------------------
def _options(args):
    from optparse import OptionParser

    parser = OptionParser(usage = "%prog: [options] file.fsproj")
    parser.add_option('-e', None,
                      action = 'store_true',
                      dest   = 'doparse',
                      help   = 'Parse .fs7 to obtain more fine grain dependencies')

    options, args = parser.parse_args(args)

    if len(args) != 1:
        parser.error('exactly one .fsproj file must be given')

    options.fsproj = args[0]

    return options


# --------------------------------------------------------------------
class TopoSortCycleException(Exception):
    pass

def topoiter1(D, k, sk, seen = None):
    seen = dict() if seen is None else seen
    flag = seen.get(k, 0)

    if flag < 0:
        print [k] + sk
        raise TopoSortCycleException()
    if flag > 0:
        return

    seen[k] = -1
    for x in D.get(k, []):
        for y in topoiter1(D, x, [k] + sk, seen):
            yield y
    seen[k] = 1

    yield k

def topoiter(D):
    seen = dict()
    for k in D.iterkeys():
        for x in topoiter1(D, k, [], seen):
            yield x

# --------------------------------------------------------------------
class FS7Deps(object):
    @staticmethod
    def by_compilation_order(files):
        return [ \
            (files[i], ['%s.fs7' % (x,) for x in files[:i]]) \
                for i in xrange(len(files))
        ]

    @staticmethod
    def by_parsing(srcdir, files):
        srcfiles = dict([(x.lower(), x) for x in os.listdir(srcdir)])
        lowfiles = [x.lower() for x in files]
        alldeps  = dict()

        for name in files:
            modules  = set()

            for ext in ['.fs', '.fsi', '.fs7']:
                contents = open(srcfiles[name.lower() + ext], 'r').read()
                contents = re.sub(r'\(\*(?:.|\r|\n)*?\*\)', '', contents, 0)
                contents = re.sub(r'".*?"', '', contents)
                contents = contents.splitlines()
                contents = [re.sub(r'//.*', '', x) for x in contents]
                contents = [re.sub(r'\s+', ' ', x.strip()) for x in contents]
    
                for line in contents:
                    m = re.search(r'^open (\w+)', line)
                    if m is not None:
                        modules.add(m.group(1).lower())
                    else:
                        for m in re.finditer(r'(\w+?)\.\w+', line):
                            modules.add(m.group(1).lower())

            alldeps[name.lower()] = modules.intersection(lowfiles)

        for name in topoiter(alldeps):
            for d in set(alldeps[name]): # copy
                alldeps[name].update(alldeps[d])

        # Reorder using user ordering
        for name in alldeps.iterkeys():
            alldeps[name] = [x for x in lowfiles if x in alldeps[name]]
        alldeps = [(x, alldeps[x]) for x in lowfiles if x in alldeps]

        # Go back to FS name (with correct case)
        def _norm(x, y):
            realname = os.path.splitext(srcfiles[x + '.fs7'])[0]
            realdeps = [srcfiles[z + '.fs7'] for z in y]
            return (realname, realdeps)

        return [_norm(x, y) for (x, y) in alldeps]

# --------------------------------------------------------------------
def _main():
    options = _options(sys.argv[1:])

    with open(options.fsproj, 'r') as stream:
        doc = etree.parse(stream)

    files  = doc.findall('.//{0}ItemGroup/*'.format('{%s}' % (MSBUILD,)))
    files  = [x.get('Include') for x in files if x.get('Include') is not None]
    files  = [x for x in files if os.path.splitext(x)[1] == '.fs7']
    files  = [os.path.splitext(x)[0] for x in files]
    srcdir = os.path.dirname(options.fsproj) or os.path.curdir

    if options.doparse:
        fs7deps = FS7Deps.by_parsing(srcdir, files)
    else:
        fs7deps = FS7Deps.by_compilation_order(files)

    print "# -*- Makefile -*-"
    print "# Automatically generated by: %s" % (' '.join(sys.argv),)
    print "# Generated on %s" % (time.ctime(),)
    print
    print MKHEADER
    print "# ----- BEGIN AUTO FS7 -----"
    for name, deps in fs7deps:
        fargs = dict(name = name, mod = name.lower(), deps = ' '.join(deps))
        print '%(name)s.tc7: $(libperv) $(libfs7) %(deps)s %(name)s.fs7 %(name)s.fs %(name)s.fs7' % fargs
        print '\t$(f7) $(f7flags) -scripts %(name)s %(deps)s %(name)s.fs7 %(name)s.fs' % fargs
        print '\t@touch $@'
        print
    print "# ----- END AUTO FS7 -----"

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()

