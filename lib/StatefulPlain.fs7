module StatefulPlain
open Bytes
open Formats
open TLSInfo
open DataStream
open AEADPlain

type (;ki:KeyInfo) data = (b:bytes){Length(b) = AEPlain.ADLength(ki,ki) - 8}


private type (;ki:KeyInfo)prehistory =
	| Empty
	| ConsHistory of h:(;ki)prehistory * ad:(;ki)data * r:range * x:(;ki,r)Fragment.fragment //{Fragment(ki,h,ad,r,x)}

function val HLength: ki:KeyInfo * (;ki)prehistory -> nat
private assume !ki. HLength(ki,Empty) = 0
private assume !ki,h,ad,r,x. HLength(ki,ConsHistory(h,ad,r,x)) = HLength(ki,h)+1

predicate type preds = History of ki:KeyInfo * ( nat * (;ki)prehistory )

// History and seqn are bijective
assume !ki,h,h',sn. History(ki,(sn,h)) /\ History(ki,(sn,h')) => h = h'
assume !ki. History(ki,(0,Empty))

private type (;ki:KeyInfo)history = (sn:nat * h:(;ki)prehistory){History(ki,(sn,h)) /\ sn = HLength(ki,h)}

function val SeqN: ki:KeyInfo * (;ki)history -> nat
private assume !ki,sn,h. SeqN(ki,(sn,h)) = sn

predicate Fragment of ki:KeyInfo * (;ki)history * (;ki)data * r:range * (;ki,r)Fragment.fragment

private type (;ki:KeyInfo,h:(;ki)history,ad:(;ki)data,r:range) prefragment =
	x:(;ki,r)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,r,x)}

private type (;ki:KeyInfo,h:(;ki)history,ad:(;ki)data,r:range) fragment =
	{contents: (;ki,h,ad,r)prefragment}

val emptyHistory: ki:KeyInfo -> h:(;ki)history{SeqN(ki,h) = 0}
private val consHistory: ki:KeyInfo -> h:(;ki)prehistory ->
	ad:(;ki)data -> r:range -> x:(;ki,r)Fragment.fragment -> 
        h':(;ki)prehistory{h' = ConsHistory(h,ad,r,x)}
// This function will assume History
val addToHistory: ki:KeyInfo -> h:(;ki)history ->
	ad:(;ki)data -> r:range -> x:(;ki,h,ad,r)fragment ->
	h':(;ki)history{SeqN(ki,h') = SeqN(ki,h)+1}

function val MakeAD:  ki:KeyInfo * (;ki)history * (;ki)data -> bytes//(;ki)AEADPlain.data
assume !ki,h,ad. MakeAD(ki,h,ad) = IntBytes(8,SeqN(ki,h)) @| ad

val makeAD:  ki:KeyInfo -> h:(;ki)history -> ad:(;ki)data ->
	b:(;ki)AEADPlain.data{b=MakeAD(ki,h,ad)}

val fragment: ki:KeyInfo{not Auth(ki)} -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;r)rbytes -> (;ki,h,ad,r) fragment
val repr: ki:KeyInfo{not Auth(ki)} -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r) fragment -> (;r)rbytes

val contents:  ki:KeyInfo -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r)fragment ->
	x:(;ki,r)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,r,x)}
val construct: ki:KeyInfo -> h:(;ki)history -> ad:(;ki)data -> r:range ->
	x:(;ki,r)Fragment.fragment{Auth(ki) => Fragment(ki,h,ad,r,x)} -> (;ki,h,ad,r)fragment

val FragmentToAEADPlain: ki:KeyInfo -> h:(;ki)history -> ad:(;ki)data -> r:range -> (;ki,h,ad,r)fragment ->
	(;ki,r,MakeAD(ki,h,ad))AEADPlain

val AEADPlainToFragment: ki:KeyInfo -> h:(;ki)history -> ad:(;ki)data -> r:range ->
	(;ki,r,MakeAD(ki,h,ad))AEADPlain -> (;ki,h,ad,r)fragment

assume !ki,ad,r,x. AEADSays(ki,r,ad,x) <=> ?h,ad'. ad = MakeAD(ki,h,ad') /\ History(ki,h) /\ Fragment(ki,h,ad',r,x)

ask !ki,ad,h,ad',r,x. ad = MakeAD(ki,h,ad') /\ History(ki,h) /\ Fragment(ki,h,ad',r,x) => AEADSays(ki,r,ad,x)
