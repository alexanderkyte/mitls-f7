module TLSPlain

open TLSInfo

type Lengths (* abstractly, a list of desired ciphertext lengths *)
predicate val Head: Lengths -> int
predicate val Tail: Lengths -> Lengths
predicate val Cons: int -> Lengths -> Lengths

(* Secret App Data *)
type (;ki:KeyInfo,l:Lengths) appdata

type (;ki:KeyInfo,n:int) fragment

val concat_fragment_appdata: ki:KeyInfo -> n:int -> (;ki,n) fragment -> l:Lengths -> (;ki,l) appdata -> (;ki,Cons(n,l)) appdata

val app_fragment: ki:KeyInfo -> l:Lengths -> x:(;ki,l) appdata ->  ((n:int{n=Head(l)} * f:(;ki,n) fragment) * 
								    (t:Length{t=Tail(l)} * (;ki,t) appdata))

val pub_fragment: ki:KeyInfo -> b:bytes -> ((n:int * (;ki,n) fragment) * bytes) (* Note that n is *not* the length of the plaintext, it is the length of the target ciphertext *)

type (;ki:KeyInfo) mac

type (;ki:KeyInfo,n:int) plain

val concat_fragment_mac: ki:KeyInfo -> n:int -> (;ki,n) fragment -> (;ki) mac -> (;ki,n) plain

val split_mac: ki:KeyInfo -> n:int -> (;ki,n) plain -> ((;ki,n) fragment * (;ki) mac)
