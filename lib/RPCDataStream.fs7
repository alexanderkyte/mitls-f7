module RPCDataStream
open TLSInfo
open Bytes
open Error

/// Some TLS constants (relocate?)
private val max_TLSPlaintext_fragment_length: nat
private val max_TLSCompressed_fragment_length: nat
private val fragmentLength: nat
val max_TLSCipher_fragment_length: nat

/// Ranges of lengths for byte arrays
type range = low:nat * high:nat { low <= high }
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   
function val Sum: range * range -> range
private assume !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val rangeSum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}
val min: a:int -> b:int -> c:int{(a<=b /\ c=a) \/ (a>b /\ c=b)}
val max: a:int -> b:int -> c:int{(a>=b /\ c=a) \/ (a<b /\ c=b)}
val splitRange: ki:epoch -> r:range -> (r0:range * r1:range){r = Sum(r0,r1)} 

/// Messages
(*
val msglen : i:int{i > 0}
private type msg = b:bytes{length(b) = msglen}
*)

private type (;ki:epoch) stream = {sb:bytes list}

predicate Request  of epoch * bytes
predicate Response of epoch * bytes * bytes

(*
private type (;ki:epoch, h:(;ki)stream, r:range) delta = {
  contents: b:(;r) rbytes(*{
       (?rq     . Request(ki, rq) /\ (?s . rq = h @| b @| s))
	\/ (?rq, rp . Request(ki, rq) /\ Response(ki, rq, rp) /\ (?s . rp = h @| b @| s))
	\/ (not Auth(ki))
  }
}
*)

private function val BytesLstToBytes: (bytes list) -> bytes

private assume BytesLstToBytes([]) = [||]
private assume !hd, tl . BytesLstToBytes(hd :: tl) = BytesLstToBytes(tl) @| hd

function val StreamToBytes: ki:epoch * (;ki) stream -> bytes

assume !ki, h. StreamToBytes(ki, h) = BytesLstToBytes(h.sb)

val byteslst_to_bytes: bs:(bytes list) -> b:bytes{BytesLstToBytes(bs) = b}

val stream_to_bytes: ki:epoch -> h:(;ki) stream -> b:bytes{StreamToBytes(ki, h) = b}

private type (;ki:epoch, h:(;ki)stream, r:range) delta = {
  contents: b:(;r) rbytes{
       (?rq . Request(ki, rq) /\ (?s . rq = StreamToBytes(ki, h) @| b @| s))
	\/ (?rq, rp . Request(ki, rq) /\ Response(ki, rq, rp) /\ (?s . rp = StreamToBytes(ki, h) @| b @| s))
	\/ not Auth(ki)
  }
}

predicate EmptyStream of ki:epoch * (;ki) stream 
// function val EmptyStream:  ki:epoch -> (;ki) stream
// AP: F7 issue with records as single argument of a function. Do not use this function, use the predicate instead.
function val ExtendStream: 'a * 'b * 'c * 'd -> 'e
assume !ki,s. EmptyStream(ki,s) <=> s = {sb = [] }
assume !ki,s,r,d. ExtendStream(ki,s,r,d) = {sb = d.contents :: s.sb } 
ask !ki,s,s'. EmptyStream(ki,s) /\ EmptyStream(ki,s') => s = s'

val deltaPlain: 
  ki:epoch{not Auth(ki)} -> s:(;ki) stream -> r:range -> 
  b:(;r) rbytes -> c: (;ki,s,r) delta

val deltaRepr: 
  ki:epoch{not Safe(ki)} -> s:(;ki) stream -> r:range -> 
  c: (;ki,s,r) delta -> (;r) rbytes

val split: ki:epoch -> s:(;ki) stream -> 
  r0:range -> r1:range -> d:(;ki,s,Sum(r0,r1)) delta -> 
  (d0:(;ki,s,r0) delta * d1:(;ki,ExtendStream(ki,s,r0,d0),r1) delta)
