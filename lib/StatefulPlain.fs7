module StatefulPlain
open TLSInfo
open TLSFragment
open DataStream
open Error
open Bytes
open Formats
open CipherSuites

type (;ki:KeyInfo) data = (b:bytes){Length(b) = TLSFragment.ADLength(ki) - 8}

type (;ki:KeyInfo)history =
	| Empty
	| ConsHistory of h:(;ki)history * ad:data * r:range * (;ki,r)sbytes

val emptyHistory: ki:KeyInfo -> h:(;ki)history{h = Empty}
// This function will assume History, or it might avoid if we have some
// Multiplexed predicate coming from above...
val addToHistory: ki:KeyInfo -> h:(;ki)history -> ad:data -> r:range -> x:(;ki,r)sbytes ->
	h':(;ki)history{h' = ConsHistory(h,ad,r,x)}

// Let's make a predicate of these definitions: ValidMultiplexing(h,ss),
// where h is history, and ss is TLSFragment.history (should we call it "streams" to avoid confusion?)
function val ValidMultiplexing: history * TLSFragment.history -> bool
function val History: KeyInfo * nat * history -> bool
assume !ki. History(ki,0,Empty) <=> ?ss. (Multiplexed(ki,ss) /\ EmptyStreams(ss))
assume !ki,sn,ct,f.
	?h,r. History(ki,sn,ConsHistory(h,ADBytes(ki,ct),r,f)) <=>
	?ss. Multiplexed(ki,ConsStream(ki,ct,ss,f)) // FIXME: glitch on ranges: should be !r

function val SeqN: history -> nat
assume SeqN(Empty) = 0
assume !ki,h,ad,r,x. SeqN(ConsHistory(h,ad,r,x)) = SeqN(h)+1

type (;ki:KeyInfo,h:history,ad:data,r:range)fragment =
	x:(;ki,r)sbytes {Safe(ki) => History(ki,SeqN(h)+1,ConsHistory(h,ad,r,x))}

//val addFragment: ki:KeyInfo -> seqn:nat -> h:(;ki)history{History(ki,seqn,h)} -> ad:data -> r:range -> f:(;ki,h,ad,r) fragment ->
//			     seqn':nat * h': (;ki)history{History(ki,seqn',h')} // History(ki,seqn',h') will be assumed by this function

val fragment: ki:KeyInfo{not Safe(ki)} -> h:(;ki)history -> ad:data -> r:range -> bytes -> (;ki,h,ad,r) fragment
val repr: ki:KeyInfo{not Safe(ki)} -> h:(;ki)history -> ad:data -> r:range -> (;ki,h,ad,r) fragment -> bytes

val TLSFragmentToFragment: ki:KeyInfo -> ct:ContentType ->
	h:(;ki)history -> ss:(;ki)TLSFragment.history{ValidMultiplexing(h,ss)} -> r:range ->
	(;ki,ct,ss,r)TLSFragment.fragment -> (;ki,h,ADBytes(ki,ct),r)fragment

val fragmentToTLSFragment: ki:KeyInfo -> ct:ContentType ->
	h:(;ki)history -> ss:(;ki)TLSFragment.history{ValidMultiplexing(h,ss)} -> r:range ->
	(;ki,h,ADBytes(ki,ct),r)fragment -> (;ki,ct,ss,r)TLSFragment.fragment

function val MakeAD:  nat * data -> bytes
assume !sn,ad. MakeAD(sn,ad) = IntBytes(8,sn) @| ad

val makeAD:  ki:KeyInfo -> sn:nat -> ad:(;ki)data ->
	b:bytes{b=MakeAD(sn,ad) /\ Length(b) = TLSFragment.ADLength(ki)}
val parseAD: ki:KeyInfo -> b:bytes{Length(b) = TLSFragment.ADLength(ki)} ->
	(sn:nat * ad:(;ki)data){b=MakeAD(sn,ad)}