module AppFragment
open Bytes
open TLSInfo
open Range
open DataStream
open Error
open TLSError

(* Application fragments are defined from DataStream as triples (e,s,d) 
   where e is an epoch, s is a stream, and d is a delta indexed by them. 
   We also set up predicates & functions to re-index with/without e & s. *) 

//CF an event recording every honest fragment creation, 
//CF assumed in fragment and used to define Sent. 
//MK as it is used to define Sent below, maybe DeltaSent would be a better name?
//MK could it be defined in DataStream? 
//MK maybe not, would it be sufficient to have a Sent event for fragments?
predicate DeltaFragment of e:epoch * s:(;e) stream * r:range * (;e,s,r)delta

private type (;i:id,r:range) preFragment = 
  {frag: (e:epoch * s:(;e)stream * d:(;e,s,r) delta{ i = Id(e) /\ 
              (Auth(e) => DeltaFragment(e,s,r,d))}) }

predicate IsFragment of i:id * r:range * (;i,r)preFragment
private definition !e,r,f. IsFragment(Id(e),r,f) <=> (?s,d. f.frag = (e,s,d))

type (;i:id,r:range) fragment = f:(;i,r)preFragment{IsFragment(i,r,f)}

predicate Sent of e:epoch * (;e) stream * r:range * (;Id(e),r)fragment
(* The following definition guarantees that for authentic appdata fragements (Sent)
   the epoch and stream within the fragment is consistent with the Sent predicate *)

private definition !e,s,r,f. Sent(e,s,r,f) <=> 
        (?d,r. f.frag = (e,s,d) /\ DeltaFragment(e,s,r,d)) 

ask !e,s,r,f. Sent(e,s,r,f) => (?d. f.frag = (e,s,d))


type (;e:epoch,s:(;e)stream,r:range) plain = f:(;Id(e),r) fragment{Auth(e) => Sent(e,s,r,f)}

function val Payload: i:id * r:range * (;i,r)fragment -> cbytes
private definition !e,r,s,d. Payload(Id(e),r,{frag = (e,s,d)}) = DataStream.Payload(e,s,r,d)

(* KB: The definition below is intentional.
       The ghost epoch and stream inside the frag       
       are irrelevant, since we will prove they are
       the same as the ones outside using Sent. *)

function val Extend: epoch * 'b * range * 'd -> 'e
private definition !e,s,r,f,e',s',d. 
  f.frag = (e',s',d) =>   
  Extend(e,s,r,f) = DataStream.ExtendStreamDelta(e,s,r,d)

//CF i.e. Extend(e,s,r,{frag = (e',s',d)}) = DataStream.ExtendStreamDelta(e,s,r,d)

ask !e,r,f,s,d. (IsFragment(Id(e),r,f) /\ Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d) ) => Extend(e,s,r,f) = DataStream.ExtendStreamDelta(e,s,r,d)

(* AP: No longer used:
// conversion with application-level deltas 
predicate FragOfDelta of e:epoch * r:range * (;Id(e),r)fragment * s:(;e)stream * (;e,s,r)delta
private definition !e,r,f,s,d.
	FragOfDelta(e,r,f,s,d) <=> f = {frag = (e,s,d)}

ask !e,r,f,s,d. FragOfDelta(e,r,f,s,d) => Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d)
ask !e,r,f,s,d. FragOfDelta(e,r,f,s,d) => Extend(e,s,r,f) = ExtendStreamDelta(e,s,r,d)
*)

val fragment: e:epoch -> s:(;e) stream -> r:range ->
  d:(;e,s,r) delta -> 
  f:(;Id(e),r) fragment * s':(;e) stream 
  {Sent(e,s,r,f) /\ s' = Extend(e,s,r,f) /\ Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d)}

val delta: e:epoch -> s:(;e) stream -> r:range -> 
  f:(;Id(e),r) fragment{AuthId(Id(e)) => Sent(e,s,r,f)} ->  
  // Note: AuthId, not Auth, so Dispatch can only call delta in the Open state
  // To make this more explicity, we could replace the above precondition by: 
  // Open(e) /\ (Auth(e) => Sent(e,s,r,f)) 
  d:(;e,s,r) delta * s':(;e) stream{s' = Extend(e,s,r,f)  /\ Payload(Id(e),r,f) = DataStream.Payload(e,s,r,d)}

// conditional fragment abstraction 

val plain: i:id{not AuthId(i)} -> r:range -> 
  b:(;r) rbytes -> f:(;i,r) fragment{B(b) = Payload(i,r,f)}

val repr:  i:id{not SafeId(i)} -> r:range -> 
  f:(;i,r) fragment -> b:(;r) rbytes{B(b) = Payload(i,r,f)}

val makeExtPad:  i:id -> r:range -> f:(;i,r)fragment -> f':(;i,r)fragment{f'=f}
val parseExtPad: i:id -> r:range -> f:(;i,r)fragment -> res:((f':(;i,r)fragment{f'=f}) Result){?f. res = Correct(f)}

// We use this function for ideal decryption by table lookup,
// as the range after decryption is usually wider than the one used for encryption.
// (Note that by design the encryption ranges are *not* authenticated).

val widen: i:id -> r0:range -> f0:(;i,r0)fragment -> 
    f1:(;i,RangeClass(i,r0))fragment{
    Payload(i,r0,f0) = Payload(i,RangeClass(i,r0),f1) /\
    !e,s. Sent(e,s,r0,f0) => Sent(e,s,RangeClass(i,r0),f1)}


(* CF unused...
// injectivity of data-fragment (follows from linearity of streams)
private theorem !e,s,r1,r2,f1,f2. 
  Auth(e) /\ 
  DeltaFragment(e,s,r1,f1) /\ 
  DeltaFragment(e,s,r2,f2) => (f1 = f2)
*)


 

