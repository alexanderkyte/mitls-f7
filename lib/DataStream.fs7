module DataStream
open TLSInfo
open Bytes
open Error

type range = l:nat * h:nat { l <= h } (* length range *)
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   

// The global plain used everywhere
// AP Maybe this is useless, and we could just keep all plains as bytes, and make them abstract
private type (;ki:KeyInfo,r:range) sbytes = {secb:(;r)rbytes}

function val Sum: range * range -> range
assume !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val rangeSum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}

private type (;ki:KeyInfo) stream = {sb:bytes}

function val Before: KeyInfo * stream * range * sbytes -> bool

private type (;ki:KeyInfo, before: (;ki) stream, r:range) delta = x:(;ki,r) sbytes{Before(ki,before,r,x)}

val init: ki:KeyInfo -> s:(;ki) stream{s.sb = [| |]}

function val ConcatStream: KeyInfo * stream * delta -> stream
assume !ki,s,d. ConcatStream(ki,s,d) = {sb = s.sb @| d.secb}

val append: 
  ki:KeyInfo -> s: (;ki) stream -> r:range ->
  d:(;ki,s,r) delta -> s':(;ki) stream{s'.sb = s.sb @| d.secb}

val split: ki:KeyInfo -> s:(;ki) stream -> 
  r0:range -> r1:range -> d:(;ki,s,Sum(r0,r1)) delta -> 
  (d0:(;ki,s,r0) delta * d1:(;ki,{sb = s.sb @| d0.secb},r1) delta)

val join: ki:KeyInfo -> s:(;ki) stream -> 
  r0:range -> d0:(;ki,s,r0) delta -> 
  r1:range -> d1:(;ki,{sb = s.sb @| d0.secb},r1) delta -> (;ki,s,Sum(r0,r1)) delta

// Plain and repr for the sbytes type.
// These are the "base" plain/repr functions used by all other plains,
// which build on top of sbytes
val plain: ki:KeyInfo{not Safe(ki)} -> r:range -> (;r)rbytes -> x:(;ki,r)sbytes
val repr:  ki:KeyInfo{not Safe(ki)} -> r:range -> x:(;ki,r)sbytes -> (;r)rbytes

// Plain/repr for "delta" (built on top of the base ones)
val delta: 
  ki:KeyInfo{not Safe(ki)} -> s:(;ki) stream -> r:range -> b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaRepr: 
  ki:KeyInfo{not Safe(ki)} -> s:(;ki) stream -> r:range -> c: (;ki,s,r) delta -> (;r) rbytes

