module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites
open DataStream

// Plain type for Dispatch and Record
type (;ki:KeyInfo) history = {
  handshake: (;ki) HandshakePlain.stream;
  alert: (;ki) AlertPlain.stream;
  ccs: (;ki) HandshakePlain.stream;
  appdata: (;ki) AppDataStream.stream;
  }
and (;ki:KeyInfo,ct:ContentType,h:(;ki) history,rg:range) fragment =
    | FHandshake of (;ki,h.handshake,rg)HandshakePlain.fragment    {ct=Formats.Handshake}
    | FCCS       of (;ki,h.ccs,rg)HandshakePlain.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of (;ki,h.alert,rg)AlertPlain.fragment        {ct=Alert}
    | FAppData   of (;ki,h.appdata,rg)AppDataStream.fragment {ct=Application_data}

// FIXME: Circular dependency!
// predicate Multiplexed of KeyInfo * StatefulPlain.history * HandshakePlain.stream * HandshakePlain.stream * AlertPlain.stream * AppDataStream.stream 
// assume !ki,fs,hs,ccs,al,ad. Multiplexed(ki,fs,hs,ccs,al,ad) <=>
//   ((fs = [] /\ 
//    HandshakePlain.EmptyStream(ki,hs) /\
//    HandshakePlain.EmptyStream(ki,ccs) /\
//    AlertPlain.EmptyStream(ki,al) /\
//    AppDataStream.EmptyStream(ki,ad)) \/
//   (?ct,h0,rg,f,t. fs = (ct,h0,rg,f)::t /\
//       (?hs'. ct = Formats.Handshake /\
// 	  HandshakePlain.ConcatStream(ki,hs',f,hs) /\
// 	  Multiplexed(ki,t,hs',ccs,al,ad)) \/
//       (?ccs'. ct = Formats.Change_cipher_spec /\
// 	  HandshakePlain.ConcatStream(ki,ccs',f,ccs) /\
// 	  Multiplexed(ki,t,hs,ccs',al,ad)) \/
//       (?al'. ct = Formats.Alert /\
// 	  AlertPlain.ConcatStream(ki,al',f,al) /\
// 	  Multiplexed(ki,t,hs,ccs,al',ad)) \/
//       (?ad'. ct = Formats.Application_data /\
// 	  AppDataStream.ConcatStream(ki,ad',f,ad) /\
// 	  Multiplexed(ki,t,hs,ccs,al,ad'))))
// 
// type (;ki:KeyInfo) shistory = (h:(;ki) history){Multiplexed(ki,h.log,h.handshake,h.ccs,h.alert,h.appdata)}


predicate Fragment of KeyInfo * range * int * ContentType * bytes

val TLSFragmentRepr: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;ki,ct,h,rg)fragment -> bytes

val TLSFragment: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  bytes -> (;ki,ct,h,rg)fragment 

function val ADLength: KeyInfo -> int
assume !ki. (ki.sinfo.protocol_version = SSL_3p0 /\ ADLength(ki) = 9) \/
	(ki.sinfo.protocol_version <> SSL_3p0 /\ ADLength(ki) = 11)

// Additional Data
type (;ki:KeyInfo) addData = (b:bytes){Length(b) = ADLength(ki) - 8}

function val ADBytes: (KeyInfo * ContentType) -> bytes
assume !ki,ct.
	( ki.sinfo.protocol_version = SSL_3p0 /\
	  ADBytes(ki,ct) =
		CTBytes(ct) ) \/
	( ki.sinfo.protocol_version <> SSL_3p0 /\
          ADBytes(ki,ct) =
		(CTBytes(ct) @| VersionBytes(ki.sinfo.protocol_version)))

ask !ki,ct. Length(ADBytes(ki,ct)) = (ADLength(ki) - 8)

private val makeAD: ki:KeyInfo -> ct:ContentType ->
	  ad: (;ki)addData{ad=ADBytes(ki,ct)}

private val parseAD: ki:KeyInfo -> 
          ad: (;ki)addData -> 
          ct:ContentType{ad=ADBytes(ki,ct)}




