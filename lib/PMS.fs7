module PMS 

(* pre-master-secrets, for RSA-based and DH-based key exchanges *) 
(* (this used to be part of CRE) *)

open Bytes
open TLSConstants


(** RSA ciphersuites **) 

// ``These parameters can encrypt HonestRSAPMSs.''
//CF unclear why we need this intermediate predicate
predicate SafeRSAPMS of RSAKey.pk * ProtocolVersion 
definition !pk,cv. SafeRSAPMS(pk,cv) <=> RSAKey.Honest(pk) 

// In this file RSA refers to any crypto materials used for the RSA KEX. 

// representation of PMS as RSA plaintexts.
type rsarepr = (;48)lbytes
//CF we considered indexing it by cv & refining with ?b. it = VersionBytes(cv) @| b  

//#begin-abstractionRSA
(* private , only shared with CRE *) 
type rsaseed = {seed:rsarepr} 

// We have two layers of abstraction:
// - rsaseed, treated abstractly almost everywhere in this module & CRE 
//   we could use a separate agile PRF module & assumption
// - rsapms, treated abstractly outside this module & CRE
//   so that we can control their usage for the RSA-PMS assumption.

type (;pk:RSAKey.pk, cv:ProtocolVersion) rsapms = 
   | IdealRSAPMS    of s:rsaseed {SafeRSAPMS(pk,cv)} // used only ideally & for abstract pms values 
   | ConcreteRSAPMS of rsarepr
// pattern matching is used in this module & in CRE only for specifying ideal code
// so we also define ideal predicate & test for the module users:
predicate HonestRSAPMS of pk:RSAKey.pk * cv:ProtocolVersion * (;pk,cv)rsapms
private definition !pk,cv,pms. 
  HonestRSAPMS(pk,cv,pms) <=> (SafeRSAPMS(pk,cv) /\ ?s. pms = IdealRSAPMS(s))

ask !pk,cv,s. not(HonestRSAPMS(pk,cv,ConcreteRSAPMS(s)))

val honestRSAPMS: pk:RSAKey.pk -> cv:ProtocolVersion -> pms: (;pk,cv) rsapms -> 
  b:bool { b=true <=> HonestRSAPMS(pk,cv,pms) } 

//CF UNUSED. to be deleted.
// abstract postcondition of RSA encryption (event) 
predicate EncryptedRSAPMS of pk:RSAKey.pk * cv:ProtocolVersion * (;pk,cv)rsapms * bytes

//CF see SafeRSAPMS in TLSInfo
//CF we get it as a runtime invariant, from the refinement of IdeaRSAPMS
private ask !pk,cv,pms. 
  HonestRSAPMS(pk,cv,pms) => SafeRSAPMS(pk,cv) 

val genRSA: pk:RSAKey.pk -> cv:ProtocolVersion -> 
  pms:(;pk,cv)rsapms { SafeRSAPMS(pk,cv) <=> HonestRSAPMS(pk,cv,pms) } 

val coerceRSA: pk:RSAKey.pk -> cv:ProtocolVersion -> rsarepr -> (;pk,cv)rsapms
// unrestricted; we actually always get a ConcreteRSAPMS

val leakRSA: 
  pk:RSAKey.pk -> cv:ProtocolVersion -> 
  pms:(;pk,cv)rsapms {not HonestRSAPMS(pk,cv,pms)} -> rsarepr
// used for concrete RSA encryption 
//#end-abstractionRSA



open DHGroup

//MK SafeDHPMS is much more specific involving the contributions to the pms. This is probably by necessity.
predicate SafeDHPMS of p:DHGroup.p * (;p)DHGroup.g * (;p)DHGroup.elt * (;p)DHGroup.elt // The DH parameters, generator, and gx and gy values yield a good dhpms

//#begin-abstractionDH

type dhrepr = bytes

(* private , only shared with CRE *)  
type dhseed = {seed:dhrepr} // treated abstractly almost everywhere in this file
// - dhpms, treated abstractly outside this module & CRE
//   so that we can control their usage for the DH-PMS assumption.
type (;p:p, g:(;p) g, gx:(;p) elt, gy:(;p) elt) dhpms =   
   | IdealDHPMS    of dhseed 
   | ConcreteDHPMS of dhrepr



predicate HonestDHPMS of p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms

private definition !p,g,gx,gy,pms. HonestDHPMS(p,g,gx,gy,pms) <=> ?s. pms = IdealDHPMS(s)

val honestDHPMS: p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt -> pms: (;p,g,gx,gy) dhpms -> b:bool { b=true <=> HonestDHPMS(p,g,gx,gy,pms) } 

val sampleDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt ->  (;p,g,gx,gy) dhpms
val coerceDH:   p:p -> g:(;p)g -> gx:(;p)elt -> gy:(;p)elt {not SafeDHPMS(p,g,gx,gy)}-> (;p)elt -> (;p,g,gx,gy) dhpms
//#end-abstractionDH


// multiplexing the PMS representations

type pms = 
  | RSAPMS of pk:RSAKey.pk * cv:ProtocolVersion * (;pk,cv)rsapms
  | DHPMS of p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * (;p,g,gx,gy) dhpms

//TODO consider adding HonestPMS as HonestRSAPMS \/ HonestDHPMS.

//CF val todo: string -> 'a { false }
