module RSAKey

(* This module is not typechecked *)

// This module defines RSA keys
// but not their use for public-key encryption: see RSA
// (We use two modules to break a circular dependency)

open Bytes

type sk (* secret (decryption) key, abstract *)
type pk (* public (encryption) key, abstract but bytes are accessible *)

type modulus  = bytes
type exponent = bytes

val honest: pk -> bool

(* Used in specifications *)
function val PK: sk -> pk
predicate Honest of pk

val gen: unit -> p:pk * s:sk {p = PK(s)}

val pkey: CoreACiphers.pk -> pk
val pkey_repr:  pk -> CoreACiphers.pk

val coerce: p:pk {not Honest(p)} -> CoreACiphers.sk -> s:sk{p = PK(s)}
val leak:   s:sk {not Honest(PK(s))} -> CoreACiphers.sk


(* TODO: to be adjusted depending on the compromise model in Cert
val create_rsapkey : modulus * exponent -> pk
val create_rsaskey : modulus * exponent -> sk
*)
// TODO (* Commented out because they depend on core ciphers,
// TODO    and they are never used in ideal TLS crypto *)
// TODO val repr_of_rsapkey : pk -> CoreACiphers.pk
// TODO val repr_of_rsaskey : sk -> CoreACiphers.sk
val repr_of_rsapkey : pk -> CoreACiphers.pk
val repr_of_rsaskey : sk -> CoreACiphers.sk
