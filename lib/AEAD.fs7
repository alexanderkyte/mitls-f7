module AEAD

open Bytes
open Error
open DataStream
open TLSInfo
open CipherSuites
open Algorithms
// open AEADPlain (* parameter *) // Do not open, or AEADPlain "module" and AEADPlain "function" will clash. We should stop using the same name for modules, types and functions, as this creates names clashes everywhere!

type cipher = b:bytes{Length(b) <= DataStream.max_TLSCipher_fragment_length}

private type (;ki:epoch) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  | GCM of ke:(;ki:AENC.state)  *)

// TODO: Define AEADSize. 
// In the code, (AEADSize * 2) is computed in CipherSuites.getKeyExtensionLength

function val AEADSize: ki:epoch -> nat
private assume !ki,si. si = EpochSI(ki) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(CipherSuites.CipherSuiteMACAlg(si.cipher_suite)) ) /\
	( IsAEADCiphersuite(si.cipher_suite) =>
	  AEADSize(ki) = MacKeySize(CipherSuites.CipherSuiteMACAlg(si.cipher_suite)) +
					    EncKeySize(CipherSuites.CipherSuiteENCAlg(si.cipher_suite)) +
					    AEPlain.IVSize(ki) )

// Why is this failing? Because of AEADSize not being what I want, I cannot typecheck COERCE.
//ask !ki. IsOnlyMACCiphersuite(EpochSI(ki).cipher_suite) => AEADSize(ki,ki) = MacKeySize(CipherSuites.CipherSuiteMACAlg(EpochSI(ki).cipher_suite))

val GEN:    ki:epoch{Safe(ki)} -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:epoch{not Auth(ki)} -> b:bytes{Length(b) = AEADSize(ki)} -> (;ki)AEADKey
val LEAK:   ki:epoch{not Auth(ki)} -> (;ki)AEADKey -> b:bytes

(* KB: 18/4. Define CTXT or assume in code? The following assume is a stop-gap *)
predicate CTXT of ki:epoch * (;ki)AEADPlain.data * r:range * (;ki,r)Fragment.fragment * cipher
private assume !ki,ad,r,f,c. CTXT(ki,ad,r,f,c)

private val mteKey: ki:epoch -> (;ki) MAC.key -> (;ki) ENC.state -> (;ki) AEADKey

val encrypt: ki:epoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.data ->
  rg:range -> p:(;ki,rg,ad) AEADPlain.AEADPlain ->
  ((;ki) AEADKey * c:cipher){Length(c)=AEPlain.RangeCipher(ki,rg) /\ CTXT(ki,ad,rg,AEADPlain.AEADContents(p),c)}

val decrypt: ki:epoch -> (;ki) AEADKey -> ad:(;ki)AEADPlain.data ->
  c:cipher -> res: 
  ( ((;ki) AEADKey * rg:range * (;ki,rg,ad) AEADPlain.AEADPlain){Length(c) = AEPlain.RangeCipher(ki,rg)}) Result{
    !k,r,p. res = Correct((k,r,p)) =>
          (Safe(ki) => CTXT(ki,ad,r,AEADPlain.AEADContents(p),c)) /\
          (Auth(ki) => CTXT(ki,ad,r,AEADPlain.AEADContents(p),c))}
 
// CF 04-09 discussion points: 
//
// plaintext integrity follows from abstraction:
// - a precondition for coercing to  (;ki,rg,ad) plain is that ki is un-Auth
// - a precondition for leaking from (;ki,rg,ad) plain is that ki is un-Safe
//
// additionally, the decryption refinement guarantees 
// functional correctness & ciphertext integrity
// 
// CTXT(ki,ad,p,c) is a runtime event recorded by encrypt, stating
// "c is a correct encryption for ki, ad, some rg, and p 
//
// the range for encryption is not recorded in CTXT,
// (as indeed only the secret length is authenticated, not the range).
//
// our interface is compatible with state for the underlying encryption
// (but does not rely on it); this is convenient for RC4, for IVs in old TLS
//
// how do we deal with corrupted peers? 
// why do we have two cases? I propose instead:
//
// Auth(ki) => 
// ( !p. res = Correct(CipherRange(ki,c),p) <=> CTXT(ki,ad,p,c) )
//
// We are still in-between encryptor/decryptor and keys, why? 
// Are TLS 1.0 IVs now part of the mutable key? 
// Note that RangeCipher depends on the TLS version too.
