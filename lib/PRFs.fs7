module PRFs

open Bytes
open Formats
open TLSInfo
open RSA
open Error

(*---------------------*)
(* Plain module for RSA *)
type (;si:SessionInfo) preMasterSecret
(* TODO: this only works for RSA, when client arbitrarily chooses PMS. A different interface is required for DH *)
(* Note: we need an external version type, and not the one contained in the session info. This is because
   we need to use the highest client supported version type, and not the negotiated one, to avoid version rollback attacks. *)
(* Client side: use genPMS and rsaEncryptPMS separately, by now. No idea yet on how to do it computationally-friendly *)
val genPMS: si:SessionInfo -> CipherSuites.ProtocolVersion -> (;si)preMasterSecret
val empty_pms: si:SessionInfo -> (;si)preMasterSecret (* Used to implement a dummy DH key exchange *)
(*---------------------*)
val rsaEncryptPMS: si:SessionInfo -> asymKey -> (;si)preMasterSecret -> bytes Result
(* Server side: embed RSA decryiption and some sanity checks. Again, fully flexibility in making this computationally-friendly *)
(* should be: rsaDecryptPMS *)
val getPMS: si:SessionInfo -> CipherSuites.ProtocolVersion ->
        bool -> (* Whether we should check protocol version in old TLS versions *)
        Certificate.cert -> 
         bytes -> (;si)preMasterSecret (* No Result type: in case of error, we return random value *)
(*---------------------*)




(*----------------------*)
(* Plain for KDF/PRF *)
type (;si:SessionInfo) masterSecret
val empty_masterSecret: si:SessionInfo ->  (;si) masterSecret
(* ------------------- *)
val prfMS: si:SessionInfo -> (;si) preMasterSecret ->
           (* No label, it's hardcoded. Of course we can make it explicit -> *)
           (* No seed (crandom @| srandom), it can be retrieved from SessionInfo -> *)
           (;si) masterSecret (* of length 48 *)
(* ------------------- *)
(* PRF: for finished messages, needs refinement. Like a MAC *)
val prfVerifyData: si:SessionInfo -> r:Role -> (;si) masterSecret ->
                   bytes (* msgLog *) -> 
                   bytes (* length depends on cs, 12 by default *)

(* KDF *)
type (;ci:ConnectionInfo) keyBlob
val prfKeyExp: ci:ConnectionInfo -> (;EpochSI(ci.id_out))masterSecret ->
               (* No label, it's hardcoded. Of course we can make it explicit -> *)
               (* No seed (crandom @| srandom), it can be retrieved from epoch (and not SessionInfo!) -> *)
               (;ci)keyBlob (* length depends on cs *)

val splitStates: ci:ConnectionInfo -> (;ci)keyBlob -> ((;ci.id_out)StatefulAEAD.state * (;ci.id_in)StatefulAEAD.state)

val makeTimestamp: unit -> int
