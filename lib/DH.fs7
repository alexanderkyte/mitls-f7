module DH

open Bytes
open DHGroup

// marks "Honest" exponentials generated using genKey (or serverGen)
predicate type predHE = HonestExponential of dhp:dhparams * gx:(;dhp) elt
private val honest: dhp:dhparams -> e:(;dhp) elt -> b:bool{b = true <=> HonestExponential(dhp,e)}

//#begin-abstraction
private type (dhp:dhparams, gx:(;dhp)elt) secret = Key of bytes 
//#end-abstraction

// We maintain 2 logs:
// - a log of honest gx and gy values
// - a log for looking up honest pms values using gx and gy values

// Any parameters returned by the Core modules are taken from the trusted DHDB,
// which only contains good parameters.

type honest_entry = (dhp:dhparams * (;dhp) elt)
private val honest_log: (honest_entry list) ref

type entry = dhp:dhparams * gx:(;dhp) elt * gy:(;dhp) elt * pms:(;dhp.p, dhp.g, gx, gy) PMS.dhpms{PMS.HonestDHPMS(dhp.p,dhp.g,gx,gy,pms)}
private val log: entry list ref 

private val assoc: dhp:dhparams -> gx:(;dhp)elt -> gy:(;dhp)elt -> entry list -> pmsoption:(;dhp.p, dhp.g, gx, gy) PMS.dhpms option{!pms. pmsoption=Some(pms) => PMS.HonestDHPMS(dhp.p,dhp.g,gx,gy,pms)}


definition !dhp,gx,gy. PMS.SafeDH(dhp.p,dhp.g,gx,gy) <=> HonestExponential(dhp,gx) /\ HonestExponential(dhp,gy) /\ PP(dhp)
//SZ Check if we can remove these queries; unless we want to keep them as documentation or sanity checks
ask !dhp,gx,gy. not HonestExponential(dhp,gx) => not PMS.SafeDH(dhp.p,dhp.g,gx,gy)
ask !dhp,gx,gy. not HonestExponential(dhp,gy) => not PMS.SafeDH(dhp.p,dhp.g,gx,gy) 
ask !dhp,gx,gy. not PP(dhp) => not PMS.SafeDH(dhp.p,dhp.g,gx,gy) 
val safeDH: dhp:dhparams -> gx:(;dhp)elt -> gy:(;dhp)elt -> b:bool { b=true <=> PMS.SafeDH(dhp.p,dhp.g,gx,gy) }


val leak  : dhp:dhparams -> gx:(;dhp)elt -> x:(;dhp,gx)secret{not HonestExponential(dhp,gx)} -> bytes
val coerce: dhp:dhparams -> gx:(;dhp)elt{not HonestExponential(dhp,gx)} -> b:bytes -> x:(;dhp,gx)secret

val genKey: dhp:dhparams -> gx:(;dhp)elt * (;dhp,gx) secret{HonestExponential(dhp,gx)}

    
val serverGen: unit -> (p:p * g:(;p) g * gs:(;p,g) elt * (;p,g,gs) secret{PP(p,g) /\ HonestExponential(p,g,gs)})

val clientGenExp: p:p -> g:(;p) g -> gs:(;p,g) elt 
				      -> (gc:(;p,g) elt * (;p,g,gc) secret * res:(;p,g,gs,gc) PMS.dhpms)
					     {HonestExponential(p,g,gc) /\ ((HonestExponential(p,g,gs) /\ PP(p,g)) => PMS.HonestDHPMS(p,g,gs,gc,res))}

val serverExp: p:p -> g:(;p) g{PP(p,g)} -> gs:(;p,g) elt{HonestExponential(p,g,gs)} -> gc:(;p,g) elt -> s:(;p,g,gs) secret 
				   -> res:(;p,g,gs,gc) PMS.dhpms{HonestExponential(p,g,gc) => PMS.HonestDHPMS(p,g,gs,gc,res)}
