module TLSPlain

// Abstract types for the secret payloads of the record layer. 

// TODO:
// - reconcile with streams, understand what the multi-message model is
// - when do we deliver messages to receiving applications?
// - add support to carry authentication from appdata to fragment and back
// - compare with game-based definitions [Ristenpart etc] 

open TLSInfo 
// nothing else? pls document dependencies at the beginning of files.

// No need for abstraction? This is public.
// The head of the list is sent before the tail
// We need to reorder: we split from the beginning but concat at the end of the buffer.

type Lengths (* abstractly, a list of desired ciphertext lengths *)
predicate val Head: Lengths -> int
predicate val Tail: Lengths -> Lengths
predicate val Cons: (int * Lengths) -> Lengths

// the second parameter n is the net data size
predicate val CompatibleLengths: (SessionInfo * int * Lengths) -> bool
val estimateLengths: si:SessionInfo -> n:int -> l:Lengths{CompatibleLengths(si,n,l)}
// We could also use something like:
// val provisionLength: ki:KeyInfo -> min:int -> max:int -> 
//   ls:Lengths{ !n. min <= n /\ n < max => CompatibleLengths(ki,n,ls) }   
// ...and more generally let the application add data to the outgoing buffer. 

// Don't we need a CompatibleLength for individual fragments as well?
// or is this part of the type abstraction? 

// We should check that as a special case we can do minimal padding 
// and reveal the length of every appdata message

// Usage?
// FIXME: AP: we don't use 'n' in the fsi interface. Can we get rid of it here, that would simplify implementation
private val fragmentSize: si:SessionInfo -> ls:Lengths -> 
  n:int{CompatibleLengths(si,n,ls)} -> f:int{CompatibleLengths(si,n-f,Tail(ls))}

(* Secret App Data *)

// Application-level data, intuitively a whole message. 
// how does this relates to streams? 
type (;si:SessionInfo,ls:Lengths) appdata (* The full buffer blessed by the application *)
val appdata: si:SessionInfo -> ls:Lengths -> 
  b:bytes{CompatibleLengths(si,Size(b),ls)} -> (;si,ls) appdata

// Record-level fragment, with a constructor for each TLS subprotocol
// The subprotocol (CT) is not considered secret
// Two missing subprotocols?
// Each fragment is already compressed, if TLS-level compression is enabled. Compression is handled
// transparently by the TLSPlain module, and nowhere else.
type (;si:SessionInfo,n:int) fragment = 
  | AppDataFragment of (;si,n) appdata // a fragment of some application data
  | KeyExchangeData of bytes           // a fragment of some key-exchange message

// also TLS-level decompress the fragment before appending
val concat_fragment_appdata: 
  si:SessionInfo -> n:int -> (;si,n) fragment -> 
  ls:Lengths -> (;si,ls) appdata -> (;si,Cons(n,ls)) appdata

// appdata is uncompressed, the returned fragment is TLS-level compressed
val app_fragment: si:SessionInfo -> ls:Lengths -> 
  x:(;si,ls) appdata -> 
  ((n:(n:int{n=Head(ls)}) * f:(;si,n) fragment) * 
   (t:(t:Lengths{t=Tail(ls)}) * (;si,t) appdata))
// could we write instead { ls = n::t } ?
// could we omit n and t in the result, and use instead logical expressions? 

(* Only used by appdata module, to return the received concrete bytes to the application *)
(* If needed, we can add some SessionInfo and Lengths as input parameters, to parameterize appdata. *)
val get_bytes: appdata -> bytes

val pub_fragment: si:SessionInfo -> b:bytes -> ((n:int * (;si,n) fragment) * bytes) 
(* Note that n is *not* the length of the plaintext, it is the length of the target ciphertext *)
val pub_fragment_to_bytes: si:SessionInfo -> n:int -> (;si,n)fragment -> bytes

type (;ki:KeyInfo) mac = MAC.mac (* a fixed-length MAC tag for ki *)
// We miss operations on MACs! 

type (;ki:KeyInfo) mac_plain = MAC.mac_plain (* The data to be MACed, typically fragment @| add_data *)
type (;ki:KeyInfo) add_data = bytes (* Additional public data to be included in MAC operations *)

val ad_fragment: ki:KeyInfo -> (;ki) add_data -> (;ki.sinfo) fragment -> (;ki) mac_plain


type (;ki:KeyInfo,n:int) plain // contents to be encrypted (exactly n bytes)

/// Concatenating fragments, MACs, and padding when using MAC-then-Encrypt

val concat_fragment_mac_pad: 
  ki:KeyInfo -> n:int -> 
  (;ki.sinfo,n) fragment -> (;ki) mac -> (;ki,n) plain (* plain includes padding *)

val split_mac: 
  ki:KeyInfo -> n:int -> 
  (;ki,n) plain -> ((;ki.sinfo,n) fragment * (;ki) mac)
  (* Returns a random fragment if pad checking fails *)
  // No! But we may instead return a random mac. 

/// Concatenating fragments and MACs for MACOnlyCipherSuites 

val fragment_mac_to_cipher: 
  ki:KeyInfo {IsMACOnlyCipherSuite(ki)} -> n:int -> 
  (;ki.sinfo,n) fragment -> (;ki) mac -> b:bytes{Length(b)=n}
val cipher_to_fragment_mac: 
  ki:KeyInfo {IsMACOnlyCipherSuite(ki)} -> n:int -> 
  b:bytes{Length(b)=n} -> ((;ki.sinfo,n) fragment * (;ki) mac)

/// Coercing the fragment for NullCipherSuites

val fragment_to_cipher: 
  ki:KeyInfo {IsNullCipherSuite(ki)} -> n:int -> 
  (;ki.sinfo,n) fragment -> b:bytes{Length(b)=n}
val cipher_to_fragment: 
  ki:KeyInfo {IsNullCipherSuite(ki)} -> n:int -> 
  b:bytes{Length(b)=n} -> (;ki.sinfo,n) fragment

// When we do not encrypt, we may instead just rely
// on coercions from fragments and macs to concrete bytes
// (which we may use for corrupted connections too)


