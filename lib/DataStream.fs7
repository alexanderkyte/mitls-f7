module DataStream
open TLSInfo
open Bytes
open Error

val max_TLSPlaintext_fragment_length: nat
val max_TLSCompressed_fragment_length: nat
val max_TLSCipher_fragment_length: nat
val fragmentLength: nat

type range = l:nat * h:nat { l <= h } (* length range *)
type (;r:range) rbytes = b:bytes { ?l,h. r = (l,h) /\ l <= Length(b) /\ Length(b) <= h }   

function val Sum: range * range -> range
assume !l0,h0,l1,h1. Sum((l0,h0),(l1,h1)) = (l0+l1,h0+h1)
val rangeSum: r0:range -> r1:range -> r:range{r = Sum(r0,r1)}
val min: a:nat -> b:nat -> c:nat{(a<=b /\ c=a) \/ (a>b /\ c=b)}
val max: a:nat -> b:nat -> c:nat{(a>=b /\ c=a) \/ (a<b /\ c=b)}
val splitRange: ki:KeyInfo -> r:range -> (r0:range * r1:range){r = Sum(r0,r1)} // /\ FitsInFrag(ki,fragmentLength,r0)

private type (;ki:KeyInfo,r:range) sbytes = {secb:(;r)rbytes}

val plain: ki:KeyInfo{not Safe(ki)} -> r:range -> (;r)rbytes -> x:(;ki,r)sbytes
val repr:  ki:KeyInfo{not Safe(ki)} -> r:range -> x:(;ki,r)sbytes -> (;r)rbytes

private type (;ki:KeyInfo) stream = {sb:bytes}
predicate Before of ki:KeyInfo * (;ki)stream * r:range * (;ki,r)sbytes

private type (;ki:KeyInfo, h:(;ki)stream, r:range) predelta = {contents:(;ki,r)sbytes}
private type (;ki:KeyInfo, h:(;ki)stream, r:range) delta = x:(;ki,h,r)predelta{Safe(ki) => Before(ki,h,r,x.contents)}

val createDelta: 
  ki:KeyInfo -> s:(;ki) stream -> r:range -> b:(;r) rbytes -> c: (;ki,s,r) delta  
val destructDelta: 
  ki:KeyInfo -> s:(;ki) stream -> r:range -> c: (;ki,s,r) delta -> (;r) rbytes
val delta: 
  ki:KeyInfo{not Safe(ki)} -> s:(;ki) stream -> r:range -> b:(;r) rbytes -> c: (;ki,s,r) delta  
val deltaRepr: 
  ki:KeyInfo{not Safe(ki)} -> s:(;ki) stream -> r:range -> c: (;ki,s,r) delta -> (;r) rbytes

predicate EmptyStream of ki:KeyInfo * (;ki)stream
private assume !s. ?ki. EmptyStream(ki,s) <=> s.sb = [||]
val init: ki:KeyInfo -> s:(;ki) stream{EmptyStream(ki,s)}

function val ExtendStream: ki:KeyInfo * s:(;ki)stream * r:range * (;ki,s,r)delta -> (;ki)stream
private assume !ki,s,r,d. ExtendStream(ki,s,r,d) = {sb = s.sb @| d.contents.secb}
private assume !ki,s,r1,r2,d1,d2. Before(ki,s,Sum(r1,r2),{secb = d1.contents.secb @| d2.contents.secb}) <=> 
	                    (Before(ki,s,r1,d1.contents) /\ Before(ki,ExtendStream(ki,s,r1,d1),r2,d2.contents))



val append: 
  ki:KeyInfo -> s: (;ki) stream -> r:range ->
  d:(;ki,s,r) delta -> s':(;ki) stream{s' = ExtendStream(ki,s,r,d)}

val split: ki:KeyInfo -> s:(;ki) stream -> 
  r0:range -> r1:range -> d:(;ki,s,Sum(r0,r1)) delta -> 
  (d0:(;ki,s,r0) delta * d1:(;ki,ExtendStream(ki,s,r0,d0),r1) delta)

val join: ki:KeyInfo -> s:(;ki) stream -> 
  r0:range -> d0:(;ki,s,r0) delta -> 
  r1:range -> d1:(;ki,ExtendStream(ki,s,r0,d0),r1) delta -> (;ki,s,Sum(r0,r1)) delta

val contents:  ki:KeyInfo -> s:(;ki)stream -> r:range -> (;ki,s,r)delta ->
	sb:(;ki,r)sbytes{Safe(ki) => Before(ki,s,r,sb)}
val construct: ki:KeyInfo -> s:(;ki)stream -> r:range ->
	sb:(;ki,r)sbytes{Safe(ki) => Before(ki,s,r,sb)} -> (;ki,s,r)delta
