module TLSInfo

open Bytes
open Principal
open CipherSuites

type sessionID = bytes

type preDirection =
    | CtoS
    | StoC
type Direction = d:preDirection{d = CtoS \/ d = StoC}
(* FIXME: Automatic inference by F7 *)

function val DualDirection: Direction -> Direction
assume DualDirection(CtoS) = StoC
assume DualDirection(StoC) = CtoS

val dualDirection: d1:Direction -> d2:Direction{d2=DualDirection(d1)}

type SessionInfo = {
    clientID: cert option;
    serverID: cert option;
    sessionID: sessionID option;
    protocol_version: ProtocolVersion;
    cipher_suite: cipherSuite;
    compression: Compression;
    init_crand: bytes;
    init_srand: bytes
    }

predicate NullSessionInfo of SessionInfo 

private assume !si. NullSessionInfo(si) <=> (si.clientID = None /\ si.serverID = None /\ si.sessionID = None /\
    IsNullCiphersuite(si.cipher_suite) /\ si.compression = NullCompression /\ si.init_crand = [||] /\ si.init_srand = [||] )

val null_sessionInfo: pv:ProtocolVersion -> si:SessionInfo{NullSessionInfo(si)}
val isNullSessionInfo: s:SessionInfo -> b:bool{b=true => NullSessionInfo(s)}

type KeyInfo = {
    sinfo: SessionInfo;
    dir: Direction;
    crand: bytes;
    srand: bytes;
    // cVerifyData: bytes
    // sVerifyData: bytes
    }

predicate NullKeyInfo of KeyInfo

private assume !ki. NullKeyInfo(ki) <=> (NullSessionInfo(ki.sinfo) /\ ki.crand = [||] /\ ki.srand = [||])

val null_KeyInfo: d:Direction -> pv:ProtocolVersion -> ki:KeyInfo{NullKeyInfo(ki)}

function val DualKeyInfo: (KeyInfo * unit) -> KeyInfo
assume !k1,dummy. DualKeyInfo(k1,dummy) = {
	sinfo = k1.sinfo;
	dir=DualDirection(k1.dir);
	crand=k1.crand;
	srand=k1.srand}

val dual_KeyInfo: k1:KeyInfo -> k2:KeyInfo{k2=DualKeyInfo(k1,())}
// We might need something like this -- and possibly more
// definition !ki. NullKeyInfo(ki) => NullSessionInfo(ki.sinfo)

predicate Corrupt of KeyInfo

assume !ki. CipherSuites.IsNullCiphersuite(ki.sinfo.cipher_suite) => Corrupt(ki)

type ConnectionInfo =
    { id_in:  KeyInfo;
      id_out: KeyInfo}

predicate UserSaysCompatibleSessions of SessionInfo * SessionInfo

predicate CompatibleSessions of SessionInfo * SessionInfo
assume !s. CompatibleSessions(s,s)
assume !s1,s2. UserSaysCompatibleSessions(s1,s2) => CompatibleSessions(s1,s2)
assume !nulls,s. NullSessionInfo(nulls) => CompatibleSessions(nulls,s)

predicate CompatibleIndexes of ConnectionInfo * ConnectionInfo
assume !id1,id2. CompatibleIndexes(id1,id2) <=>
				 ( CompatibleSessions(id1.id_in.sinfo, id2.id_in.sinfo ) /\
                   CompatibleSessions(id1.id_out.sinfo,id2.id_out.sinfo) )
