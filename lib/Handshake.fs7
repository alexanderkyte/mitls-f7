module Handshake

open Bytes
open Error
open Formats
open HS_msg
open Algorithms
open CipherSuites
open TLSInfo
open TLSPlain
open AppCommon
open Principal
open SessionDB
open PRFs
//open Record

type clientSpecificState =
    { resumed_session    : bool;
      must_send_cert     : certificateRequest Option;
      client_certificate : (cert list) Option
    }

type clientState =
    | ServerHello
    | Certificate
    | ServerKeyExchange
    | CertReqOrSHDone
    | CSHDone   of clientSpecificState
    | CCCS      of clientSpecificState
    | CFinished of clientSpecificState
    | CWaitingToWrite
    | CIdle

type serverSpecificState =
    { resumed_session: bool;
      highest_client_ver: ProtocolVersionType}

type serverState =
    | ClientHello
    | ClCert of serverSpecificState
    | ClientKEX of serverSpecificState
    | CertificateVerify of serverSpecificState
    | SCCS of serverSpecificState
    | SFinished of serverSpecificState
    | SWaitingToWrite
    | SIdle

type protoState =
  | Client of clientState
  | Server of serverState

type pre_hs_state = {
  hs_outgoing    : bytes;                  (* outgiong data before a ccs *)
  ccs_outgoing: (bytes * ccs_data) option; (* marker telling there's a ccs ready *)
  hs_outgoing_after_ccs: bytes;            (* data to be sent after the ccs has been sent *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  ccs_incoming: ccs_data option; (* used to store the computed secrects for receving data. Not set when receiving CCS, but when we compute the session secrects *)
  poptions: protocolOptions;
  pstate : protoState;
  hs_msg_log: bytes;
  hs_cur_info : SessionInfo; (* The session we're currrently running into *)
  cur_ms: masterSecret; (* The master secrect associated with the current session. *)
  hs_next_info: SessionInfo; (* The session we're establishing within the current HS *)
  next_ms: masterSecret; (* The ms we're establishing *)
  ki_crand: bytes; (* Client random for the session we're establishing (to be stored in KeyInfo) *)
  ki_srand: bytes; (* Current server random, as above *)
  hs_renegotiation_info_cVerifyData: bytes; (*Renegotiation info associated with the session we're establishing *)
  hs_renegotiation_info_sVerifyData: bytes
}

predicate type preds =
  | HandshakeState of pre_hs_state // Invariants on the hs state
  | Client of pre_hs_state         // This HS is running in client mode
  | Server of pre_hs_state         // This HS is running in server mode
  | ClientFinished of SessionInfo  // Client sent the Finished message
  | ServerFinished of SessionInfo  // Server sent the Finished message
  | Compatible of KeyInfo * bytes * protocolOptions

type hs_state = hs:pre_hs_state {HandshakeState(hs)}

type HSFragReply =
  | EmptyHSFrag
  | HSFrag of (int * fragment)
  | HSWriteSideFinished of (int * fragment) // {(Client(state) /\ ClientFinished(si)) \/ (Server(state) /\ ServerFinished(si))}
  | HSFullyFinished_Write of (int * fragment) * ss:StorableSession {ClientFinished(ss.sinfo) /\ ServerFinished(ss.sinfo)} // Honest(..) /\ StrongSuite(..) =>
  | CCSFrag of (int * fragment) * cd:ccs_data // {(Client(state) /\ Compatible(cd.ki,state.ki_crand,state.poptions)) \/ (Server(state) /\ Compatible(cd.ki,state.ki_srand,state.poptions))}

(* CF out of date:
// returns to the dispatcher the next fragment to be sent, if any 
val next_fragment: s:hs_state -> r:HSFragReply * s':hs_state 
    {   (s'.hs_cur_info = s.hs_cur_info) 
	/\  (r = EmptyHSFrag => s' = s) 
    /\  (!i,f. r = HSFrag((i,f)) => (UpperProtoSend(s.hs_info,Handshake,f) /\ Pub(f))) 
        // TODO: Pub(f) might not be true for the Finished message, in this case a different return value is needed 
        // FIXME: The fragments returned after the CCS must be blessed for the next sessioninfo, not the current one!
        //          This will also be true for the alert protocol... and input/output session infos at the record layer
        //          might not be synchronized... 
    /\  (!i,f,ccs. r = CCSFrag((i,f),ccs) =>
          (UpperProtoSend(s.hs_info,Change_cipher_spec,f) /\ Pub(f) /\ Compatible(ccs.ki,s.ki_Xrand,s.poptions))
                    // /\ ccs.ki.sinfo = s.ns_next_info 
					)
               
    /\  (!i,f. r = HSWriteSideFinished((i,f)) => // FIXME: which sinfo to use? cur, next? We must be aligned, or don't care about this
          (UpperProtoSend(s.hs_info, Handshake, f) /\ Pub(f) /\ Client/ServerFinished(s.hs_next_info)))
                
    /\  (!i,f,ss. r = HSFullyFinished_Write(((i,f),ss)) =>
          (UpperProtocoSend(s.hs_info, Handshake, f) /\ Pub(f) /\ ClientFinished(s.hs_next_info) /\ ServerFinished(s.hs_next_info)))
                    // /\ ss.sinfo = s.hs_next_info 
    }
*)

type recv_reply = 
  | HSAck
  | HSChangeVersion of Direction * ProtocolVersionType
  | HSReadSideFinished // {(Client(state) /\ ClientFinished(si)) \/ (Server(state) /\ ServerFinished(si))}
  | HSFullyFinished_Read of ss:StorableSession {ClientFinished(ss.sinfo) /\ ServerFinished(ss.sinfo)} // Honest(..) /\ StrongSuite(..) =>

// Negotiation

function val Negotiate: ('a list * 'a list) -> 'a
//definition !cs,s,ss.    Mem(s,cs)      <=> s = Negotiate(cs,s:ss)  
//definition !cs,s,s',ss. not(Mem(s',cs) <=> Negotiate(cs,s':ss,s) = Negotiate(cs,ss,s) )

val negotiate: cs: 'a list -> ss: 'a list -> (s: 'a { s = Negotiate(cs,ss) }) option  

// Internal
val makeFragment : HS_msg.handshakeType -> Data.bytes -> Data.bytes
val makeHelloRequestBytes : unit -> Data.bytes
val makeTimestamp : unit -> int
val makeClientHello : protocolOptions -> Sessions.sessionID -> HS_msg.clientHello
val b_of_cslist : HS_ciphersuites.CipherSuite list -> Data.bytes -> Data.bytes
val bytes_of_cipherSuites : HS_ciphersuites.CipherSuite list -> Data.bytes
val b_of_complist : Formats.Compression list -> Data.bytes -> Data.bytes
val compressionMethodsBytes : Formats.Compression list -> Data.bytes
val makeClientHelloBytes : protocolOptions -> Sessions.sessionID -> Data.bytes

val init_handshake: r:role -> protocolOptions -> (info:SessionInfo * s:hs_state){info = InitSessionInfo(r,None) /\ s.hs_info = info}

val resume_handshake: role -> SessionInfo -> protocolOptions -> hs_state

val start_rehandshake: hs_state -> protocolOptions -> hs_state

val start_rekey: hs_state -> protocolOptions -> hs_state

val start_hs_request: hs_state -> protocolOptions -> hs_state

val new_session_idle: hs_state -> i:SessionInfo -> s:hs_state{s.hs_info = i}

val parseFragment :
  hs_state ->
    Data.bytes -> hs_state * (HS_msg.handshakeType * Data.bytes) option
val recv_fragment: hs_state -> Record.fragment ->
	(r:(recv_reply Error_handling.Result) * hs_state){
		(!rr. r = Correct(rr) => (!hs,r,pv. rr = HSChangeVersion(hs,r,pv) => pv <> UnknownPV))
	}
val recv_ccs: s:hs_state -> Record.fragment ->
	(r:(Record.ccs_data Error_handling.Result) * hs_state){
//CF temp//	(!ccs. r = Correct(ccs) => Compatible(ccs.ki, s.ki_Xrand, s.poptions)) (* /\ ccs.ki.sinfo = s.hs_next_info *)
	}

(* A ccs such that Compatible(ccs,...) holds implies that there exist
   TLSMKey(mk,info) and TLSSKey(sk,info) (where mk,sk,info are somehow bound to ccs).
   This is enough for the keys to be used in the record layer, and for the dispatcher
   to be in its Finishing/Finished states.
   However, when the HS protocol emits the HSFinished(info) event, then it means we're in
   an opened session, so the dispatcher can go to the open state, and we can lift Pub_K
   to the compromised session *)

(*   
// If a confirmed key is public, then the session is compromised 
assume  !mk,info. TLSMKey(mk,info) /\ HSFinished(info) /\ Compromised(info) => Crypto.Pub_k(mk)
theorem !mk,info. TLSMKey(mk,info) /\ HSFinished(info) /\ Crypto.Pub_k(mk) => Compromised(info)
assume  !sk,info. TLSSKey(sk,info) /\ HSFinished(info) /\ Compromised(info) => Crypto.Pub_k(sk)
theorem !sk,info. TLSSKey(sk,info) /\ HSFinished(info) /\ Crypto.Pub_k(sk) => Compromised(info)
*)

(* towards a ClientFinished logical specification

[rest of] si, MS =
 
si, ms, ClientVerifyMessages { 
/\ ClientHelloMessage(ClientHello,si.CR,options)
/\ ServerHelloMessage(ServerHello,si.SR,si.sessionID,
                      si.protocolVersion,si.ciphersuite,si.compression,si.extensions)
/\ CertificateMessage(Certificate, si.serverID)
/\ ClientKEXMessage(ClientKEX,pms, si.serverID)
/\ ms = PRF("...",pms,si.CR,si.SR...)
/\ ClientVerifyMessages = ClientHello @| ServerHello @| Certificate @| ClientKEX }

// all those being injective; maybe use functions instead? 

  si.CR = ClientHello[CR]

}

*)

(*
Handshake verification hints:
We have agreement on the exchanged messages (verifyData). From this, we want to infer
that we agreement on sessionInfo. So, we want to express sessionInfo = F(verifyData).
However, F will be different from client to server, and in general we cannot prove
F = F' (where F is on the client and F' on the server).
Instead we want to characterize F and F' with the minimum information that we need to prove
that F'(verifyData) = SessionInfo' = SessionInfo = F(verifyData)
(Again: verifying the Finished message gives agreement on verifyData, i.e. it tells us verifyData
is indeed the same on both sides).
So, we do this by binding each field of sessionInfo to specific messages: e.g.
sessionInfo.init_crand = F(clientHello) and F'(clientHello), etc.

(best is when we can use the same binding for F and F', so that we write it only once and
we reuse it on both client and server sides)

We end up with something like in Cedric's comment. To prove it locally, we have to reason
step-by-step, increasing the invariant:
- In the initial state, we don't know anything about sessionInfo
- When we receive one message, we assume all previously set fields are ok, and we prove
  the field we handle is set correctly
- In the final state, all fields are set correctly, and we get agreement on sessionInfo
*)