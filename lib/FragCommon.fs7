module FragCommon

open Bytes
open TLSInfo
open CipherSuites
open Algorithms

val max_TLSPlaintext_fragment_length: n:nat { n = 16384 (* 2^14 *) }
val fragmentLength: n:nat{n <= max_TLSPlaintext_fragment_length}

val max_TLSCompressed_fragment_length: n:nat {n = max_TLSPlaintext_fragment_length + 1024}
val max_TLSCipher_fragment_length: n:nat {n = max_TLSCompressed_fragment_length + 1024}

type tlen = n:nat{n <= max_TLSCipher_fragment_length}

predicate CompatibleLength of SessionInfo * nat * tlen

private assume !si,n,t.
	IsNullCiphersuite(si.cipher_suite) /\ t = n => CompatibleLength(si,n,t)
private assume !si,n,t.
	IsOnlyMACCiphersuite(si.cipher_suite) /\ 
	t = n + MacKeySize(CipherSuiteMACAlg(si.cipher_suite)) =>
		CompatibleLength(si,n,t)

val padLength: SessionInfo -> int -> int

val cipherLength: si:SessionInfo -> n:nat{n<=max_TLSPlaintext_fragment_length} -> t:tlen{CompatibleLength(si,n,t)}
val splitInFrag: ki:KeyInfo -> b:bytes ->
		(n:nat * b1:bytes * b2:bytes){CompatibleLength(ki.sinfo,Length(b1),n) /\
				b = b1 @| b2 /\ Length(b1) <= max_TLSPlaintext_fragment_length}

predicate CompatibleLengths of SessionInfo * int * int list
val estimateLengths: si:SessionInfo -> n:int -> l:int list{CompatibleLengths(si,n,l)}
val getFragment: si:SessionInfo -> tlen:int -> b:bytes -> (b1:bytes * b2:bytes){CompatibleLength(si,Length(b1),tlen) /\ b = b1 @| b2}
