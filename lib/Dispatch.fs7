module Dispatch

open Bytes
open Formats
open Tcp
open Error
open Record
open Handshake
open Alert
open AppDataStream
open TLSInfo
open TLSKey
open AppConfig
open TLSFragment
open SessionDB

type predispatchState =
  | Init (* of ProtocolVersion * ProtocolVersion *) (* min and max *)
  | FirstHandshake (* of ProtocolVersion *)             (* set by the ServerHello *) 
  | Finishing
  | Finished (* Only for Writing side, used to avoid sending data on a partially completed handshake *)
  | Open
  | Closing
  | Closed

type dispatchState = d:predispatchState{
	d = Init \/ d = FirstHandshake \/ d = Finishing \/ d = Finished \/
	d = Open \/ d = Closing \/ d = Closed}

type (;ki:KeyInfo) dState = {
    disp: dispatchState;
    conn: (;ki)Record.ConnectionState;
    seqn: int
    }

type (;id:ConnectionInfo) preGlobalState = {
  poptions: protocolOptions;
  (* abstract protocol states for HS/CCS, AL, and AD *)
  handshake: (;id) Handshake.hs_state;
  alert    : (;id) Alert.state;
  appdata  : (;id) AppDataStream.app_state;    

  (* connection state for reading and writing *)
  read  : (;id.id_in)  dState;
  write : (;id.id_out) dState;
  (* The actual socket *)
  ns: NetworkStream;
  }

type (;id:ConnectionInfo) globalState = (gs:(;id) preGlobalState){
  InSequenceNo(id,gs.appdata) = gs.read.seqn /\ 
  OutSequenceNo(id,gs.appdata) = gs.write.seqn
}

type Connection = Conn of (id:ConnectionInfo * (;id)globalState)
function val ConnectionIndex: Connection -> ConnectionInfo
assume !id,s. ConnectionIndex(Conn(id,s)) = id

function val ConnectionOutKeyInfo: Connection -> KeyInfo
assume !id,s. ConnectionOutKeyInfo(Conn(id,s))= id.id_out
function val ConnectionInKeyInfo: Connection -> KeyInfo
assume !id,s. ConnectionInKeyInfo(Conn(id,s)) = id.id_in


function val ConnectionOutSessionInfo: Connection -> SessionInfo
assume !id,s. ConnectionOutSessionInfo(Conn(id,s))=id.id_out.sinfo
function val ConnectionInSessionInfo: Connection -> SessionInfo
assume !id,s. ConnectionInSessionInfo(Conn(id,s))=id.id_in.sinfo

function val Params: Connection -> protocolOptions
assume !id,s. Params(Conn(id,s))=s.poptions

function val dStateSeqn: ki:KeyInfo * (;ki)dState -> int
assume !ki,s. dStateSeqn(ki,s)=s.seqn

function val ConnectionReadSeqn: Connection -> int
assume !id,s. ConnectionReadSeqn(Conn(id,s))=s.read.seqn

val checkCompatibleSessions: s1:SessionInfo -> s2:SessionInfo -> AppConfig.protocolOptions ->
                             b:bool{b = true => CompatibleSessions(s1,s2)}

type (;c:Connection) CompatibleConnection = c':Connection{
   CompatibleConnections(ConnectionIndex(c),ConnectionIndex(c')) }

type writeOutcome =
    | WriteAgain (* Possibly more data to send *)
    | Done (* No more data to send in the current state *)
    | MustRead (* Read until completion of Handshake *)

type deliverOutcome =
    | ReadAgain
    | AppDataDone
    | HSDone
    | Abort

val init: NetworkStream -> Direction -> protocolOptions -> Connection

val resume: NetworkStream -> sessionID -> protocolOptions -> unit Result * Connection

val ask_rehandshake: c:Connection -> protocolOptions -> (;c) CompatibleConnection
val ask_rekey:       c:Connection -> protocolOptions -> (;c) CompatibleConnection
val ask_hs_request:  c:Connection -> protocolOptions -> (;c) CompatibleConnection

val getSessionInfo: c:Connection -> si:SessionInfo{si=ConnectionOutSessionInfo(c)}

val moveToOpenState: c:Connection ->
	(si:SessionInfo * (;si)PRFs.masterSecret * Direction)
		{si=ConnectionOutSessionInfo(c) /\ si=ConnectionInSessionInfo(c)} ->
	(;ConnectionIndex(c))globalState

val reIndex_dState: oldKI:KeyInfo -> newKI:KeyInfo{CompatibleSessions(oldKI.sinfo,newKI.sinfo)} ->
	ods:(;oldKI)dState -> (;newKI)ccs_data -> 
  nds:(;newKI)dState{nds.disp = ods.disp /\ nds.seqn = ods.seqn}

val reIndex_dState_null: oldKI:KeyInfo{NullSessionInfo(oldKI.sinfo)} ->
  newKI:KeyInfo{NullSessionInfo(newKI.sinfo)} ->
  ods:(;oldKI)dState -> 
  nds:(;newKI)dState{nds.disp = ods.disp /\ nds.seqn = ods.seqn}

val reIndex_out: oldID:ConnectionInfo ->
	newID:ConnectionInfo{oldID.id_in = newID.id_in /\
			     CompatibleSessions(oldID.id_out.sinfo,newID.id_out.sinfo)} ->
	(;oldID)globalState -> (;newID.id_out)ccs_data ->
	(;newID)globalState

val reIndex_in: oldID:ConnectionInfo ->
	newID:ConnectionInfo{oldID.id_out = newID.id_out /\
						 CompatibleSessions(oldID.id_in.sinfo,newID.id_in.sinfo)} ->
	(;oldID)globalState -> (;newID.id_in)ccs_data ->
	(;newID)globalState

val reIndex_null: oldID:ConnectionInfo{
	NullSessionInfo(oldID.id_out.sinfo) /\
	NullSessionInfo(oldID.id_in.sinfo)} ->
	newID:ConnectionInfo{
	NullSessionInfo(newID.id_out.sinfo) /\
	NullSessionInfo(newID.id_in.sinfo)} ->
	(;oldID)globalState -> (;newID)globalState


val closeConnection: c:Connection-> (;c) CompatibleConnection

// This always returns the write-side seqn increased by one,
// regardless of the content type
val send: ki:KeyInfo -> NetworkStream -> ss:(;ki)dState -> tlen:int ->
	ct:ContentType -> f:(;ki,tlen,dStateSeqn(ki,ss),ct)TLSFragment.fragment ->
	(ss':(;ki)dState{dStateSeqn(ki,ss') = dStateSeqn(ki,ss)+1}) Result

// internally invokes send (which increases the write-side seqn),
// however resets the write-side seqn is we just sent a CCS
val writeOne: c:Connection ->
	(writeOutcome Result) * (;c) CompatibleConnection

// Normally, the returned read-side seqn will be increased by one
// expect if we delivered a CCS, in which case it is 0
val deliver: c:Connection -> ct:ContentType -> tlen:int ->
	(;ConnectionInKeyInfo(c),tlen,ConnectionReadSeqn(c),ct)TLSFragment.fragment ->
	(deliverOutcome Result * (;c) CompatibleConnection)

val recv: c:Connection ->
	(c':(;c)CompatibleConnection *
	 ct:ContentType * tlen:int * 
         (;ConnectionInKeyInfo(c'),tlen,ConnectionReadSeqn(c'),ct)TLSFragment.fragment) Result

val readOne: c:Connection ->
	deliverOutcome Result * (;c) CompatibleConnection

val writeFromRead: c:Connection ->
	unit Result * (;c) CompatibleConnection

type preReadInvocation =
    | StopAtHS
    | StopAtAppData

type readInvocation = r:preReadInvocation{
	r = StopAtHS \/ r = StopAtAppData}

val read: c:Connection -> readInvocation -> unit Result * (;c) CompatibleConnection

val writeAppData: c:Connection -> unit Result * (;c) CompatibleConnection


val commit: c:Connection -> DataStream.range -> bytes ->
	(;c)CompatibleConnection

val readAppData: c:Connection ->
	c':(;c)CompatibleConnection *
	  bytes Result
	

val readHS: c:Connection -> unit Result * (;c) CompatibleConnection
