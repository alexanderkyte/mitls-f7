module AEAD

open TLSInfo
open Error
open DataStream
open AEADPlain

type (;ki:KeyInfo) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  |   GCM of ke:(;ki:AENC.state)  *)

val encrypt: ki:KeyInfo -> 
  (;ki) AEADKey ->  
  ad:(;ki) data ->
  rg:DataStream.range -> 
  p:(;ki,rg,ad) plain ->
  ((;ki) AEADKey * c:ENC.cipher){Length(c)=RangeCipher(ki,rg) /\ CTXT(ki,ad,p,c)}

val decrypt: ki:KeyInfo -> 
  (;ki) AEADKey -> 
  ad:(;ki) data ->
  c:ENC.cipher ->
  res: ((;ki) AEADKey * 
	rg:(rg:range{rg = CipherRange(ki,c)}) * 
	(;ki,rg,ad) plain) Result{
    (Safe(ki) => (!rg,p. (res = Correct(rg,p) <=> CTXT(ki,ad,p,c)))) /\
    (Auth(ki) => (!rg,p. (res = Correct(rg,p) =>  (?c. CTXT(ki,ad,p,c)))))}
      


(* TODOS: (KB: Done?) *)
(* - Add explicit ciphertext length *)
(* - Make all iv become iv3: Only TLS 1.0 will use iv, later versions don't. *)
(*	 The ciphertext has different lengths, depending on the version: *)
(*   In later versions it includes the fresh iv, in early versions it doensn't. *)

