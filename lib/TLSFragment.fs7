module TLSFragment

open Bytes
open TLSInfo
open Formats
open CipherSuites
open DataStream

// Plain type for Dispatch and Record
private type (;ki:KeyInfo) history = {
  handshake: (;ki) HandshakePlain.stream;
  alert: (;ki) AlertPlain.stream;
  ccs: (;ki) HandshakePlain.stream;
  appdata: (;ki) AppDataStream.stream;
  }

function val EmptyStreams: ki:KeyInfo -> (;ki)history -> bool
val emptyHistory: ki:KeyInfo -> h:(;ki)history{EmptyStreams(ki,h)}

function val Multiplexed: KeyInfo * history -> bool

function val ConsStream: ki:KeyInfo * ContentType * (;ki)history * 'a -> history
assume !ki,h,d. ConsStream(ki,Formats.Handshake,h,d) =
	 { handshake = ConcatStream(ki,h.handshake,d);
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = h.appdata}
assume !ki,h,d. ConsStream(ki,Formats.Alert,h,d) =
	 { handshake = h.handshake;
	   alert = ConcatStream(ki,h.alert,d);
	   ccs = h.ccs;
	   appdata = h.appdata}
assume !ki,h,d. ConsStream(ki,Formats.Handshake,h,d) =
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = ConcatStream(ki,h.ccs,d);
	   appdata = h.appdata}
assume !ki,h,d. ConsStream(ki,Formats.Handshake,h,d) =
	 { handshake = h.handshake;
	   alert = h.alert;
	   ccs = h.ccs;
	   appdata = ExtendStream(ki,h.appdata,d)}


type (;ki:KeyInfo,ct:ContentType,h:(;ki) history,rg:range) fragment =
    | FHandshake of f:(;ki,h.handshake,rg)HandshakePlain.fragment    {ct=Formats.Handshake}
    | FCCS       of f:(;ki,h.ccs,rg)HandshakePlain.ccsFragment {ct=Change_cipher_spec}
    | FAlert     of f:(;ki,h.alert,rg)AlertPlain.fragment        {ct=Alert}
    | FAppData   of f:(;ki,h.appdata,rg)AppDataStream.fragment {ct=Application_data}

val addToStreams: ki:KeyInfo -> ct:ContentType -> ss:(;ki)history -> r:range ->
	f:(;ki,ct,ss,r)fragment -> ss':(;ki)history{ss' = ConsStream(ki,ct,ss,f)}

// Deprecated
// FIXME: Circular dependency!
// predicate Multiplexed of KeyInfo * StatefulPlain.history * HandshakePlain.stream * HandshakePlain.stream * AlertPlain.stream * AppDataStream.stream 
// assume !ki,fs,hs,ccs,al,ad. Multiplexed(ki,fs,hs,ccs,al,ad) <=>
//   ((fs = [] /\ 
//    HandshakePlain.EmptyStream(ki,hs) /\
//    HandshakePlain.EmptyStream(ki,ccs) /\
//    AlertPlain.EmptyStream(ki,al) /\
//    AppDataStream.EmptyStream(ki,ad)) \/
//   (?ct,h0,rg,f,t. fs = (ct,h0,rg,f)::t /\
//       (?hs'. ct = Formats.Handshake /\
// 	  HandshakePlain.ConcatStream(ki,hs',f,hs) /\
// 	  Multiplexed(ki,t,hs',ccs,al,ad)) \/
//       (?ccs'. ct = Formats.Change_cipher_spec /\
// 	  HandshakePlain.ConcatStream(ki,ccs',f,ccs) /\
// 	  Multiplexed(ki,t,hs,ccs',al,ad)) \/
//       (?al'. ct = Formats.Alert /\
// 	  AlertPlain.ConcatStream(ki,al',f,al) /\
// 	  Multiplexed(ki,t,hs,ccs,al',ad)) \/
//       (?ad'. ct = Formats.Application_data /\
// 	  AppDataStream.ConcatStream(ki,ad',f,ad) /\
// 	  Multiplexed(ki,t,hs,ccs,al,ad'))))
// 
// type (;ki:KeyInfo) shistory = (h:(;ki) history){Multiplexed(ki,h.log,h.handshake,h.ccs,h.alert,h.appdata)}


predicate Fragment of KeyInfo * range * int * ContentType * bytes

val TLSFragmentRepr: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  (;ki,ct,h,rg)fragment -> bytes

val TLSFragment: ki:KeyInfo -> ct:ContentType -> h: (;ki) history -> rg:range ->
  bytes -> (;ki,ct,h,rg)fragment 

function val ADLength: KeyInfo -> int
assume !ki. (ki.sinfo.protocol_version = SSL_3p0 /\ ADLength(ki) = 9) \/
	(ki.sinfo.protocol_version <> SSL_3p0 /\ ADLength(ki) = 11)

// Additional Data
type (;ki:KeyInfo) addData = (b:bytes){Length(b) = ADLength(ki) - 8}

function val ADBytes: (KeyInfo * ContentType) -> bytes
assume !ki,ct.
	( ki.sinfo.protocol_version = SSL_3p0 /\
	  ADBytes(ki,ct) =
		CTBytes(ct) ) \/
	( ki.sinfo.protocol_version <> SSL_3p0 /\
          ADBytes(ki,ct) =
		(CTBytes(ct) @| VersionBytes(ki.sinfo.protocol_version)))

ask !ki,ct. Length(ADBytes(ki,ct)) = (ADLength(ki) - 8)

private val makeAD: ki:KeyInfo -> ct:ContentType ->
	  ad: (;ki)addData{ad=ADBytes(ki,ct)}

//private val parseAD: ki:KeyInfo -> 
//          ad: (;ki)addData -> 
//          ct:ContentType{ad=ADBytes(ki,ct)}




