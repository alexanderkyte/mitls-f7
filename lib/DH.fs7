module DH

open Bytes
open DHGroup

// marks "Honest" exponentials generated using genKey (or serverGen)
predicate type predHE = HonestExponential of p:p * g:(;p) g * gx:(;p,g) elt
private val honest: p:p -> g:(;p)g -> e:(;p,g) elt -> b:bool{b = true <=> HonestExponential(p,g,e)}

//#begin-abstraction
private type (;p:p, g:(;p)g, gx:(;p,g)elt) secret = Key of bytes 
//#end-abstraction

// We maintain 2 logs:
// - a log of honest gx and gy values
// - a log for looking up honest pms values using gx and gy values

// Any parameters returned by the Core modules are taken from the trusted DHDB,
// which only contains good parameters.

type honest_entry = (p:p  * g:(;p) g * (;p,g) elt)
type entry = p:p * g:(;p) g * gx:(;p,g) elt * gy:(;p,g) elt * pms:(;p, g, gx, gy) PMS.dhpms{PMS.HonestDHPMS(p,g,gx,gy,pms)}
private val honest_log: (honest_entry list) ref
private val log: entry list ref 

private val assoc: p:p -> g:(;p) g -> gx:(;p,g)elt -> gy:(;p,g)elt -> entry list -> pmsoption:(;p, g, gx, gy) PMS.dhpms option{!pms. pmsoption=Some(pms) => PMS.HonestDHPMS(p,g,gx,gy,pms)}


// RFCs are vague about best practices for Diffie-Hellman parameter generation
// We use default parameters for which we store the order of the subgroup for ciphertext validation
val default_pp: unit -> p:p * g:(;p) g * q {Elt(p,g,g) /\ PP(p,g)} 


definition !p,g,gx,gy. PMS.SafeDH(p,g,gx,gy) <=> HonestExponential(p,g,gx) /\ HonestExponential(p,g,gy) /\ PP(p,g)
//SZ Check if we can remove these queries; unless we want to keep them as documentation or sanity checks
ask !p,g,gx,gy. not HonestExponential(p,g,gx) => not PMS.SafeDH(p,g,gx,gy)
ask !p,g,gx,gy. not HonestExponential(p,g,gy) => not PMS.SafeDH(p,g,gx,gy) 
ask !p,g,gx,gy. not PP(p,g) => not PMS.SafeDH(p,g,gx,gy) 
val safeDH: p:p -> g:(;p) g -> gx:(;p,g)elt -> gy:(;p,g)elt -> b:bool { b=true <=> PMS.SafeDH(p,g,gx,gy) }


val leak  : p:p -> g:(;p) g -> gx:(;p,g)elt -> x:(;p,g,gx)secret{not HonestExponential(p,g,gx)} -> bytes
val coerce: p:p -> g:(;p) g -> gx:(;p,g)elt{not HonestExponential(p,g,gx)} -> b:bytes -> x:(;p,g,gx)secret

val genKey: p:p -> g:(;p) g -> gx:(;p,g) elt * (;p,g,gx) secret{HonestExponential(p,g,gx)}

    
val serverGen: unit -> (p:p * g:(;p) g * gs:(;p,g) elt * (;p,g,gs) secret{PP(p,g) /\ HonestExponential(p,g,gs)})

val clientGenExp: p:p -> g:(;p) g -> gs:(;p,g) elt 
				      -> (gc:(;p,g) elt * (;p,g,gc) secret * res:(;p,g,gs,gc) PMS.dhpms)
					     {HonestExponential(p,g,gc) /\ ((HonestExponential(p,g,gs) /\ PP(p,g)) => PMS.HonestDHPMS(p,g,gs,gc,res))}

val serverExp: p:p -> g:(;p) g{PP(p,g)} -> gs:(;p,g) elt{HonestExponential(p,g,gs)} -> gc:(;p,g) elt -> s:(;p,g,gs) secret 
				   -> res:(;p,g,gs,gc) PMS.dhpms{HonestExponential(p,g,gc) => PMS.HonestDHPMS(p,g,gs,gc,res)}
