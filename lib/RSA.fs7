module RSA

// RSA encryption & decryption of the PMS

open Bytes
open Error
open TLSError
open TLSConstants
open TLSInfo
open RSAKey

// We currently exclude RSA keys used both for signing and decryption

// For concrete security, see also 
// "On the Security of RSA Encryption in TLS",
// Jakob Jonsson and Burton S. Kaliski Jr.
// http://www.iacr.org/archive/crypto2002/24420127/24420127.pdf   

val encrypt: 
  pk:pk -> cv:ProtocolVersion -> pms:(;pk,cv) PMS.rsapms -> 
  b:bytes {PMS.EncryptedRSAPMS(pk,cv,pms,b)}

val decrypt: 
  sk -> si:SessionInfo -> 
  cv:ProtocolVersion -> (* highest client version *) 
  bool -> (* flag whether we should check protocol version in old TLS versions *)
  bytes -> (* encrypted PMS *)
  (;Cert.RSAPKCert(si.serverID),cv) PMS.rsapms (* no Result type: instead of an error, we return a fresh Nonce.random PMS *)

// This is not just plain RSA_PKCS1 decryption.
// We put in place timing attack countermeasures.
// See RFC 5246, section 7.4.7.1
  

// The rest of the interface is internal to RSA.fs
// TODO where do we require/use that cv_check be used everywhere with Honest keys?
// TODO explain that letting the adversary choose further strengthen our RSA assumption. 

// Ideally, we add an indirection from a fresh dummy pms to the ideal pms (before encryption)
// and we maintain a table to undo it (after concrete decryption)

type entry = pk:pk * cv:ProtocolVersion * PMS.rsarepr * (;pk,cv) PMS.rsapms
private val log: entry list ref 
private val assoc: 
  pk:RSAKey.pk -> pv:ProtocolVersion -> dummy_pms:bytes -> entry list -> (;pk,pv)PMS.rsapms option

// Concrete decryption with TLS-specific countermeasures against 
// protocol regression, Bleichenbacher, and related timing attacks
private val real_decrypt: 
  sk -> si:SessionInfo -> 
  cv:ProtocolVersion -> (* highest client version *) 
  cv_check:bool -> (* flag whether we should check protocol version in old TLS versions *)
  ct:bytes -> (* encrypted PMS *)
  pmsb:PMS.rsarepr { cv_check=true => ?b. pmsb= VersionBytes(cv) @| b} (* No Result type: in case of error, we return a fresh Nonce.random PMS *)



(* CF 

 Markulf: this is an old discussion of the joint RSAPMS assumption. 
 May still contain some interesting insights, but has mostly been rewritten by me in the techreport.

 Some draft assumption discussed with Markulf on 13/9/12
 
 let sk, pk = keyGen() // sk is private  
 
 let sample v = v @| Nonce.random 46
 
 let compliantClient a v Cr Sr = 
   // a determines the prf algorithm 
   // check that Cr is used at most once; probably irrelevant 
   let pms  = sample v
   let pms0 = sample v
   log := (pms0,pms)::!log
   encrypt pk (if b then pms else pms0),
   prf a (pms, Cr @| Sr)  
     
 let decryptRO a v Cr Sr c =
   // check that Sr is used at most once
   let pms0 = 
     let fake = sample v
     match decrypt sk c with 
     | pms0 when length pms0 = 48 -> let (_,r) = split (decrypt sk c) 2 in v @| r
     | _                          -> fake 
   let pms = 
     match assoc !log pms0 with 
 	| Some(pms) when b -> pms
 	| None             -> pms0
   prf a (pms, Cr @| Sr)
    
  The adversary get pk, compliantClient, decryptRO, and prf. Its goal is to guess b. 
    
  when b = 0, we have a simplification of concrete TLS
  when b = 1, the protocol is parametric in "compliant" PMSs, so we get good session keys 
              pms becomes abstract.    
  Hopefully we can reduce it to RSA with an extra oracle:
 
 let old_decryptRO a v Cr Sr c =
   // check that Sr is used at most once 
   let (_,r) = split (decrypt sk c) 2 
   let pms0 = v @| r 
   let pms = try assoc !log pms0 with not_found -> pms0
   prf a (pms, Cr @| Sr)
    
    
 let ptxt plain cipher = (decrypt sk cipher = plain) // possibly after erasing some bytes 
    
  I am puzzled that we do not use the cipher-integrity guarantee provided by the ClientFinished check
  informally, the adversary would need to extract the pms to forge a Finished for any related ciphertext  

*)