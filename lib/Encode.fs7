module Encode

(* The "plain" file for CPA encryption (module ENC) *)
(* provided by AEAD, implementing AEADPlain @| MAC @| padding *) 

open Bytes
open Error
open TLSInfo
open TLSConstants

//CF ideal only
private val safe: e:epoch -> r:bool { r = true <=> Safe(e) }
private val zeros: rg:range -> b:(;rg) rbytes  

//CF we miss this logical function, to be relocated as a postcondition of AEAD.repr and AEAD.plain
function val Payload: e:epoch * r:range * ad:(;e)AEADPlain.adata * f:(;e,ad,r)AEADPlain.plain -> 'rbytes //(;r) rbytes
private val payload: e:succEpoch -> r:range -> ad:(;e)AEADPlain.adata -> f:(;e,ad,r)AEADPlain.plain -> b:(;r) rbytes
  { b = Payload(e,r,ad,f) }

//------------------------------------------------------------------------------------------------------
// Interface towards ENC (abstract)
//------------------------------------------------------------------------------------------------------

// a function from public length of ciphertext to public length of encoded plaintext 
// (either identity, or minus iv length)
//CF still TBD!
function val PlainLength: epoch * nat -> nat
private type (;e:epoch,tlen:nat) plain = {p: (x:bytes){Length(x) = PlainLength(e,tlen) /\ tlen <= max_TLSCipher_fragment_length}}

val plain: e:epoch{not Auth(e)} -> tlen:nat{tlen <= max_TLSCipher_fragment_length} -> b:bytes{Length(b) = PlainLength(e,tlen)} -> (;e,tlen) plain
val repr:  e:epoch{not Safe(e)} -> tlen:nat -> (;e,tlen) plain -> b:bytes{Length(b) = PlainLength(e,tlen)}

//------------------------------------------------------------------------------------------------------
// Interface towards AEAD 
//------------------------------------------------------------------------------------------------------
//CF cut: type (;e:epoch) adata = (;e)AEADPlain.adata

// the MAC tags 
//CF added a length refinement; this abstract type protects secrecy 
private type (;e:succEpoch) tag = {macT: (;e) MAC.tag } 

// Result of decoding; this abstract type protects secrecy
private type (;e:epoch,ad:(;e)AEADPlain.adata,rg:range) parsed =
	{ plain: (;e,ad,rg)AEADPlain.plain;
	  tag  : (;e)tag;
	  ok   : bool (* true iff decoding succeeded *) }

// the MACed bytes, i.e. ad @| 2-byte length of payload @| payload 
//CF should ask some injectivity

function val MACPlain : 'a * 'b * 'c * 'd -> 'e
private definition !e,r,ad,f,b. MACPlain(e,r,ad,f) = ad @| VLBytes(2,Payload(e,r,ad,f))
val macPlain: e:succEpoch -> r:range -> 
  ad:(;e)AEADPlain.adata -> f:(;e,ad,r)AEADPlain.plain -> b:bytes{b = MACPlain(e,r,ad,f)}

//CF MACed is undefined for now; just added a placeholder def; overlaps with MAC.Msg ? omit the key?
predicate MACed of e:epoch * (;e) MAC.key * ad:(;e)AEADPlain.adata * rg:range * (;e,ad,rg)AEADPlain.plain * (;e) tag
private definition !e,k,rg,ad,p,m. MACed(e,k,ad,rg,p,m) 

val mac: e:succEpoch -> k:(;e) MAC.key ->
  ad:(;e)AEADPlain.adata -> rg:range ->
  p:(;e,ad,rg)AEADPlain.plain ->
  tag:(;e) tag {MACed(e,k,ad,rg,p,tag)}
val verify: e:succEpoch -> k:(;e) MAC.key ->
  ad:(;e)AEADPlain.adata -> rg:range ->
  ps:(;e,ad,rg)parsed ->
  (res:(;e,ad,rg)AEADPlain.plain Result)
	{(!p. res = Correct(p) => (p = ps.plain /\ ps.tag = MACPlain(e,rg,ad,p)) ) /\ (MACed(e,k,ad,rg,ps.plain,ps.tag) => ?p. res = Correct(p))}

predicate type preds = CipherRange of epoch * range * nat // declared here, defined in AEAD
predicate val Encoded: 'e * 'a * 'b * 'c * 'd -> bool

private val pad: l:int { 0 < l /\ l <= 256 } -> b:bytes{Length(b) = l}
//CF we will need a more precise refinement for the MEE proof 

//Cf why not extracting ivL from e? we need finer formulas for the pad computation.
val encode: e:succEpoch{IsAEADCiphersuite(EpochSI(e).cipher_suite)} ->
	ivL:nat -> tlen:nat{tlen <= max_TLSCipher_fragment_length} -> rg:range{CipherRange(e,rg,tlen)} ->
	ad:(;e) AEADPlain.adata -> pl:(;e,ad,rg) AEADPlain.plain -> tag:(;e) tag ->
	p:(;e,tlen) plain{Encoded(e,ad,pl,tag,p)}
val decode: e:succEpoch{IsAEADCiphersuite(EpochSI(e).cipher_suite)} ->
	ivL:nat ->
	ad:(;e) AEADPlain.adata -> rg:range ->
	tlen:nat{tlen - ivL >= ( HashSize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)) + 1) /\
	CipherRange(e,rg,tlen)} ->
	p:(;e,tlen) plain ->
	ps:(;e,ad,rg)parsed{Encoded(e,ad,ps.plain,ps.tag,p) => ps.ok = true}

//CF why do we need "NoPad" variants again? 
val encodeNoPad: e:succEpoch{IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128} ->
	tlen:nat{tlen <= max_TLSCipher_fragment_length} -> rg:range{CipherRange(e,rg,tlen)} ->
	ad:(;e) AEADPlain.adata -> (;e,ad,rg) AEADPlain.plain -> (;e) tag ->
	(;e,tlen) plain
val decodeNoPad: e:succEpoch{IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128} ->
	ad:(;e) AEADPlain.adata -> rg:range ->
	tlen:nat{tlen >= HashSize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)) /\
	CipherRange(e,rg,tlen)} -> (;e,tlen) plain ->
	(;e,ad,rg)parsed

//------------------------------------------------------------------------------------------------------
// Auxiliary definitions and assumptions for typing
//------------------------------------------------------------------------------------------------------

function val MsgBytes: e:epoch * (;e) AEADPlain.adata * bytes -> bytes
private assume !e,ad,x. MsgBytes(e,ad,x) = ad @| VLBytes(2,x)
private ask !e,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(e,ad1,x1) = MsgBytes(e,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

//CF this was too weak: no constraint on f! patched
private assume !e,pl. MAC.Msg(e,pl) <=>
  (not Auth(e) \/
     (?ad,r,f. Length(ad) = 8 + StatefulPlain.ADLength(e) /\
	  pl = MACPlain(e,r,ad,f)))

ask !e,t. not Auth(e) => MAC.Msg(e,t)

//CF Comments:
//CF 
//CF AP and CF agree: Encode is indexed by (e and) its public length after encoding (rathern than its range).
//CF We define function from:
//CF - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
//CF - from tlen to public range of decoded authenticated fragment
//CF - (and the inverse functions)
