module Encode

open Bytes
open TLSInfo

open TLSConstants


//------------------------------------------------------------------------------------------------------
// Interface towards ENC 
//------------------------------------------------------------------------------------------------------
function val PlainLength: e:epoch * tlen:nat -> plen:nat
private type (;e:epoch,tlen:nat) plain = {p: (x:bytes){Length(x) = PlainLength(e,tlen) /\ tlen <= fragmentLength}}
val plain: e:epoch{not Safe(e)} -> tlen:nat{tlen <= fragmentLength} -> b:bytes{Length(b) = PlainLength(e,tlen)} -> (;e,tlen) plain
val repr:  e:epoch{not Safe(e)} -> tlen:nat -> (;e,tlen) plain -> b:bytes{Length(b) = PlainLength(e,tlen)}


val pad: l:int -> b:bytes{Length(b) = l}

val check_split: 
  b:bytes -> i:int -> 
  b1:bytes * b2:bytes { Length(b1) = i /\ b = b1 @| b2 }


//------------------------------------------------------------------------------------------------------
// Interface towards AEAD
//------------------------------------------------------------------------------------------------------
function val IVSize: epoch -> nat
val ivLength: e:succEpoch -> l:nat{l=IVSize(e)}
type (;e:epoch) adata = (;e)AEADPlain.adata

type (;e:epoch,ad:(;e)adata,r:range)AEFragment = {contents: (;e,ad,r)AEADPlain.fragment}

predicate AESays of e:epoch * ad:(;e) adata * r:range * (;e,ad,r)AEFragment 

// Plaintext for AE
private type (;e:epoch,ad:(;e)adata,r:range)AEPlain = f:(;e,ad,r)AEFragment{Auth(e) => AESays(e,ad,r,f)}
val AEPlain: e:epoch{not Auth(e)} -> r:range -> ad:(;e)adata -> (;r)rbytes -> (;e,ad,r)AEPlain
val AERepr:  e:epoch{not Safe(e)} -> r:range -> ad:(;e)adata -> (;e,ad,r)AEPlain -> (;r)rbytes

private val AEConstruct: e:epoch -> r:range -> ad:(;e)adata -> (;e,ad,r)AEADPlain.plain -> (;e,ad,r)AEPlain
private val AEContents:  e:epoch -> r:range -> ad:(;e)adata -> (;e,ad,r)AEPlain -> f:(;e,ad,r)AEADPlain.plain

// Plaintext of MAC
private type (;e:epoch) MACPlain = {macP:bytes}
// Result of MAC
private type (;e:epoch) tag = {macT:bytes}

function val MACPlain : 'a * 'b * 'c * 'd -> 'e
val macPlain: e:epoch -> r:range -> 
  ad:(;e)adata ->
  f:(;e,ad,r)AEPlain ->
  p:(;e)MACPlain{p = MACPlain(e,r,ad,f)}

predicate MACed of e:epoch * (;e) MAC.key * (;e) MACPlain * (;e) tag

val mac: e:succEpoch -> k:(;e) MAC.key -> t:(;e) MACPlain{?r,ad,f. t = MACPlain(e,r,ad,f) /\ 
                                                         (Auth(e) => AESays(e,ad,r,f))}
  -> tag:(;e) tag{Length(tag.macT) = MacKeySize(CipherSuiteMACAlg(EpochSI(e).cipher_suite)) /\ MACed(e,k,t,tag)}
val verify: e:succEpoch -> k:(;e) MAC.key -> text:(;e) MACPlain -> tag:(;e) tag ->
  v:bool{v = true => (?r,ad,f. text = MACPlain(e,r,ad,f) /\ (Auth(e) => AESays(e,ad,r,f))) /\ (MACed(e,k,text,tag) => v = true)}

// Padding computations
val padLength: e:succEpoch -> nat -> nat
function val RangeCipher: epoch * range -> nat // not injective
val rangeCipher: e:succEpoch -> r:range -> tlen:nat{tlen = RangeCipher(e,r) /\ tlen <= fragmentLength}
val cipherRange: e:succEpoch -> tlen:nat{tlen <= fragmentLength} -> r:range{tlen = RangeCipher(e,r)}

predicate val Encoded: 'e * 'a * 'b * 'c * 'd -> bool
val encode: e:succEpoch{IsAEADCiphersuite(EpochSI(e).cipher_suite)} ->
	rg:range -> ad:(;e) adata -> pl:(;e,ad,rg) AEPlain -> tag:(;e) tag ->
	(tlen:nat * p:(;e,tlen) plain){tlen=RangeCipher(e,rg) /\ tlen <= fragmentLength /\ Encoded(e,ad,pl,tag,p)}
val decode: e:succEpoch{IsAEADCiphersuite(EpochSI(e).cipher_suite)} ->
	ad:(;e) adata -> tlen:nat -> p:(;e,tlen) plain ->
	(rg:range * pl:(;e,ad,rg)AEPlain * tag:(;e)tag * ok:bool){
          tlen=RangeCipher(e,rg) /\
          (Encoded(e,ad,pl,tag,p) => ok = true)}
val encodeNoPad: e:succEpoch{IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128} ->
	rg:range -> ad:(;e) adata -> (;e,ad,rg) AEPlain -> (;e) tag ->
	(tlen:nat * (;e,tlen) plain){tlen=RangeCipher(e,rg) /\ tlen <= fragmentLength}
val decodeNoPad: e:succEpoch{IsOnlyMACCiphersuite(EpochSI(e).cipher_suite) \/
                    CipherSuiteENCAlg(EpochSI(e).cipher_suite) = RC4_128} ->
	ad:(;e) adata -> tlen:nat -> (;e,tlen) plain ->
	(rg:range * (;e,ad,rg)AEPlain * (;e)tag){tlen=RangeCipher(e,rg)}
// TODO: Say that the result of encode is "block-aligned" (more generally: compatible with the current enc algorithm)


//------------------------------------------------------------------------------------------------------
// Auxiliary definitions and Assumes for typing (CHECK!)
//------------------------------------------------------------------------------------------------------

function val MsgBytes: e:epoch * (;e) adata * bytes -> bytes
assume !e,ad,x. MsgBytes(e,ad,x) = (ad @| IntBytes(2,Length(x))) @| x 
assume !e,ad1,x1,ad2,x2. (Length(ad1) = Length(ad2) /\
                        MsgBytes(e,ad1,x1) = MsgBytes(e,ad2,x2)) => 
                       (ad1 = ad2 /\ x1=x2)

assume !e,tlen,pl. MAC.Msg(e,pl) <=>
  (not Auth(e) \/
     (?ad,x. Length(ad) = (8 + StatefulPlain.ADLength(e)) /\
	  pl = MsgBytes(e,ad,x)))

ask !e,t. not Auth(e) => MAC.Msg(e,t)



predicate type preds = Unsafe of epoch
private assume !e. Unsafe(e) <=> not Auth(e)
assume !e. IVSize(e) >= 0
assume !e,si. si = EpochSI(e) =>
	( si.protocol_version = SSL_3p0 \/ si.protocol_version = TLS_1p0
		=> IVSize(e) = 0 ) /\
	( si.protocol_version = TLS_1p1 \/ si.protocol_version = TLS_1p2
		=> IVSize(e) = BlockSize(CipherSuiteENCAlg(si.cipher_suite)) )
assume !e,si,tlen. si = EpochSI(e) =>
	( IsOnlyMACCiphersuite(si.cipher_suite) => PlainLength(e,tlen) = tlen ) /\
    ( IsAEADCiphersuite(si.cipher_suite) /\ tlen >= IVSize(e) =>
	  PlainLength(e,tlen) = tlen - IVSize(e) )


// The following conversions embed AEADPlains into AEPlains 
val AEADPlainToAEPlain: e:epoch -> r:range -> ad:(;e)AEADPlain.adata -> (;e,ad,r) AEADPlain.plain -> (;e,ad,r) AEPlain
val AEPlainToAEADPlain: e:epoch -> r:range -> ad:(;e)AEADPlain.adata -> (;e,ad,r) AEPlain -> (;e,ad,r) AEADPlain.plain
assume !e,r,d,f. AESays(e,d,r,f) <=> AEADPlain.AEADSent(e,d,r,f.contents)

//Comments:

// AP and CF agree: Encode is indexed by (e and) its public length, after encoding (and not by range).
// We define function from:
// - public length of ciphertext to public length of encoded plaintext (either identity, or minus iv length)
// - from tlen to public range of decoded authenticated fragment
// - (and the inverse functions)
