module Handshake

// CF old? We haven't yet verified the Handshake implementation against this interface.

open Bytes
open Error
open TLSInfo

open StatefulAEAD
open TLSConstants
open TLSExtensions

(* Message Predicates *)
type HandshakeType =
    | HT_hello_request
    | HT_client_hello
    | HT_server_hello
    | HT_certificate
    | HT_server_key_exchange
    | HT_certificate_request
    | HT_server_hello_done
    | HT_certificate_verify
    | HT_client_key_exchange
    | HT_finished

function val HTBytes: HandshakeType -> bytes

private assume
    HTBytes(HT_hello_request      ) = [|  0uy |] /\ 
    HTBytes(HT_client_hello       ) = [|  1uy |] /\
    HTBytes(HT_server_hello       ) = [|  2uy |] /\
    HTBytes(HT_certificate        ) = [| 11uy |] /\
    HTBytes(HT_server_key_exchange) = [| 12uy |] /\
    HTBytes(HT_certificate_request) = [| 13uy |] /\
    HTBytes(HT_server_hello_done  ) = [| 14uy |] /\
    HTBytes(HT_certificate_verify ) = [| 15uy |] /\
    HTBytes(HT_client_key_exchange) = [| 16uy |] /\
    HTBytes(HT_finished           ) = [| 20uy |]

val htBytes: ht:HandshakeType -> b:bytes{b=HTBytes(ht)}
val parseHt: b:bytes -> (ht:HandshakeType{b=HTBytes(ht)}) Result 

function val MessageBytes: HandshakeType * bytes -> bytes
private definition !ht,b. MessageBytes(ht,b) = HTBytes(ht) @| VLBytes(3,b)
val messageBytes: ht:HandshakeType -> x:bytes -> m:bytes{m = MessageBytes(ht,x)}
val parseMessage: buf:bytes -> ((rem:bytes * ht:HandshakeType * x:bytes * to_log:bytes)
				{buf = to_log @| rem /\ to_log = MessageBytes(ht,x)}) option Result

// Next predicate to make sure we can make fragments
predicate type unsafe = Unsafe of epoch
private assume !ki. Unsafe(ki) <=> not Auth(ki)
val makeFragment: ki:epoch -> b:bytes -> (r:range * (;ki,r) Fragment.fragment * bytes)


(* verify data authenticated by the Finished messages *)
type log = bytes         (* message payloads so far, to be eventually authenticated *) 
type cVerifyData = bytes (* ClientFinished payload *)
type sVerifyData = bytes (* ServerFinished payload *)


// For each Handshake message x, we have:
// XMsg   : a logical specification of its wire format 
// xBytes : a formatting function  
// parseX : a parsing function (returning a Result, as parsing may fail)

function val ClientHelloMsg: (ProtocolVersion * random * sessionID * cipherSuites * Compression list * bytes) -> bytes
definition !cv,clRdm,sid,cls,cm,ext,b.
    ClientHelloMsg(cv,clRdm,sid,cls,cm,ext) =
		MessageBytes(HT_client_hello,
            (VersionBytes(cv) @| 
             clRdm @| 
             VLBytes(1,sid) @| 
             VLBytes(2,CipherSuitesBytes(cls)) @| 
             VLBytes(1,CompressionsBytes(cm)) @| 
             ext)
		)
              
val clientHelloBytes: c:config -> cr:random -> sid:sessionID -> ext:bytes -> m:bytes{m = ClientHelloMsg(c.maxVer,cr,sid,c.ciphersuites,c.compressions,ext)}
val parseClientHello: m:bytes -> 
	( pv:ProtocolVersion * cr:bytes * sid:sessionID * cs:cipherSuites * cm:Compression list * ext:bytes
	  {?cs',cm'. MessageBytes(HT_client_hello,m) = ClientHelloMsg(pv,cr,sid,cs',cm',ext)
              /\ ContainsCipherSuites(cs',cs) /\ ContainsCompressions(cm',cm)}) Result

function val ServerHelloMsg: (ProtocolVersion * random * sessionID * cipherSuite * Compression * bytes) -> bytes
private definition !pv,sr,sid,cs,cm,ext.
	ServerHelloMsg(pv,sr,sid,cs,cm,ext) =
		MessageBytes(HT_server_hello,
			(VersionBytes(pv) @|
			 sr @|
			 VLBytes(1,sid) @|
			 CipherSuiteBytes(cs) @|
			 CompressionBytes(cm) @|
			 ext)
		)

val serverHelloBytes: si:SessionInfo -> sr:random -> ext:bytes ->
	b:bytes{b = ServerHelloMsg(si.protocol_version,sr,si.sessionID,si.cipher_suite,
							   si.compression,ext)}
val parseServerHello: b:bytes ->
	((pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes)
	 {MessageBytes(HT_server_hello,b) = ServerHelloMsg(pv,sr,sid,cs,cm,ext)})
	Result

val helloRequestBytes: b:bytes{b=MessageBytes(HT_hello_request,[||])}
val CCSBytes: b:bytes{b=[|1uy|]}

function val ServerHelloDoneMsg: bytes -> bytes
private definition !x. ServerHelloDoneMsg(x) = MessageBytes(HT_server_hello_done,[||])

val serverHelloDoneBytes: b:bytes{b=ServerHelloDoneMsg([||])}

function val CertificateMsg: Cert.chain -> bytes
private definition !cl. CertificateMsg(cl) = MessageBytes(HT_certificate,VLBytes(3,Cert.CertificateListBytes(cl)))

val serverCertificateBytes: cl:Cert.chain ->
	b:bytes{b = CertificateMsg(cl)}

val clientCertificateBytes: clo: (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	b:bytes{
		( clo = None /\ b = CertificateMsg([]) ) \/
		( ?cl,a',b'. clo = Some((cl,a',b')) /\ b = CertificateMsg(cl)
		)}

val parseClientOrServerCertificate: b:bytes ->
	(bl:Cert.chain{
	  MessageBytes(HT_certificate,b) = CertificateMsg(bl)
	}) Result

function val CertificateRequestTLS12: certType list * Sig.alg list * string list -> bytes
private definition !ct,sa,dn.
	CertificateRequestTLS12(ct,sa,dn) =
		MessageBytes(HT_certificate_request,
		  VLBytes(1,CertTypesBytes(ct)) @|
		  VLBytes(2,SigHashAlgsBytes(sa)) @|
		  VLBytes(2,DistinguishedNamesBytes(dn)))
function val CertificateRequestTLS: certType list * string list -> bytes
private definition !ct,dn.
	CertificateRequestTLS(ct,dn) =
		MessageBytes(HT_certificate_request,
		    VLBytes(1,CertTypesBytes(ct)) @| [||] @| 
		    VLBytes(2,DistinguishedNamesBytes(dn)))
function val CertificateRequestMsg: ProtocolVersion * certType list * Sig.alg list * string list -> bytes
private definition !pv,ct,sa,dn.
	(pv = TLS_1p2 => CertificateRequestMsg(pv,ct,sa,dn) = CertificateRequestTLS12(ct,sa,dn)) /\
	((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) => CertificateRequestMsg(pv,ct,sa,dn) = CertificateRequestTLS(ct,dn))

val sigHashAlgBytesVersion: pv:ProtocolVersion -> cs:cipherSuite ->
	b:bytes{(pv = TLS_1p2 => b=VLBytes(2,SigHashAlgsBytes(DefaultSigHashAlgs(pv,cs)))) /\
			((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) =>
				b = [||])}

val parseSigHashAlgVersion: pv:ProtocolVersion -> b:bytes ->
	((a:(Sig.alg list) * r:bytes){
		(pv = TLS_1p2 =>
			(b = VLBytes(2,SigHashAlgsBytes(a)) @| r) 
		) /\
		((pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) =>
			a = [] /\  r=b)
	}) Result

val certificateRequestBytes: sign:bool -> cs:cipherSuite -> pv:ProtocolVersion ->
	b:bytes{b = CertificateRequestMsg(pv,DefaultCertTypes(sign,cs),DefaultSigHashAlgs(pv,cs),[])}

val parseCertificateRequest: pv:ProtocolVersion -> b:bytes ->
	((ctl:certType list * al:(Sig.alg list) * sl:string list){
		MessageBytes(HT_certificate_request,b) = CertificateRequestMsg(pv,ctl,al,sl)})	 Result

//function val ClientKeyExchangeMsg_RSA: pv:ProtocolVersion * si:SessionInfo * RSAKeys.pk * (;si,pv)CRE.rsapms -> bytes
function val ClientKeyExchangeMsg_RSA: pv:ProtocolVersion * bytes -> bytes
private definition !pv,encpms,b.
       ((pv = TLS_1p2 \/ pv = TLS_1p1 \/ pv = TLS_1p0) => ClientKeyExchangeMsg_RSA(pv,encpms) = MessageBytes(HT_client_key_exchange,VLBytes(2,encpms))) /\
	(pv = SSL_3p0 => ClientKeyExchangeMsg_RSA(pv,encpms) = MessageBytes(HT_client_key_exchange,encpms))

val encpmsBytesVersion: pv:ProtocolVersion -> encpms:bytes ->
	b:bytes{(pv = SSL_3p0 => b=encpms) /\
		((pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2) => b=VLBytes(2,encpms))}

val parseEncpmsVersion: pv:ProtocolVersion -> b:bytes ->
	(encpms:bytes{
		(pv = SSL_3p0 => b=encpms) /\
		((pv = TLS_1p0 \/ pv = TLS_1p1 \/ pv = TLS_1p2) => b = VLBytes(2,encpms))
	}) Result

// For the next two functions, the returned encpms is a ghost variable used to
// avoid an existential.
val clientKEXBytes_RSA: si:SessionInfo -> c:config ->
	((b:bytes * encpms:bytes * pms:(;Cert.RSAPKCert(si.serverID),c.maxVer)CRE.rsapms){
		b=ClientKeyExchangeMsg_RSA(si.protocol_version,encpms)
		}) Result
val parseClientKEX_RSA: si:SessionInfo -> RSAKeys.sk -> pv:ProtocolVersion -> config -> b:bytes ->
	((encpms:bytes * (;Cert.RSAPKCert(si.serverID),pv)CRE.rsapms){
		ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) = MessageBytes(HT_client_key_exchange,b)
	}) Result

function val ClientKeyExchangeMsg_DHE: bytes -> bytes
private definition !b.
	ClientKeyExchangeMsg_DHE(b) =
		MessageBytes(HT_client_key_exchange,
			VLBytes(2,b))

val clientKEXExplicitBytes_DH: gx:bytes ->
	b:bytes{b = ClientKeyExchangeMsg_DHE(gx)}
val parseClientKEXExplicit_DH: p:DHGroup.p -> b:bytes ->
	(gx:(;p)elt{
		MessageBytes(HT_client_key_exchange,b) = ClientKeyExchangeMsg_DHE(gx)
	}) Result
val clientKEXImplicitBytes_DH: bytes
val parseClientKEXImplicit_DH: bytes -> unit Result

(* Digitally signed and DHE parameters *)
function val DigitallySignedBytes: Sig.alg * bytes * ProtocolVersion -> bytes
private definition !a,p,pv.
	(pv = TLS_1p2 => DigitallySignedBytes(a,p,pv) = SigHashAlgBytes(a) @| VLBytes(2,p)) /\
	( (pv = TLS_1p1 \/ pv = TLS_1p0 \/ pv = SSL_3p0) => DigitallySignedBytes(a,p,pv) = VLBytes(2,p))

val digitallySignedBytes: a:Sig.alg -> p:bytes -> pv:ProtocolVersion ->
	b:bytes{b = DigitallySignedBytes(a,p,pv)}
val parseDigitallySigned: al:Sig.alg list -> b:bytes -> pv:ProtocolVersion ->
	((a:Sig.alg * p:bytes){
		b = DigitallySignedBytes(a,p,pv)
		// /\ SigHashAlgContains(al,a)
	}) Result

function val DHEParamBytes: bytes * bytes * bytes -> bytes
private definition !p,g,y.
	DHEParamBytes(p,g,y) =
		VLBytes(2,p) @|
		VLBytes(2,g) @|
		VLBytes(2,y)
val dheParamBytes: p:bytes -> g:bytes -> y:bytes ->
	b:bytes{b = DHEParamBytes(p,g,y)}
val parseDHEParams: b:bytes -> 
 (p:DHGroup.p * g:(;p)DHGroup.elt * y:(;p)DHGroup.elt * rem:bytes {
	b = (DHEParamBytes(p,g,y) @| rem)
 }) Result

function val ServerKeyExchangeMsg_DHE:  ProtocolVersion * p:bytes * g:bytes * y:bytes * Sig.alg * sign:bytes-> bytes
private definition !pv,p,g,y,a,sign.
	ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign) =
		MessageBytes(HT_server_key_exchange,
			DHEParamBytes(p,g,y) @| DigitallySignedBytes(a,sign,pv))

val serverKeyExchangeBytes_DHE: dheb:bytes{?p,g,y. dheb = DHEParamBytes(p,g,y)} ->
	a:Sig.alg -> sign:bytes -> pv:ProtocolVersion ->
	b:bytes{?p,g,y. dheb = DHEParamBytes(p,g,y) /\
		b = ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign)}
val parseServerKeyExchange_DHE: pv:ProtocolVersion -> cs:cipherSuite -> 
	b:bytes ->
	((p:DHGroup.p * g:(;p)DHGroup.elt * y:(;p)DHGroup.elt * a:Sig.alg * sign:bytes){
	MessageBytes(HT_server_key_exchange,b) =
		ServerKeyExchangeMsg_DHE(pv,p,g,y,a,sign)
	}) Result

function val ServerKeyExchangeMsg_DH_anon: bytes * bytes * bytes -> bytes

val serverKeyExchangeBytes_DH_anon: bytes -> bytes -> bytes -> bytes
val parseServerKeyExchange_DH_anon: bytes -> (bytes * bytes * bytes) Result

//function val CertificateVerifyMsg: si:SessionInfo * (;si)PRF.masterSecret * a:Sig.alg * Cert.chain * (;a)Sig.pkey * log -> bytes
function val CertificateVerifyMsg: ProtocolVersion * Sig.alg * bytes -> bytes
private definition !pv,a,sign.
		 CertificateVerifyMsg(pv,a,sign) = MessageBytes(HT_certificate_verify,DigitallySignedBytes(a,sign,pv))

(* ------------------------------------------------------ *)
(* We need here and now to deinfe the Sig.Msg predicate,  *)
(* So that we can sign in make/check certificate verify   *)
(* ------------------------------------------------------ *)

private assume !a,k,t. Sig.Msg(a,k,t)

val makeCertificateVerifyBytes: si:SessionInfo -> (;si)PRF.masterSecret -> a:Sig.alg -> (;a)Sig.skey -> l:log ->
	b:bytes * sign:bytes{
	  b = CertificateVerifyMsg(si.protocol_version,a,sign)
	}
val certificateVerifyCheck: si:SessionInfo -> (;si)PRF.masterSecret -> al:Sig.alg list -> l:log -> payload:bytes ->
	b:bool * sign:bytes{
	  b = true => ?a.
		MessageBytes(HT_certificate_verify,payload) = CertificateVerifyMsg(si.protocol_version,a,sign)
		// /\ Something good about signature check (depends on si.protocol_version)
	}

//function val ServerFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ServerFinishedMsg: sVerifyData -> bytes

private assume !svd. ServerFinishedMsg(svd) = MessageBytes(HT_finished,svd)

//function val ClientFinishedMsg: si:SessionInfo * (;si)PRF.masterSecret * log -> bytes
function val ClientFinishedMsg: cVerifyData -> bytes

private assume !svd. ClientFinishedMsg(svd) = MessageBytes(HT_finished,svd)

predicate ServerLogBeforeClientCertificateRSA of SessionInfo * ProtocolVersion * log
predicate ServerLogBeforeClientCertificateRSA_Auth of SessionInfo * ProtocolVersion * log 
predicate ServerLogBeforeClientCertificateRSA_NoAuth of SessionInfo * ProtocolVersion * log 

private assume !si,pv,l.
  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l)))

private assume !si,pv,l. 
  ServerLogBeforeClientCertificateRSA_Auth(si,pv,l) <=>
  (?cs,cm,sess,ex1,ex2,ctl,sal,nl. 
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
          CertificateMsg(si.serverID) @|
          CertificateRequestMsg(si.protocol_version,ctl,sal,nl) @|
          ServerHelloDoneMsg([||]))))

private assume !si,pv,l. 
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l) <=>
  (?cs,cm,sess,ex1,ex2. 
     l = (ClientHelloMsg(pv,si.init_crand,sess,cs,cm,ex1) @|
          (ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2) @|
          CertificateMsg(si.serverID) @|
          ServerHelloDoneMsg([||]))))
          

predicate ServerLogBeforeClientKeyExchangeRSA of SessionInfo * ProtocolVersion * log 
predicate ServerLogBeforeClientKeyExchangeRSA_Auth of SessionInfo * ProtocolVersion * log 
predicate ServerLogBeforeClientKeyExchangeRSA_NoAuth of SessionInfo * ProtocolVersion * log 

private assume !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA(si,pv,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l)))

private assume !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l) <=>
  (?l'. ServerLogBeforeClientCertificateRSA_Auth(si,pv,l') /\
        l = l' @| CertificateMsg(si.clientID))

private assume !si,pv,l.
  ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l) <=>
  ServerLogBeforeClientCertificateRSA_NoAuth(si,pv,l)

predicate ServerLogBeforeClientCertificateVerifyRSA of SessionInfo * log 
predicate ServerLogBeforeClientCertificateVerifyRSA_Auth of SessionInfo * log 
predicate ServerLogBeforeClientCertificateVerifyRSA_NoAuth of SessionInfo * log 

private assume !si,pv,l.
  ServerLogBeforeClientCertificateVerifyRSA(si,l) <=>
  ((si.client_auth = true /\  ServerLogBeforeClientCertificateVerifyRSA_Auth(si,l)) \/
   (si.client_auth = false /\  ServerLogBeforeClientCertificateVerifyRSA_NoAuth(si,l)))
private assume !si,l.
  ServerLogBeforeClientCertificateVerifyRSA_Auth(si,l) <=>
  (?pv,l',encpms. ServerLogBeforeClientKeyExchangeRSA_Auth(si,pv,l) /\
                 l = l' @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))
private assume !si,l.
  ServerLogBeforeClientCertificateVerifyRSA_NoAuth(si,l) <=>
  (?pv,l',encpms. ServerLogBeforeClientKeyExchangeRSA_NoAuth(si,pv,l) /\
                 l = l' @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

predicate ServerLogBeforeClientCertificateVerify of SessionInfo * log
private assume 
 !si,l. ServerLogBeforeClientCertificateVerify(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ServerLogBeforeClientCertificateVerifyRSA(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a)))

predicate ServerLogBeforeClientFinishedRSA of SessionInfo * log 
predicate ServerLogBeforeClientFinishedRSA_Auth of SessionInfo * log 
predicate ServerLogBeforeClientFinishedRSA_NoAuth of SessionInfo * log

private assume !si,pv,l.
  ServerLogBeforeClientFinishedRSA(si,l) <=>
  ((si.client_auth = true /\  si.clientID <> [] /\ ServerLogBeforeClientFinishedRSA_Auth(si,l)) \/
   ((si.client_auth = false \/  si.clientID = []) /\ ServerLogBeforeClientFinishedRSA_NoAuth(si,l)))

private assume !si,l.
  ServerLogBeforeClientFinishedRSA_Auth(si,l) <=>
  (?l',a,sign. ServerLogBeforeClientCertificateVerifyRSA_Auth(si,l') /\
   (l = l' @| CertificateVerifyMsg(si.protocol_version,a,sign)))

private assume !si,l.
  ServerLogBeforeClientFinishedRSA_NoAuth(si,l) <=>
  ServerLogBeforeClientCertificateVerifyRSA_NoAuth(si,l)

predicate ServerLogBeforeClientFinished of SessionInfo * log
private assume 
 !si,l. ServerLogBeforeClientFinished(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ServerLogBeforeClientFinishedRSA(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a)))


predicate ServerLogBeforeServerFinishedRSA of SessionInfo * log 
predicate ServerLogBeforeServerFinishedRSA_Auth of SessionInfo * log 
predicate ServerLogBeforeServerFinishedRSA_NoAuth of SessionInfo * log 

private assume !si,pv,l.
  ServerLogBeforeServerFinishedRSA(si,l) <=>
  ((si.client_auth = true /\ ServerLogBeforeServerFinishedRSA_Auth(si,l)) \/
   (si.client_auth = false /\ ServerLogBeforeServerFinishedRSA_NoAuth(si,l)))

private assume !si,l.
  ServerLogBeforeServerFinishedRSA_Auth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedRSA_Auth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

private assume !si,l.
  ServerLogBeforeServerFinishedRSA_NoAuth(si,l) <=>
  (?l',cvd. ServerLogBeforeClientFinishedRSA_NoAuth(si,l') /\
   (l' = l @| ClientFinishedMsg(cvd)))

predicate ServerLogBeforeServerFinished of SessionInfo * log
private assume 
 !si,l. ServerLogBeforeServerFinished(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ServerLogBeforeServerFinishedRSA(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a)))


predicate ClientLogBeforeServerHello of random * log 
predicate ClientLogBeforeServerCertificateRSA of SessionInfo * log 

private assume !cr,sid,l.
  ClientLogBeforeServerHello(cr,l) <=>
  (?pv,csid,cs,cm,ex1. l = ClientHelloMsg(pv,cr,sid,cs,cm,ex1))

ask !pv,cs,cm,ex1,cr,sid. ClientLogBeforeServerHello(cr,ClientHelloMsg(pv,cr,sid,cs,cm,ex1))

private assume !si,l.
  ClientLogBeforeServerCertificateRSA(si,l) <=>
  (?l',cr,ex2. 
     ClientLogBeforeServerHello(cr,l') /\
     l = l' @| 
     ServerHelloMsg(si.protocol_version,si.init_srand,si.sessionID,si.cipher_suite,si.compression,ex2))

predicate ClientLogBeforeCertificateRequestRSA of SessionInfo * log 


(* KB HERE: add precise agreement parameters to these predicates *)

private assume !si,pv,l. 
  ClientLogBeforeCertificateRequestRSA(si,l) <=>
  (?l'. ClientLogBeforeServerCertificateRSA(si,l') /\
     l = l @| CertificateMsg(si.serverID))

predicate ClientLogBeforeServerHelloDoneRSA of SessionInfo * log 
predicate ClientLogBeforeServerHelloDoneRSA_Auth of SessionInfo * log 
predicate ClientLogBeforeServerHelloDoneRSA_NoAuth of SessionInfo * log 

private assume !si,pv,l. 
  ClientLogBeforeServerHelloDoneRSA(si,l) <=>
  ((si.client_auth = true /\ ClientLogBeforeServerHelloDoneRSA_Auth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l)))

private assume !si,pv,l. 
  ClientLogBeforeServerHelloDoneRSA_Auth(si,l) <=>
  (?l',ctl,sal,nl. ClientLogBeforeCertificateRequestRSA(si,l) /\
     l = CertificateRequestMsg(si.protocol_version,ctl,sal,nl))

private assume !si,pv,l. 
  ClientLogBeforeServerHelloDoneRSA_NoAuth(si,l) <=>
  ClientLogBeforeCertificateRequestRSA(si,l)

predicate ClientLogBeforeClientFinishedRSA of SessionInfo * log 
predicate ClientLogBeforeClientFinishedRSA_Auth of SessionInfo * log 
predicate ClientLogBeforeClientFinishedRSA_TryNoAuth of SessionInfo * log 
predicate ClientLogBeforeClientFinishedRSA_NoAuth of SessionInfo * log 

private assume !si,pv,l. 
  ClientLogBeforeClientFinishedRSA(si,l) <=>
  ((si.client_auth = true /\ si.clientID <> [] /\ ClientLogBeforeClientFinishedRSA_Auth(si,l)) \/
   (si.client_auth = true /\ si.clientID = [] /\ ClientLogBeforeClientFinishedRSA_TryNoAuth(si,l)) \/
   (si.client_auth = false /\ ClientLogBeforeClientFinishedRSA_NoAuth(si,l)))

private assume !si,pv,l. 
  ClientLogBeforeClientFinishedRSA_Auth(si,l) <=>
  (?l',l'',encpms,a,sign. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l'' = l' @| ServerHelloDoneMsg([||]) 
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms) /\
     l = l''
         @| CertificateVerifyMsg(si.protocol_version,a,sign)) // FIXME: ?k. sign = Sign(k,l'')

private assume !si,pv,l. 
  ClientLogBeforeClientFinishedRSA_TryNoAuth(si,l) <=>
  (?l',l'',encpms. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||]) 
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))


private assume !si,pv,l. 
  ClientLogBeforeClientFinishedRSA_Auth(si,l) <=>
  (?l',encpms. ClientLogBeforeServerHelloDoneRSA_Auth(si,l') /\
     l = l' @| ServerHelloDoneMsg([||]) 
         @| CertificateMsg(si.clientID)
         @| ClientKeyExchangeMsg_RSA(si.protocol_version,encpms))

predicate ClientLogBeforeClientFinished of SessionInfo * log
private assume 
 !si,l. ClientLogBeforeClientFinished(si,l) <=>
  ((?a. si.cipher_suite = CipherSuite(RSA,a) /\ ClientLogBeforeClientFinishedRSA(si,l)) \/
   (!a. si.cipher_suite <> CipherSuite(RSA,a)))

predicate ClientLogBeforeServerFinished of SessionInfo * log 
private assume !si,l. 
  ClientLogBeforeServerFinished(si,l) <=>
  (?l',cvd. ClientLogBeforeClientFinished(si,l') /\
     l = l' @| ClientFinishedMsg(cvd))

 
type serverState =  (* note that the CertRequest bits are determined by the config *) 
                    (* we may omit some ProtocolVersion, mostly a ghost variable *)
   | ClientHello                  of cVerifyData * sVerifyData

   | ClientCertificateRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log){ServerLogBeforeClientCertificateRSA(si,pv,l)}
   | ServerCheckingCertificateRSA of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log * b:bytes){ServerLogBeforeClientKeyExchangeRSA(si,pv,l)}
   | ClientKeyExchangeRSA         of (si:SessionInfo * pv:ProtocolVersion * sk:RSAKeys.sk * l:log){ServerLogBeforeClientKeyExchangeRSA(si,pv,l)}

   | ClientCertificateDH          of si:SessionInfo * l:log
   | ServerCheckingCertificateDH  of si:SessionInfo * l:log * b:bytes
   | ClientKeyExchangeDH          of si:SessionInfo * l:log

   | ClientCertificateDHE         of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log
   | ServerCheckingCertificateDHE of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log * bytes
   | ClientKeyExchangeDHE         of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | ClientKeyExchangeDH_anon     of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * (;p,g,gx)DH.secret * log

   | CertificateVerify            of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientCertificateVerify(si,l)}
   | ClientCCS                    of (si:SessionInfo * (;si)PRF.masterSecret * l:log){ServerLogBeforeClientFinished(si,l)}
   | ClientFinished               of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeClientFinished(si,l)}
   (* by convention, the parameters are named si, cv, cr', sr', ms, log *)
   | ServerWritingCCS             of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.writer * cVerifyData * l:log){
                                       EpochSI(e)=si /\ ServerLogBeforeServerFinished(si,l)}
   | ServerWritingFinished        of si:SessionInfo * (;si)PRF.masterSecret * cVerifyData * sVerifyData

   | ServerWritingCCSResume       of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;epochSI(ew))PRF.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ClientCCSResume              of e:succEpoch * (;e)StatefulAEAD.reader * sVerifyData * (;EpochSI(e))PRF.masterSecret * log
   | ClientFinishedResume         of si:SessionInfo * (;si)PRF.masterSecret * sVerifyData * log

   | ServerIdle                   of cVerifyData * sVerifyData
   (* the ProtocolVersion is the highest TLS version proposed by the client *)

type clientState = 
   | ServerHello                  of cr:crand * sid:sessionID (* * bytes for extensions? *) * cvd:cVerifyData * svd:sVerifyData * l:log{ClientLogBeforeServerHello(cr,l)}

   | ServerCertificateRSA         of si:SessionInfo * l:log{ClientLogBeforeServerCertificateRSA(si,l)}
   | ClientCheckingCertificateRSA of si:SessionInfo * l:log * b:bytes{ClientLogBeforeCertificateRequestRSA(si,l)}
   | CertificateRequestRSA        of si:SessionInfo * l:log{ClientLogBeforeCertificateRequestRSA(si,l)} (* both certificate request and hellodone will be accepted *)
   | ServerHelloDoneRSA           of si:SessionInfo * c:Cert.sign_cert * l:log{ClientLogBeforeServerHelloDoneRSA(si,l)}

   | ServerCertificateDH          of SessionInfo * log
   | ClientCheckingCertificateDH  of SessionInfo * log * bytes
   | CertificateRequestDH         of SessionInfo * log (* We pick our cert and store it in sessionInfo as soon as the server requests it.
                                                         We put None if we don't have such a certificate, and we know whether to send
                                                         the Certificate message or not based on the state when we receive the Finished message *)
   | ServerHelloDoneDH            of SessionInfo * log

   | ServerCertificateDHE         of SessionInfo * log
   | ClientCheckingCertificateDHE of SessionInfo * log * bytes
   | ServerKeyExchangeDHE         of SessionInfo * log
   | CertificateRequestDHE        of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log
   | ServerHelloDoneDHE           of SessionInfo * Cert.sign_cert * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ServerKeyExchangeDH_anon of SessionInfo * log (* Not supported yet *)
   | ServerHelloDoneDH_anon of SessionInfo * p:DHGroup.p * g:(;p)DHGroup.g * gx:(;p)DHGroup.elt * log

   | ClientWritingCCS       of si:SessionInfo * (;si)PRF.masterSecret * l:log{ClientLogBeforeClientFinished(si,l)}
   | ServerCCS              of (si:SessionInfo * (;si)PRF.masterSecret * e:succEpoch * (;e)StatefulAEAD.reader * cVerifyData * l:log){ EpochSI(e)=si  
       /\ ClientLogBeforeServerFinished(si,l) }
   | ServerFinished         of si:SessionInfo * (;si)PRF.masterSecret * cVerifyData * l:log{ClientLogBeforeServerFinished(si,l)}

   | ServerCCSResume        of (ew:succEpoch * (;ew)StatefulAEAD.writer * er:succEpoch * (;er)StatefulAEAD.reader * (;EpochSI(ew))PRF.masterSecret * log){EpochSI(ew)=EpochSI(er)}
   | ServerFinishedResume   of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRF.masterSecret * log
   | ClientWritingCCSResume of e:succEpoch * (;e)StatefulAEAD.writer * (;EpochSI(e))PRF.masterSecret * sVerifyData * log
   | ClientWritingFinishedResume of cVerifyData * sVerifyData

   | ClientIdle             of cVerifyData * sVerifyData

type protoState = // Cannot use Client and Server, otherwise clashes with Role
  | PSClient of clientState
  | PSServer of serverState

private type pre_hs_state = {
  (* I/O buffers *)
  hs_outgoing    : bytes;                  (* outgoing data *)
  hs_incoming    : bytes;                  (* partial incoming HS message *)
  (* local configuration *)
  poptions: config; 
  sDB: SessionDB.SessionDB;
  (* current handshake & session we are establishing *) 
  pstate: protoState;
}

(*--- controlinterface *)
(* Control Interface *)

private type (;ci:ConnectionInfo) hs_state = pre_hs_state
function val Config: ci:ConnectionInfo * s:(;ci)hs_state -> config
private assume !ci,s. Config(ci,s) = s.poptions

predicate val Authorize: config * Cert.chain -> bool
predicate val Complete: ConnectionInfo * config -> bool
predicate EvSentFinishedFirst of ConnectionInfo * bool
// AP: Not sure the SentCCS event is useful;
// AP: rather I'd welcome a SentFinished event, to model False Start
predicate val SentCCS: epoch -> bool
private assume !e. SentCCS(e)

function val HSOutStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val CCSOutStream: ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_out)stream
function val HSInStream:   ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream
function val CCSInStream:  ci:ConnectionInfo * (;ci)hs_state -> 'a //(;ci.id_in) stream

predicate EmptyStreams of ci:ConnectionInfo * (;ci)hs_state
predicate SameStreams of ci:ConnectionInfo * (;ci)hs_state * (;ci)hs_state
assume !ci,s. EmptyStreams(ci,s) <=> (
		EmptyStream(ci.id_in,HSInStream(ci,s)) /\
		EmptyStream(ci.id_in,CCSInStream(ci,s)) /\
		EmptyStream(ci.id_out,HSOutStream(ci,s)) /\
		EmptyStream(ci.id_out,CCSOutStream(ci,s)) )
assume !ci,s,s'. SameStreams(ci,s,s') <=> (
		HSInStream(ci,s') = HSInStream(ci,s) /\
		CCSInStream(ci,s') = CCSInStream(ci,s) /\
		HSOutStream(ci,s') = HSOutStream(ci,s) /\
		CCSOutStream(ci,s') = CCSOutStream(ci,s) )

type (;ci:ConnectionInfo,c:config) nextState = s:(;ci)hs_state {Config(ci,s) = c}

val init:  rl:Role  -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){Config(ci,s) = c /\ 
                ci.role = rl /\
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}
		                    
val resume:      nextSID:sessionID -> c:config  ->
	(ci:ConnectionInfo * s:(;ci)hs_state){ Config(ci,s) = c /\ 
                ci.role = Client /\          
		IsInitEpoch(ci.id_in) /\
		IsInitEpoch(ci.id_out)}

val rehandshake: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ 
                 (b = false /\ Config(ci,s') = Config(ci,s)))}

val rekey: ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
	   b:bool * s':(;ci)hs_state{((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}
		
val request:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:config  ->
                 b:bool * s':(;ci)hs_state{
		((b = true /\ Config(ci,s') = c) \/ (b = false /\ Config(ci,s') = Config(ci,s)))}

val getPrincipal:  ci:ConnectionInfo -> s:(;ci)hs_state -> string
val invalidateSession: ci:ConnectionInfo -> s:(;ci)hs_state -> s':(;ci,Config(ci,s))nextState
(*{SameStreams(ci,s,s')} *)

val getNextEpochs: ci:ConnectionInfo -> si:SessionInfo -> crand -> srand -> ci':ConnectionInfo{IsSuccEpoch(ci'.id_in) /\ IsSuccEpoch(ci'.id_out) /\ EpochSI(ci'.id_in) = si /\ EpochSI(ci'.id_out) = si}

(*--- networkinterface *)
(* Network Interface*)

type (;ci:ConnectionInfo, hs:(;ci) hs_state) outgoing =
  | OutIdle of s':(;ci,Config(ci,hs))nextState
  | OutSome of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState)
  | OutCCS of  (rg:range * f:(;ci.id_out,rg)Fragment.fragment * 
               ci':ConnectionInfo * cs:(;ci'.id_out)StatefulAEAD.state * s':(;ci',Config(ci,hs))nextState)
               { StatefulPlain.EmptyHistory(ci'.id_out,cs.history) /\ 
                 ci.id_out = Pred(ci'.id_out) /\
                 ci.id_in = ci'.id_in /\
                 ci.role = ci'.role }
  | OutFinished of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState){
				EvSentFinishedFirst(ci,true)}
  | OutComplete of (rg:range * f:(;ci.id_out,rg)Fragment.fragment * s':(;ci,Config(ci,hs))nextState)
                   {Complete(ci,Config(ci,hs))}
val next_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> (;ci,s)outgoing

type (;ci:ConnectionInfo,c:config)incoming =
  | InAck of (;ci,c)nextState
  | InVersionAgreed  of (;ci,c)nextState * ProtocolVersion
  | InQuery of Cert.chain * advice:bool * (;ci,c)nextState
  | InFinished of (;ci,c)nextState {EvSentFinishedFirst(ci,false)}
  | InComplete of (;ci,c)nextState {Complete(ci,c)}
  | InError of alertDescription * string * (;ci,c)nextState
val recv_fragment: ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incoming
val authorize:     ci:ConnectionInfo -> s:(;ci)hs_state -> c:Cert.chain {Authorize(Config(ci,s),c)}->
				   (;ci,Config(ci,s))incoming

type (;ci:ConnectionInfo,c:config)incomingCCS =
  | InCCSAck of ci':ConnectionInfo * (;ci'.id_in)StatefulAEAD.state * (;ci',c)nextState
				{ci.id_out = ci'.id_out /\ ci.id_in = Pred(ci'.id_in)}
  | InCCSError of alertDescription * string * (;ci,c)nextState
val recv_ccs     : ci:ConnectionInfo -> s:(;ci)hs_state -> rg:range -> (;ci.id_in,rg)Fragment.fragment -> 
                   (;ci,Config(ci,s))incomingCCS

val getMinVersion:        ci:ConnectionInfo -> (;ci)hs_state -> ProtocolVersion

(*--- end *)

(* INTERNAL HS VERIFICATION (ALL THESE DEFS ARE PRIVATE) *)

val find_client_cert_sign: certType list -> Sig.alg list -> string list ->
	ProtocolVersion -> Cert.hint -> Cert.sign_cert
val getCertificateBytes: si:SessionInfo ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> 
  (b:bytes * cl:Cert.chain){
    (si.client_auth = true /\  b = CertificateMsg(cl)) \/
    (si.client_auth = false /\ b = [||])}

val getCertificateVerifyBytes: si:SessionInfo -> (;si) PRF.masterSecret ->
  cert_req:(Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> log ->
  b:bytes{(!cl,a,k. (cert_req = Some((cl,a,k)) /\ si.client_auth = true) => 
                    (?sign. b = CertificateVerifyMsg(si.protocol_version,a,sign))) /\
          ((cert_req = None \/ si.client_auth = false) => b = [||])}

val prepare_client_output_full_RSA: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option -> l:log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val prepare_client_output_full_DHE: ci:ConnectionInfo -> (;ci)hs_state ->
	si:SessionInfo -> (Cert.chain * a:Sig.alg * (;a)Sig.skey) option ->
	p:DHGroup.p -> (;p)DHGroup.g -> (;p)DHGroup.elt -> log ->
	((;ci)hs_state * si':SessionInfo * (;si)PRF.masterSecret * log) Result
val on_serverHello_full: cr:crand -> l:log -> to_log:bytes ->
         (pv:ProtocolVersion * sr:random * sid:sessionID * cs:cipherSuite * cm:Compression * ext:bytes){
         ClientLogBeforeServerHello(cr,l) /\
         to_log = ServerHelloMsg(pv,sr,sid,cs,cm,ext)} ->
	protoState
val parseMessageState: ci:ConnectionInfo -> hs:(;ci)hs_state ->
	(hs':(;ci)hs_state * ht:HandshakeType * pl:bytes * to_log:bytes{Config(ci,hs) = Config(ci,hs') /\
                                                                     to_log = MessageBytes(ht,pl)}) option Result
val recv_fragment_client: ci:ConnectionInfo -> s:(;ci)hs_state -> ProtocolVersion option ->
	(;ci,Config(ci,s))incoming

val prepare_server_output_full_RSA: ci:ConnectionInfo -> (;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> Sig.alg list -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. l = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        }->
	((;ci)hs_state * ProtocolVersion) Result
val prepare_server_output_full_DH: 'a -> 'b -> 'c -> 'd -> res:('e Result){?x,y. res = Error(x,y)}
val prepare_server_output_full_DHE: ci:ConnectionInfo -> (;ci)hs_state -> SessionInfo ->
	Sig.alg list -> cVerifyData -> sVerifyData -> log ->
	((;ci)hs_state * ProtocolVersion) Result
val prepare_server_output_full_DH_anon: ci:ConnectionInfo -> (;ci)hs_state -> SessionInfo ->
	cVerifyData -> sVerifyData -> log ->
	((;ci)hs_state * ProtocolVersion) Result
val prepare_server_output_full: ci:ConnectionInfo -> (;ci)hs_state -> si:SessionInfo ->
	pv:ProtocolVersion -> Sig.alg list -> cVerifyData -> sVerifyData -> l:log{
          ?csid,cs,cm,ex. l = ClientHelloMsg(pv,si.init_crand,csid,cs,cm,ex)
        } ->
	((;ci)hs_state * ProtocolVersion) Result
val negotiate: 'a list -> 'a list -> 'a option
val prepare_server_output_resumption: ci:ConnectionInfo -> (;ci)hs_state -> crand ->
	si:SessionInfo -> (;si)PRF.masterSecret -> cVerifyData -> sVerifyData -> log ->
	(;ci)hs_state
val startServerFull: ci:ConnectionInfo -> s:(;ci)hs_state -> 
	(ProtocolVersion * crand * sessionID * cipherSuites * Compression list * bytes) ->// CHello
	cVerifyData -> sVerifyData -> l:log -> ((;ci)hs_state * ProtocolVersion) Result
val recv_fragment_server: ci:ConnectionInfo -> s:(;ci)hs_state -> pv:ProtocolVersion option ->
	(;ci,Config(ci,s))incoming
val enqueue_fragment: ci:ConnectionInfo -> (;ci)hs_state -> bytes -> (;ci)hs_state


/// Misc

// 
// //TODO? change sessionID to uniformally use [||] instead of None.
// 
// /// Handshake message format 
// 
// // we need a precise spec, as verifyData is a series of such messages.
// 
// function val MessageBytes: HandshakeType * bytes -> bytes 
// definition !ht,payload. MessageBytes(ht,payload) = HTBytes(ht) @| VLBytes(3,data)
// 
// val makeMessage: ht:HandshakeType -> payload:bytes -> msg:bytes { msg = MessageBytes(ht,payload) }
// val parseMessage: hs_state -> (hs_state * ht:HandshakeType * payload:bytes * msg:bytes { msg = MessageBytes(ht,payload) }) option
// //TODO unclear how to usefully maintain hs_state invariant; pass instead state.incoming? 
// 
// /// Client Hello 
// 
// 
// function val ClientHelloBytes: ... 
// definition !cv,clRdm,sid,clientCipherSuites,cm,ext.
//   ClientHelloBytes(cv,clRdm,sid,clientCipherSuites,cm,ext) = 
//     MessageBytes(
// 	  HT_client_hello, 
//       VersionBytes cv @| CRBytes clRdm @| SidBytes sid @| CipherSuitesBytes clientCipherSuites @| CompressionsBytes cm @| ext )
// 
// //TODO get rid of the intermediate record
// //TODO factor out extension processing
// val makeClientHelloBytes: ... -> msg:bytes { msg = ClientHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( cv,clRdm,sid,clientCipherSuites,cm,ext { MessageBytes(HT_client_hello,payload) =  ClientHelloBytes(...) }  ) Result
// 
// /// Server Hello 
// 
// function val ServerHelloBytes: ... // (sv,sr,sid,cs,cm,extensions) 
// definition !sv,sr,sid,cs,cm,ext.
//   ServerHelloBytes(sv,sr,sid,cs,cm,ext) =
//     MessageBytes(
// 	  HT_server_hello, 
//       VersionBytes sv @| CRBytes sr @| SidBytes sid @| CipherSuiteBytes cs @| CompressionsBytes cm @| ext )
// 
// val makeServerHelloBytes: ... -> msg:bytes { msg = ServerHelloBytes(...) } 
// val parseClientHello: payload:bytes -> ( sv,sr,sid,cs,cm,ext { MessageBytes(HT_server_hello,payload) = ServerHelloBytes(sv,sr,sid,cs,cm,ext) } ) Result
// 
// /// Certificate chains
// 
// function val CertificateListBytes: Cert.cert list -> bytes
// definition CertificateListBytes([]) = [||] 
// definition !c,cs. CertificateListBytes(c::cs) = CertificateBytes(c) @| CertificateListBytes(cs)
// 
// function val CertsBytes: Cert.cert list -> bytes
// definition !cs. CertsBytes(cs) = VLBytes 3 (CertificateListBytes(cs))
// 
// function val CertificateBytes: Cert.cert list -> bytes
// definition !certs. CertificateBytes(certs) = MessageBytes(HT_certificate,CertsBytes(certs))
// 
// val makeCertificateBytes: certs:Cert.cert list -> msg:bytes { msg = CertificateBytes(certs) }
// val parseCertificate: payload:bytes -> (certs:Cert.cert list{ MessageBytes(HT_certificate,CertsBytes(certs)) = CertificateBytes(certs) } ) Result
// 
// /// Server Hello Done
// 
// val serverHelloDoneBytes: msg:bytes { msg = Message(HT_server_hello_done,[||]) }
// 
// /// Client Key Exchange (for now only for RSA); note that this message is randomized.
// 
// predicate val ClientKeyExchangeBytes: pms * pkey * bytes -> bool (* with some injectivity properties *)
// definition !pms,pkey. ClientKeyExchangeBytes(pms,pkey,msg) =
//   ?cipher. Encrypted(pms,pkey,cipher) /\ msg = MessageBytes(HT_client_key_exchange, cipher)
// 
// //TODO makeClientKeyExchangeBytes actually generates the pms?!
// 
// val makeClientKexRsaBytes: pms:pms -> pkey:pkey -> msg:bytes { ClientKeyExchangeBytes(pms,pkey,msg) }  
// val parseClientKexRsa: si:SessionInfo -> payload:bytes -> pms:pms { !cs. si.serverID = Some(cs)  = ClientKeyExchangeBytes(pms,CertsPKey(cs),MessageBytes(HT_client_key_exchange,payload)) } 
// 
// /// State-machine invariants (sample)
// 
// // Full handshake, RSA with anonymous client, waiting for ClientKeyExchange:
// 
// config, si, log { 
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,    certs, ts 
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(certs)
//       @|  serverHelloDoneBytes
//      
//  /\ (si.sessionID = [||] \/ si.sessionID <> clientSid) (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.maxVer) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ si.compression in config.compressions
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(certs)
// }
// 
// // Idem, after a few more steps
// 
// config, si, log, pms {
// // ? clientVer clientSid, clientCipherSuites, clientCm, clientExt,     cs, ts,    cipher  
//     log = ClientHelloBytes(clientVer         , si.crand, clientSid   , clientCipherSuites, clientCm      , clientExt)
//       @|  ServerHelloBytes(si.protocolVersion, si.srand, si.sessionID, si.cipherSuite    , si.compression, serverExt)
//       @|  CertificateBytes(cs)
//       @|  serverHelloDoneBytes
// 	  @|  ClientKeyExchangeBytes(cipher)
//      
//  /\ si.sessionID <> clientSid (* full handshake *)
//  /\ si.protocolVersion = Min(clientVer, config.ver) 
//  /\ si.cipherSuite in clientCipherSuites 
//  /\ si.cipherSuite in config.cipherSuites 
//  /\ si.compression in clientCm
//  /\ Extensions(clientExt,serverExt)
// 
//  (* RSA-specific *)
//  //\ config says anon client
//  /\ si.cipherSuite = CipherSuite(RSA,ts)
//  /\ si.clientID = None
//  /\ si.serverID = Some(cs)
// 
//  (* after ClientKeyExchange *)
//  /\ ...
// 
//  (* after accepting Finished *) 
//  /\ ( Honest(pms) /\ StrongHS(si.cipherSuite) -> ?clientConfig. ClientFinished(clientConfig,si) /\ clientVer = clientConfig.maxVer /\ ...  (* we may also rewrite the whole invariant by unification *) ) 
// 
// }
// 
// 
// 
