#! /usr/bin/env python

# --------------------------------------------------------------------
import sys, os, re, time, json, xml.etree.ElementTree as etree

# --------------------------------------------------------------------
MSBUILD = 'http://schemas.microsoft.com/developer/msbuild/2003'

FS7DEFAULT = [
  'Error',
  'TLSConstants',
  'TLSInfo',
  'DataStream',
  'Alert',
  'AppFragment',
  'HSFragment',
  'TLSFragment',
  'AppData',
  'StatefulPlain',
  'LHAEPlain',
  'MAC',
  'Encode',
  'LHAE',
  'StatefulLHAE',
  'Record',
  'Handshake',
  'Dispatch',
  'TLS',
  'UTLS',
]

FS7APPS = [ 'PwToken', 'PwApp' ]

MKHEADER = '''\
include ../Makefile.config

lib7      = ../../../lib/fs7-interfaces/
libperv   = $(lib7)pervasives.fs7 $(lib7)tuples.fs7
lperv     = -pervasives $(lib7)pervasives.fs7 -tuples $(lib7)tuples.fs7
libfs7    = $(lib7)pi.fs7 $(lib7)formulas.fs7
f7timeout = 1
f7defs    = avoid verify ideal

override f7flags += \\
  -timeout $(f7timeout) $(patsubst %%,--define %%,$(f7defs)) \\
  --verbose -nokindcheck $(lperv) $(libfs7)

xunit ?= xunit.xml

.PHONY: default clean check-xunit

-include Makefile.tc7

# default verification targets 
default: %(fs7default)s

#==Categories of .fs7 files==
#
# trusted: these files are not supposed to be verified, but we rely on
# their .fs7 files for verification:
#
#   Base: Bytes DER Tcp Range
#
#   CoreCrypto wrappers: RSAKeys DHGroup HASH HMAC TLSPRF
#
#   Key management: Cert, SessionDB
#
#
# idealizing: these are .fs7 files for .fs files with #ideal flags
# this flag is used to define ideal variants of the modules
#
#   Sig MAC ENC LHAE PRF CRE RSA DH
#
# the Makefile rules by default verify with --define ideal; additional
# typing is needed for some modules: Encode and LHAE are typechecked
# against multiple flags
#
#
# protocol: these .fs7 files verify the trunk of TLS building on
# the cryptographic guarantees provided by the interfaces of idealized
# modules:
# 
#   DataStream, AppFragment, HSFragment, TLSFragment, StatefulPlain,
#   LHAEPlain, StatefulLHAE, Record, Alert, Handshake, AppData,
#   Dispatch, TLS, UTLS
#
# Current verification status:
# - TLSConstants.tc7 fails on recently added list primitives.
# - Encode.tc7 fails on full correctness for decryption.
# - Handshake.tc7 still fails outside TLS 1.2 for DHE and RSA.
# - Dispatch.tc7 
# - <idealizing modules>.tc7 mostly fail because of CoreCrypto dependencies, 
# - MAC.tc7 typechecks

clean:
	rm -f *.smp *.tc7
''' % dict(fs7default = ' '.join([x + '.tc7' for x in FS7DEFAULT]))

# --------------------------------------------------------------------
class Object(object):
    def __init__(self, **kw):
        self.__dict__.update(kw)

# --------------------------------------------------------------------
def _options(args):
    from optparse import OptionParser

    parser = OptionParser(usage = "%prog: [options] file.fsproj")
    parser.add_option('-I', None,
                      action  = 'append',
                      dest    = 'includes',
                      default = [],
                      metavar = 'DIR',
                      help    = 'Add DIR to include path')
    parser.add_option('-m', '--mode',
                      action  = 'store',
                      default = 'makefile',
                      metavar = 'MODE',
                      help    = 'set output mode to MODE')

    options, args = parser.parse_args(args)

    if len(args) != 1:
        parser.error('exactly one .fsproj file must be given')

    options.fsproj = args[0]

    return options


# --------------------------------------------------------------------
class TopoSortCycleException(Exception):
    pass

def topoiter1(D, k, sk, seen = None):
    seen = dict() if seen is None else seen
    flag = seen.get(k, 0)

    if flag < 0:
        print [k] + sk
        raise TopoSortCycleException()
    if flag > 0:
        return

    seen[k] = -1
    for x in D.get(k, []):
        for y in topoiter1(D, x, [k] + sk, seen):
            yield y
    seen[k] = 1

    yield k

def topoiter(D):
    seen = dict()
    for k in D.iterkeys():
        for x in topoiter1(D, k, [], seen):
            yield x

# --------------------------------------------------------------------
class FS7Deps(object):
    @staticmethod
    def by_compilation_order(files):
        return [ \
            (files[i], ['%s.fs7' % (x,) for x in files[:i]]) \
                for i in xrange(len(files))
        ]

    @staticmethod
    def by_parsing(srcdir, files):
        srcfiles = dict([(x.lower(), x) for x in os.listdir(srcdir)])
        lowfiles = [x.lower() for x in files]
        alldeps  = dict()

        for name in files:
            modules  = set()

            for ext in ['.fs', '.fsi', '.fs7']:
                contents = srcfiles[name.lower() + ext]
                contents = open(os.path.join(srcdir, contents), 'r').read()
                contents = re.sub(r'\(\*(?:.|\r|\n)*?\*\)', '', contents, 0)
                contents = re.sub(r'".*?"', '', contents)
                contents = contents.splitlines()
                contents = [re.sub(r'//.*', '', x) for x in contents]
                contents = [re.sub(r'\s+', ' ', x.strip()) for x in contents]
    
                for line in contents:
                    m = re.search(r'^open (\w+)', line)
                    if m is not None:
                        modules.add(m.group(1).lower())
                    else:
                        for m in re.finditer(r'(\w+?)\.\w+', line):
                            modules.add(m.group(1).lower())

            alldeps[name.lower()] = modules.intersection(lowfiles)

        for name in topoiter(alldeps):
            for d in set(alldeps[name]): # copy
                alldeps[name].update(alldeps[d])

        # Reorder using user ordering
        for name in alldeps.iterkeys():
            alldeps[name] = [x for x in lowfiles if x in alldeps[name]]
        alldeps = [(x, alldeps[x]) for x in lowfiles if x in alldeps]

        # Go back to FS name (with correct case)
        def _norm(x, y):
            realname = os.path.splitext(srcfiles[x + '.fs7'])[0]
            realdeps = [srcfiles[z + '.fs7'] for z in y]
            return (realname, realdeps)

        return [_norm(x, y) for (x, y) in alldeps]

# --------------------------------------------------------------------
def _main():
    options = _options(sys.argv[1:])

    with open(options.fsproj, 'r') as stream:
        doc = etree.parse(stream)

    files  = doc.findall('.//{0}ItemGroup/*'.format('{%s}' % (MSBUILD,)))
    files  = [x.get('Include') for x in files if x.get('Include') is not None]
    files  = [x for x in files if os.path.splitext(x)[1] == '.fs7']
    files  = [os.path.splitext(x)[0] for x in files]
    srcdir = os.path.dirname(options.fsproj) or os.path.curdir

    fs7deps    = FS7Deps.by_parsing(srcdir, files)
    fs7deps_m  = dict(fs7deps)
    fs7default = [x for (x, _) in fs7deps if x in FS7DEFAULT]

    if options.mode == 'makefile':
        print "# -*- Makefile -*-"
        print "# Automatically generated by: %s" % (' '.join(sys.argv),)
        print "# Generated on %s" % (time.ctime(),)
        print
        print MKHEADER
        print "# ----- BEGIN AUTO FS7 -----"
        for name, deps in fs7deps:
            fargs = dict(name = name, mod = name.lower(), deps = ' '.join(deps))
            print '%(name)s.tc7: $(libperv) $(libfs7) %(deps)s %(name)s.fs7 %(name)s.fs %(name)s.fs7' % fargs
            print '\t@echo '
            print '\t@echo Lemma $@'
            print '\t$(f7) $(f7flags) -scripts %(name)s %(deps)s %(name)s.fs7 %(name)s.fs' % fargs
            print '\t@touch $@'
            print
        print 'check-xunit: clean'
        print '\t../scripts/xunit-tc7 --xunit=$(xunit) %s' % (' '.join(fs7default),)
        print "# ----- END AUTO FS7 -----"

    if options.mode == 'defaults':
        print ' '.join(fs7default)

    if options.mode == 'json':
        jsondata = { name: [os.path.splitext(x)[0] for x in fs7deps_m[name]] \
                         for name in (fs7default + FS7APPS) }
        print json.dumps(jsondata)

# --------------------------------------------------------------------
if __name__ == '__main__':
    _main()
