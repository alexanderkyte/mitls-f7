module PRF

// This module implements the PRFs keyed by master secrets, 
// for two purposes: MACing the verifyData and deriving the connection keys. 
// (CRE independently implements extraction.
// TLS using the same hash functin based techniques for this, 
// i.e. PRFs keyed by pre master secrets.)

open Bytes
open TLSConstants
open TLSInfo
open StatefulLHAE

// Master secrets are used to derive key materials. 
// Compared with standard (non-tls) key derivation,
// - the label is hardcoded & implicit; 
// - the seed (crandom @| srandom) is retrieved from the epoch

type repr = (;48)lbytes
//#begin-abstraction

// We need descriptors for the algorithm keyed by PMS and MS (named "PRF" in TLS)
// Given pv and cs, and except for SSL3, 
// the same algorithm is used for extraction, key derivation, and verifyData
// TODO migrate to TLSPRF? adapt the code there
type prfAlg = // can't be folded back to the sums in TLSConstants; we need to use it in TLSPRF too. 
  | PRF_TLS_1p2 of macAlg // typically SHA256 but may depend on CS
  | PRF_TLS_1p01           // MD5 xor SHA1
  | PRF_SSL3_nested        // MD5(SHA1(...)) for extraction and keygen
  | PRF_SSL3_concat        // MD5 @| SHA1    for VerifyData tags

val prfAlgOf: SessionInfo -> prfAlg

// precise index for master secrets is a function of session info (involving pmsdata decryption)
//CF we cannot use just csr, because of MiTM forwarding honest nonces

type msIndex =  // We record the parameters used to derive this MS: 
  pms   : PMS.pms * // the pms and its indexes  
  csr   : csrands *                                               // the nonces  
  creAlg: prfAlg                                                 // the PMS-PRF algorithm
   
function val MsI: SessionInfo -> msIndex 
//TODO: logically define this function.
//TODO: avoid in code: do we really want to decrypt? 
//MK: Maybe have a function msF: pms -> SessionInfo -> msindex

val safeMS_msIndex: msIndex -> bool

private type (;i:msIndex) ms = {bytes: repr}

// This index additionally records the *local* session info.
type (;si:SessionInfo) masterSecret = (;MsI(si)) ms 
//#end-abstraction

// We have two notions of conditional safety (logically defined in TLSInfo.fs7)
// SafeMS_SI for Finished messages, when the pms is ideal and hashAlg is strong
// SafeHS_SI for Key derivation,    additionally requiring agreement on committed parameters.

// Ideally, we maintain two logs
// - all authentic Finished messages so far, to filter out forgeries in their "MAC verify". 
// - all safe connection keys generated so far, to share them with the second, matching ideal key derivation.


(** Master secrets are either ideally sampled or concretely derived & coerced *) 

val sample: si:SessionInfo -> (;si)masterSecret 
//#begin-coerce
//the precondition of coerce excludes both idealizations.
val coerce: si:SessionInfo {not SafeMS_SI(si)} -> repr -> (;si)masterSecret 
//#end-coerce


//ask from LHAE.fs7 repeated here to help Z3
private ask !ki,si,enc,mac. 
     TLSConstants.CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = TLSConstants.MACOnly(mac) 
  => LHAE.LHAEKeySize(ki) = TLSConstants.MacKeySize(mac)

private ask !cs,pv,mac. 
     CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) 
  => KeyExtensionLength(pv,cs) = MacKeySize(mac)+MacKeySize(mac)
private ask !cs,pv,mac. 
     CipherSuiteAuthEncAlg(cs,pv) = MACOnly(mac) 
  => LHAE.LHAEKeySize_AEAlg(MACOnly(mac)) = TLSConstants.MacKeySize(mac)
private ask !ki,mac. 
     CipherSuiteAuthEncAlg(EpochSI(ki).cipher_suite,EpochSI(ki).protocol_version) = MACOnly(mac) 
  => LHAE.LHAEKeySize(ki) = TLSConstants.MacKeySize(mac)


(** Key derivation **) 

private val real_keyGen: 
  ci:ConnectionInfo{
      EpochSI(ci.id_in)=EpochSI(ci.id_out) /\ 
      IsSuccEpoch(ci.id_in) /\ IsSuccEpoch(ci.id_out) /\ 
      not Auth(ci.id_in) /\ not Auth(ci.id_out)} ->  
  (;EpochSI(ci.id_out))masterSecret ->
  ( w:(;ci.id_out)StatefulLHAE.writer * r:(;ci.id_in) StatefulLHAE.reader ) 
//      { StatefulLHAE.History(ci.id_out,WriterState,w) = StatefulPlain.EmptyHistory(ci.id_out) /\
//        StatefulLHAE.History(ci.id_out,ReaderState,r) = StatefulPlain.EmptyHistory(ci.id_in)}

// TODO: adapt to use StAE's tight indexes instead of epochs.
type keysentry = (e:epoch * e':epoch * ms:(;EpochSI(e)) masterSecret * bytes * (;e)StatefulLHAE.reader * (;e')StatefulLHAE.writer) 
private val keyslog: keysentry list ref 
val keysassoc: e:epoch -> e':epoch -> ms:(;EpochSI(e)) masterSecret -> bytes -> keysentry list -> ((;e)StatefulLHAE.reader * (;e')StatefulLHAE.writer) option

// Ideally, the server commits to using at most 
// (an extension of) this si for keyGen with matching (si.cr,si.sr)
// We could enforce commitments by adding a post-condition to keyCommit  
// and a matching pre-condition to the server-side keyGen.

val keyCommit: 
  ci:ConnectionInfo{IsSuccEpoch(ci.id_in)} -> unit

val keyGen: 
  ci:ConnectionInfo{IsSuccEpoch(ci.id_in)} -> (;EpochSI(ci.id_out))masterSecret -> 
  ( w:(;ci.id_out)StatefulLHAE.writer * r:(;ci.id_in) StatefulLHAE.reader ) 
  { StatefulLHAE.History(ci.id_out,WriterState,w) = StatefulPlain.EmptyHistory(ci.id_out) /\
    StatefulLHAE.History(ci.id_out,ReaderState,r) = StatefulPlain.EmptyHistory(ci.id_in)}

(* typing the keys log for the ideal functionality *)
//private type entry = (ems:(e12:(epoch * epoch) * (;Fst(e12))masterSecret) * 
//                   ((;Fst(Fst(ems)),ReaderState)state * (;Snd(Fst(ems)),WriterState)state)) 
//private val log: entry list ref 



(** VerifyData authenticator in Finished messages **)

// Master secrets are also used to generate and check verifyData tags,
// providing conditional authentication of the (abstract) VerifyData predicate.

// We specify it as we do for MACs,
// whereas we have a stronger PRF assumption.
// TODO reduction from joint MAC & KDF to PRF. 

// Some verbatim handshake message log...
// MACed into tags (with a fixed, irrelevant length) 

type text = bytes
type tag = bytes

// Abstract predicate authenticated by the Finished messages.
//CF we used to index it by epoch, now by SessionInfo, but this is still too wide:
//CF the first index should be F(si), keeping only the pms, pv, and nonces.
predicate VerifyData of SessionInfo * Role * text

// role & text are jointly authenticated
type entry = si:SessionInfo * r:Role * t:text {VerifyData(si,r,t)}
private val log: entry list ref
private val mem: si:SessionInfo -> r:Role -> t:text -> entry list -> b:bool{ b=true => VerifyData(si,r,t) }
//private val cons: si:SessionInfo -> tag -> r:Role -> t:text {VerifyData(si,r,t)} -> entry list -> entry list

private val verifyData: si:SessionInfo -> (;si) masterSecret -> r:Role -> t:text -> tag 

(* MACing *)
val makeVerifyData: 
  si:SessionInfo -> (;si) masterSecret -> 
  r:Role -> t:text{VerifyData(si,r,t)} -> 
  tag (* length depends on cs, 12 by default *)

(* MAC verifying *)
val checkVerifyData: 
  si:SessionInfo -> (;si) masterSecret ->
  r:Role -> t:text -> tag:tag (* the expected value *) ->
  b:bool{(b = true /\ SafeHS_SI(si)) => VerifyData(si,r,t)} 
  

(** ad hoc SSL3-only function; untrusted. **) 

//CF we need to exclude calls to this function when SafeHS_SI(si)!
val ssl_certificate_verify: 
  si:SessionInfo -> (;si)masterSecret ->
  TLSConstants.sigAlg -> bytes -> bytes


private val epochs:ConnectionInfo -> epoch * epoch





///CF attic, to be deleted soon...
//CF Markulf, what to do with those?  
(*MK SHOULD BE:
private type (;pms:Pms,csr:csrands) protoMasterSecret = { bytes: repr }

private type (;si:SessionInfo) masterSecret = {
  protoms    : (;(;GetPMS(si),si.csrands) protoMasterSecret;         
}

val changeMasterSecret: si:SessionInfo -> (;GetPMS(si),si.csrands) protoMasterSecret{?ki. EpochSI(ki)=si /\ Complete(ki,..)} -> (;si) masterSecret
*)

(* MK !! causes logical inconsistency
function val Epochs: 'a -> 'b
private definition !ci,r,e_in,e_out.
	(ci = {role=Client;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_in,ci.id_out) ) \/
	(ci = {role=Server;id_rand=r;id_in=e_in;id_out=e_out} /\
	 Epochs(ci) = (ci.id_out,ci.id_in) )
*)
//MK ask !si, si'. SafeHS_SI(si) /\ SafeHS_SI(si') /\ si.csrands=si.csrands => CS(si)=CS(si')
