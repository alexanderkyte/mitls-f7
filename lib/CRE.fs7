module CRE

open Bytes
open TLSConstants
open TLSInfo
open PMS
open PRF

//CF temporary
private val todo: string -> unit { false } 

// concrete PMS --> MS derivation.
private val extractMS: si:SessionInfo {not SafeMS_SI(si)} -> pms -> p:bytes -> (;si) PRF.masterSecret

(** RSA ciphersuites **) 

//CF actually a private type 
type rsaentry = pk:RSAKey.pk * cv:ProtocolVersion * pms:(;pk,cv)rsapms * csr:csrands * pa:prfAlg * ms:(;(RSAPMS(pk,cv,pms),csr,pa)) ms
private val rsalog: rsaentry list ref 

private val rsaassoc: 
    pk:RSAKey.pk -> cv:ProtocolVersion -> pms:(;pk,cv)rsapms -> csr:csrands -> pa:prfAlg-> 
    (pk':RSAKey.pk * cv':ProtocolVersion * pms':(;pk',cv')rsapms * csr':bytes * pa':prfAlg * ms':(;(RSAPMS(pk',cv',pms'),csr',pa')) ms) list -> 
	ms:(;(RSAPMS(pk,cv,pms),csr,pa)) ms option

// CF what for?
private val accessRSAPMS: pk:RSAKey.pk -> cv:ProtocolVersion -> (;pk,cv) rsapms -> rsarepr

val extractRSA:
    si:SessionInfo ->
	cv:ProtocolVersion ->
    pms: (;Cert.RSAPKCert(si.serverID),cv) rsapms 
	// { DecryptedPMS(si.pmsdata,pms)  } 
	->
    (;si) PRF.masterSecret


open DHGroup

//CF actually a private type
type dhentry = p:p * g:(;p) g * gx:(;p) elt * gy:(;p) elt * pms:(;p,g,gx,gy) dhpms * csr:csrands * pa:prfAlg * ms:(;(DHPMS(g,p,gx,gy,pms),csr,pa)) PRF.ms
private val dhlog: dhentry list ref 

val dhassoc: p:p -> g:(;p) g -> gx:(;p) elt -> gy:(;p) elt -> pms:(;p,g,gx,gy) dhpms -> csr:csrands -> pa:prfAlg -> 
             (p':p * g':(;p') g * gx':(;p') elt * gy':(;p') elt * pms':(;p',g',gx',gy') dhpms * csr':csrands * pa':prfAlg * (;(DHPMS(p',g',gx',gy',pms'),csr',pa')) PRF.ms) list -> 
             (;(DHPMS(p,g,gx,gy,pms),csr,pa)) PRF.ms option

private val accessDHPMS: p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms -> bytes

val extractDHE:
    si:SessionInfo ->
    p:DHGroup.p -> g:(;p)DHGroup.g -> gx:(;p)DHGroup.elt -> gy:(;p)DHGroup.elt ->
    pms: (;p,g,gx,gy)dhpms ->
    (;si) PRF.masterSecret
