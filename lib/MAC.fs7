module Mac

open Bytes
open Algorithms
open TLSInfo

/// a refined, ideal interface for indexed MACs
/// this file is loosely synchronized with cma/mac2.fs7

type id = {ki:TLSInfo.KeyInfo; tlen:int}
predicate val CMA: id -> bool

// id is an abstract index type managed by the protocol
// id may e.g. determine the choice of algorithms, 
// so in principle the sizes should also be indexed by id

//TLS: algorithms and sizes for keys and tags are in algorithms. 
//TLS: how to logically go from id to Algorithms.hashAlg ?
//     this is *some* ki.sinfo.cipher_suite
//     also confusing hash and mac algorithms for now. 

// this could also be imported; we had (;ki) ltext ? 

//type (;id:id) keybytes = b:bytes{Length(b)=KeySize(id)}
//type (;id:id) key = {bytes: (;id) keybytes} 

//function val TagSize: id -> int // to be removed? 
//val tagsize: id:id -> n:int{n=TagSize(id)} 
//type (;id:id) tag = b:bytes{Length(b) = TagSize(id)}

// removed internal stuff for now 

predicate Msg of KeyInfo * MACPlain.MACPlain
assume !ki,t. Corrupt(ki) => Msg(ki,t)

val MAC:    id:id -> k:(;id.ki) MACKey.key -> t:(;id.ki,id.tlen)MACPlain.MACPlain{Msg(id.ki,t)} -> (;id.ki,id.tlen) MACPlain.MACed
val VERIFY: id:id -> k:(;id.ki) MACKey.key -> t:(;id.ki,id.tlen)MACPlain.MACPlain -> (;id.ki,id.tlen) MACPlain.MACed -> 
  v:bool{ (v=true (*/\ CMA(id)*) ) => Msg(id.ki,t) }
