module CipherSuites

open Bytes
open Algorithms
open Error

//ask !x. x <= x
ask 0 <= 1
ask !l. (0 <= l /\ l <> 0) => l >= 1
//ask !l,n. l > n => l >= (n+1)
ask !l. l > 1 => l >= 2
ask 0 <= 2


(*** Following RFC5246 A.5 *)

private type SCSVsuite =
    | TLS_EMPTY_RENEGOTIATION_INFO_SCSV

private type cipherSuite = // internal; kept abstract in the .fsi
    | NullCipherSuite
    | CipherSuite of kexAlg * authencAlg
    | OnlyMACCipherSuite of kexAlg * hashAlg
    | SCSV of SCSVsuite

type cipherSuites = cipherSuite list

type Compression =
    | Null

type ProtocolVersion =
    | SSL_3p0   
    | TLS_1p0   
    | TLS_1p1   
    | TLS_1p2   

//CF Bad name. We'll need VersionBytes to be injective; we can verify it in principle.
function val VersionBytes: ProtocolVersion -> bytes
val versionBytes: pv:ProtocolVersion -> b:bytes{Length(b) = 2 /\ b = VersionBytes(pv)}
val parseVersion: b:bytes{Length(b) = 2} -> (pv:ProtocolVersion{ b= VersionBytes(pv)}) Result
val minPV: a:ProtocolVersion -> b:ProtocolVersion -> c:ProtocolVersion
//CF what's this refinement?? adjust on demand
//  {(a < b /\ c = a) \/ (a >= b /\ c = b)}

(* FIXME: same duplication between logical and concrete function definitions, 
   already seen in Algorithms. 
   CF: we could save a bit by not making cipherSuite abstract for F7.
   *)
predicate val IsNullCiphersuite: cipherSuite -> bool
assume !x. IsNullCiphersuite(x) <=> x = NullCipherSuite
val nullCipherSuite: c:cipherSuite{IsNullCiphersuite(c)}
val isNullCipherSuite: c:cipherSuite -> r:bool{r=true => IsNullCiphersuite(c)}

predicate val IsOnlyMACCiphersuite: cipherSuite -> bool
assume !x. (IsOnlyMACCiphersuite(x) <=> ?z,t. x = OnlyMACCipherSuite(z,t))
val isOnlyMACCipherSuite: c:cipherSuite -> r:bool{r=true => IsOnlyMACCiphersuite(c)}


(* TODO: predicates similar to the ones above, to be done when handling handshake *)
val isAnonCipherSuite: cipherSuite -> bool
val cipherSuiteRequiresKeyExchange: cipherSuite -> bool
val canEncryptPMS: cipherSuite -> bool
val contains_TLS_EMPTY_RENEGOTIATION_INFO_SCSV: cipherSuites -> bool
val verifyDataLen_of_ciphersuite: cipherSuite -> int
val prfHashAlg_of_ciphersuite: cipherSuite -> hashAlg
val verifyDataHashAlg_of_ciphersuite: cipherSuite -> hashAlg

val macAlg_of_ciphersuite: cipherSuite -> hashAlg
val encAlg_of_ciphersuite: cipherSuite -> cipherAlg

val compressionBytes: Compression -> b:bytes{Length(b)=1}
(* FIXME: We can say that the length of the following byte array is the same of the length of the returned list.
   1) do we want/need to say this?
   2) how do we talk about lengths of lists in F7?
   CF: we can even typecheck it, but this is low priority
*)
val parseCompression: b:bytes{Length(b)=1} -> Compression Result
val parseCompressions: bytes -> Compression list

val cipherSuiteBytes: c:cipherSuite -> b:bytes{Length(b)=2}
val cipherSuite_of_bytes: b:bytes{Length(b)=2} -> cipherSuite Result

function val CipherSuitesBytes: cipherSuites -> bytes 
// this parsing function may fail if b has the wrong length,
// or if we were strict on unknown ciphersuites
val parseCipherSuites: b:bytes -> (css:cipherSuites {b=CipherSuitesBytes(css)}) Result
val bytes_of_cipherSuites: css:cipherSuites -> b:bytes {b=CipherSuitesBytes(css)}

val getKeyExtensionLength: ProtocolVersion -> cipherSuite -> int

val PVRequiresExplicitIV: ProtocolVersion -> bool

(* Not for verification, just to run the implementation *)

type cipherSuiteName =
    | TLS_NULL_WITH_NULL_NULL            

    | TLS_RSA_WITH_NULL_MD5              
    | TLS_RSA_WITH_NULL_SHA              
    | TLS_RSA_WITH_NULL_SHA256           
    | TLS_RSA_WITH_RC4_128_MD5           
    | TLS_RSA_WITH_RC4_128_SHA           
    | TLS_RSA_WITH_3DES_EDE_CBC_SHA      
    | TLS_RSA_WITH_AES_128_CBC_SHA       
    | TLS_RSA_WITH_AES_256_CBC_SHA       
    | TLS_RSA_WITH_AES_128_CBC_SHA256    
    | TLS_RSA_WITH_AES_256_CBC_SHA256 
       
    | TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA   
    | TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA   
    | TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA  
    | TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA  
    | TLS_DH_DSS_WITH_AES_128_CBC_SHA    
    | TLS_DH_RSA_WITH_AES_128_CBC_SHA    
    | TLS_DHE_DSS_WITH_AES_128_CBC_SHA   
    | TLS_DHE_RSA_WITH_AES_128_CBC_SHA      
    | TLS_DH_DSS_WITH_AES_256_CBC_SHA    
    | TLS_DH_RSA_WITH_AES_256_CBC_SHA    
    | TLS_DHE_DSS_WITH_AES_256_CBC_SHA   
    | TLS_DHE_RSA_WITH_AES_256_CBC_SHA    
    | TLS_DH_DSS_WITH_AES_128_CBC_SHA256 
    | TLS_DH_RSA_WITH_AES_128_CBC_SHA256 
    | TLS_DHE_DSS_WITH_AES_128_CBC_SHA256
    | TLS_DHE_RSA_WITH_AES_128_CBC_SHA256
    | TLS_DH_DSS_WITH_AES_256_CBC_SHA256 
    | TLS_DH_RSA_WITH_AES_256_CBC_SHA256 
    | TLS_DHE_DSS_WITH_AES_256_CBC_SHA256
    | TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

    | TLS_DH_anon_WITH_RC4_128_MD5       
    | TLS_DH_anon_WITH_3DES_EDE_CBC_SHA  
    | TLS_DH_anon_WITH_AES_128_CBC_SHA
    | TLS_DH_anon_WITH_AES_256_CBC_SHA  
    | TLS_DH_anon_WITH_AES_128_CBC_SHA256
    | TLS_DH_anon_WITH_AES_256_CBC_SHA256

val cipherSuites_of_nameList: cipherSuiteName list -> cipherSuites

