module StatefulAEAD

open TLSInfo
open Error
 
open Bytes

//CF 12/2: do we need pre/post on the ciphertext lengths?
//CF 21/4: cut prestate and State? 

private type (;ki:epoch) prestate = {
  key: (;ki) AEAD.AEADKey; // possibly stateful
  history: (;ki)StatefulPlain.history    // ghost state, except for the derived sequence number
}

predicate State of ki:epoch * (;ki)prestate

type (;ki:epoch) state = s:(;ki)prestate {State(ki,s)}

private definition !ki,s. State(ki,s) // KB: 21/4 Why do we need this?

function val History: e:epoch * (;e)state -> 'a //(;e)StatefulPlain.history
private definition !e,s. History(e,s) = s.history

// CF 21/4 typing should prevent mixing read/write states! 
// CF      can we keep state a public datatype and make reader/writer abstract?
type (;ki:epoch) reader = r:(;ki) state
type (;ki:epoch) writer = w:(;ki) state

//CF 21/4 patched, pls check; rediscuss COERCE/LEAK 
val GEN:    ki:epoch{Safe(ki)} -> (;ki) reader * (;ki)writer
val COERCE: ki:succEpoch{not Auth(ki)}  -> b:bytes{Length(b)=AEAD.AEADSize(ki)} -> (;ki)state
val LEAK:   ki:epoch{not Auth(ki)}  -> (;ki)state -> b:bytes

val history: ki:epoch -> s:(;ki) state -> h:(;ki)StatefulPlain.history{h=History(ki,s)}

// Ideally,
// the writer maintains a table (ki, h, ad, range, fragment, cipher) {...} [details?]
// when SAFE(ki), the writer uses 0s instead of the actual fragment
// when AUTH(ki), the reader decrypts by table lookup
// turning forgeries into errors; retrieving the "right" history index; returning the concrete decrypted range

//CF 21/4: STXT is an event tracking written fragments; not sure about details and contents ?!
//CF e.g.    * the decrypted rg is NOT authenticated
//CF         * the states are not necessarily synchronized; only the histories are when AUTH

type cipher = AEAD.cipher

predicate STXT of ki:epoch * (;ki)state * ad:(;ki)StatefulPlain.adata * r:range * (;ki,ad,r)StatefulPlain.fragment * cipher
assume !ki,s,ad,r,f,c. STXT(ki,s,ad,r,f,c)  // FIXME!!!
//	<=> AEAD.CTXT(ki,MakeAD(ki,s.history,ad),r,f,c)

val encrypt: ki:succEpoch -> 
  w:(;ki) writer -> 
  ad:(;ki)StatefulPlain.adata ->
  r:range ->
  f: (;ki,ad,History(ki,w),r) StatefulPlain.plain ->
  (w':(;ki) writer * c:cipher){
    History(ki,w') = StatefulPlain.ExtendHistory(ki,ad,History(ki,w),r,f) /\
    STXT(ki,w,ad,r,f,c)}

val decrypt: ki:succEpoch -> 
  rd:(;ki) reader -> 
  ad:(;ki)StatefulPlain.adata ->
  c:cipher ->
  res:((;ki) reader * rg:range * (;ki,ad,History(ki,rd),rg) StatefulPlain.plain) Result
  { !nrd,rg,f. res = Correct((nrd,rg,f)) => 
               (   History(ki,nrd) = StatefulPlain.ExtendHistory(ki,ad,History(ki,rd),rg,f) /\
                   Length(c)=Encode.RangeCipher(ki,rg) /\
 	         (Safe(ki) => STXT(ki,rd,ad,rg,f,c)) /\
                 (Auth(ki) => STXT(ki,rd,ad,rg,f,c))) }

//CF 21/4: as stated, we need the resulting readers and writers to have explicitly-updated histories (irrespective of AUTH)
//CF 21/4: can we return an option instead? Otherwise we may have to specify which errors can be returned.

