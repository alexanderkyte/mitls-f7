module AEAD

open TLSInfo
open Error
open DataStream
open AEADPlain

private type (;ki:KeyInfo) AEADKey =
    | MtE of ka:(;ki)MAC.key * ke:(;ki)ENC.state // {MtEKey(ki,(ka,ke))}
    | MACOnly of (;ki) MAC.key
(*  |   GCM of ke:(;ki:AENC.state)  *)

type cipher = bytes

// TODO: Define AEADSize. In the code, (AEADSize * 2) is computed in CipherSuites.getKeyExtensionLength
val GEN: ki:KeyInfo{Safe(ki)} -> encryptor:(;ki)AEADKey * decryptor:(;ki)AEADKey
val COERCE: ki:KeyInfo -> b:bytes{Length(b) = AEADSize(ki)} -> (;ki)AEADKey
val LEAK: ki:KeyInfo -> (;ki)AEADKey -> b:bytes{Length(b) = AEADSize(ki)}

val encrypt: ki:KeyInfo -> 
  (;ki) AEADKey ->  
  ad:(;ki) data ->
  rg:DataStream.range -> 
  p:(;ki,rg,ad) plain ->
  ((;ki) AEADKey * c:cipher){Length(c)=RangeCipher(ki,rg) /\ CTXT(ki,ad,p,c)}

val decrypt: ki:KeyInfo -> 
  (;ki) AEADKey -> 
  ad:(;ki) data ->
  c:cipher ->
  res: ((;ki) AEADKey * 
	rg:(rg:range{rg = CipherRange(ki,c)}) * 
	(;ki,rg,ad) plain) Result{
    (Safe(ki) => (!rg,p. (res = Correct(rg,p) <=> CTXT(ki,ad,p,c)))) /\
    (Auth(ki) => (!rg,p. (res = Correct(rg,p) =>  (?c. CTXT(ki,ad,p,c)))))}
      


(* TODOS: (KB: Done?) *)
(* - Add explicit ciphertext length *)
(* - Make all iv become iv3: Only TLS 1.0 will use iv, later versions don't. *)
(*	 The ciphertext has different lengths, depending on the version: *)
(*   In later versions it includes the fresh iv, in early versions it doensn't. *)

