module TLSPlain

open TLSInfo

type Lengths (* abstractly, a list of desired ciphertext lengths *)
predicate val Head: Lengths -> int
predicate val Tail: Lengths -> Lengths
predicate val Cons: (int * Lengths) -> Lengths

predicate val CompatibleLengths: (KeyInfo * int * Lengths) -> bool
val estimateLengths: ki:KeyInfo -> n:int -> l:Lengths{CompatibleLengths(ki,n,l)}
private val fragmentSize: ki:KeyInfo -> l:Lengths -> n:int{CompatibleLengths(ki,n,l)} -> 
	                  f:int{CompatibleLengths(ki,n-f,Tail(l))}

(* Secret App Data *)
type (;ki:KeyInfo,l:Lengths) appdata (* The full buffer blessed by the application *)
val appdata: ki:KeyInfo -> l:Lengths -> b:bytes{CompatibleLengths(ki,Size(b),l)} -> 
                (;ki:KeyInfo,l:Lengths) appdata

type (;ki:KeyInfo,n:int) fragment = (* A single app data fragment, taken form the full blessed buffer *)
  | AppDataFragment of (;ki,n) appdata
  | KeyExchangeData of bytes

val concat_fragment_appdata: ki:KeyInfo -> n:int -> (;ki,n) fragment -> l:Lengths -> (;ki,l) appdata -> (;ki,Cons(n,l)) appdata

val app_fragment: ki:KeyInfo -> l:Lengths -> x:(;ki,l) appdata ->  ((n:int{n=Head(l)} * f:(;ki,n) fragment) * 
								    (t:Lengths{t=Tail(l)} * (;ki,t) appdata))

val pub_fragment: ki:KeyInfo -> b:bytes -> ((n:int * (;ki,n) fragment) * bytes) 
(* Note that n is *not* the length of the plaintext, it is the length of the target ciphertext *)

type (;ki:KeyInfo) mac (* The result of a MAC operation *)

type (;ki:KeyInfo) mac_plain (* The data to be MACed, typically fragment @| add_data *)
type (;ki:KeyInfo) add_data = bytes (* Additional public data to be included in MAC operations *)

val ad_fragment: ki:KeyInfo -> (;ki) add_data -> (;ki) fragment -> (;ki) mac_plain

type (;ki:KeyInfo,n:int) plain (* Content to be encrypted *)

val concat_fragment_mac_pad: ki:KeyInfo -> n:int -> (;ki,n) fragment -> (;ki) mac -> (;ki,n) plain (* plain includes padding *)

val split_mac: ki:KeyInfo -> n:int -> (;ki,n) plain -> ((;ki,n) fragment * (;ki) mac) (* Returns a random fragment if pad checking fails *)

(* Only for MACOnlyCipherSuites *)
val fragment_mac_to_cipher: ki:KeyInfo {IsMACOnlyCipherSuite(ki)} ->
							n:int -> (;ki,n) fragment -> (;ki) mac -> b:bytes{Length(b) = n}
val cipher_to_fragment_mac: ki:KeyInfo {IsMACOnlyCipherSuite(ki)} ->
							n:int -> b:bytes{Length(b) = n} -> ((;ki,n) fragment * (;ki) mac)
(* Only for NullCipherSuites *)
val fragment_to_cipher: ki:KeyInfo {IsNullCipherSuite(ki)} ->
						n:int -> (;ki,n) fragment -> b:bytes{Length(b) = n}
val cipher_to_fragment: ki:KeyInfo {IsNullCipherSuite(ki)} ->
						n:int -> b:bytes{Length(b) = n} -> (;ki,n) fragment