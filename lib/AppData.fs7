module AppData

open Data
open Sessions
open Formats
open Record
open Error_handling
open Stream 

type pre_app_state =
  {app_info: SessionInfo;
   app_incoming: stream;
   app_outgoing: stream}


predicate type preds =
  | ApplicationState of pre_app_state 
  | AppDataNextChunk of SessionInfo * bytes
  | ApplicationSend of SessionInfo * stream * bytes
  | InitAppState of pre_app_state

type app_state = (aps:pre_app_state){ApplicationState(aps)}

(* type app_state // abstract type at the implementation level *)

(* Application interface *)

(* Add data to be sent to the other party *)
val send_data: aps:app_state -> d:Data.bytes{AppDataNextChunk(aps.app_info,d)} -> app_state
(* Retrieve data that we received from the other party *)
val retrieve_data: app_state -> int -> (bytes * app_state) option

(* Dispatcher interface *)
val init : i:SessionInfo -> a:app_state{InitAppState(a)}

val next_fragment: aps:app_state -> int -> 
  (d:Record.fragment * aps':app_state{ApplicationSend(aps.app_info,aps.app_outgoing,d) /\ aps'.app_info = aps.app_info}) option

val recv_fragment: aps:app_state ->
          d:fragment{(?rs. ApplicationSend(OtherRole(aps.app_info),rs,d) /\ StreamBytes(aps.app_incoming) = PreviouslyRead(rs) ) \/ Compromised(OtherRole(aps.app_info))} ->
	  app_state Result

(* Application state definition *)
assume !aps. ApplicationState(aps) <=> (Stream(aps.app_incoming) /\ Stream(aps.app_outgoing) /\
					((?raps. ApplicationState(raps) /\ raps.app_info = OtherRole(aps.app_info) /\
					StreamBytes(aps.app_incoming) = PreviouslyRead(raps.app_outgoing) /\
					StreamID(aps.app_incoming) = StreamID(raps.app_outgoing)) \/
				      IsEmptyStream(aps.app_incoming) \/
				      Compromised(OtherRole(aps.app_info))))

(* When can we add data to the outgoing buffer *)
assume !aps,d. ApplicationState(aps) /\ AppDataNextChunk(aps.app_info,d) => StreamWrite(aps.app_outgoing,d)

(* When we can send data on the network from the outgoing stream *) 
assume !aps,d. ApplicationState(aps) /\ StreamRead(aps.app_outgoing,d) => ApplicationSend(aps.app_info,aps.app_outgoing,d)

theorem !info,hist,d. ApplicationSend(info,hist,d) =>
	(?aps. ApplicationState(aps) /\ info = aps.app_info /\ hist = aps.app_outgoing /\ StreamRead(aps.app_outgoing,d))

ask !aps,rs,d. ApplicationState(aps) /\ ApplicationSend(OtherRole(aps.app_info),rs,d) /\ StreamBytes(aps.app_incoming) = PreviouslyRead(rs) =>
		((StreamRead(rs,d) /\ StreamID(rs) = StreamID(aps.app_incoming)) \/ Compromised(OtherRole(aps.app_info)))

(* Initial application state *)
assume !aps. InitAppState(aps) <=> ( IsEmptyStream(aps.app_incoming) /\ IsEmptyStream(aps.app_outgoing) )

ask !aps. InitAppState(aps) => ApplicationState(aps)

